
<<<<<<< HEAD
--- App.css ---
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}


--- App.js ---
// --- src/App.js ---
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate, Outlet } from 'react-router-dom';
import { useAuth } from './context/AuthContext';

// --- Component Imports ---

// Common
import Navbar from './component/common/Navbar.js';

// General Pages (assuming src/component/pages/)
import HomePage from './component/pages/Home';
import UnauthorizedPage from './component/pages/UnauthorizedPage';
import NotFoundPage from './component/pages/NotFoundPage';

// Functional Area Pages (assuming src/component/Page/)
import LoginPage from './component/Page/Customer_Dash';
import RegistrationPage from './component/Page/Registration';
// import JobApplicationForm from './component/Page/JobApplicationForm.js';

// Customer Specific Pages (assuming src/component/Page/)
import Header from './component/Page/Header';
import TransferMoney from './component/Page/TransferMoney';
import CheckBalancePage from './component/Page/CheckBalance';
import TransactionHistoryPage from './component/Page/TransactionHistoryPage';

// Admin Specific Pages (assuming src/component/Page/Admin/)
import AdminDashboardPage from './component/Page/Admin/AdminDashboardPage';
import PendingApprovalsPage from './component/Page/Admin/PendingApprovaslPage.js'; // Corrected filename assumption
import AdminApplicationsListPage from './component/Page/Admin/AdminApplicationsListPage';
import AdminApplicationDetailPage from './component/Page/Admin/AdminApplicationDetailPage';
import JobApplicationForm from './component/Page/JobApplicationForm.js';

// Employee Specific Pages (assuming src/component/Page/Employee/)
import EmployeeDashboardPage from './component/Page/Employee/EmployeeDashboardPage';
import EmployeeDepositPage from './component/Page/Employee/EmployeeDepositPage';
import EmployeeWithdrawalPage from './component/Page/Employee/EmployeeWithdrawalPage';
import EmployeeCheckBalancePage from './component/Page/Employee/EmployeeCheckBalancePage';
import ApplyLoanPage from './component/Page/ApplyLoanPage.js'
import MyLoansPage  from './component/Page/MyLoanPage.js';
import PendingLoansPage from './component/Page/Admin/PendingLoansPage.js';
import PendingFdsPage from './component/Page/Admin/PendingFdsPage.js';
import ApplyFDPage from './component/Page/Fd.js';
import MyFdsPage from './component/Page/MyFD.js';

// import EmployeeDownloadHistoryPag from './component/Page/TransactionHistoryPage.js';



// --- Styling Imports ---
import 'bootstrap/dist/css/bootstrap.min.css'; // Keep if still used alongside MUI
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import theme from './styles/theme'; // Your custom MUI theme
import './styles/global.css'; // Your global styles

// --- Protected Route HOC ---
const ProtectedRoute = ({ allowedRoles }) => {
    const { authState } = useAuth();
    // console.log("ProtectedRoute Check:", { isLoggedIn: authState.isLoggedIn, userRole: authState.userRole, allowedRoles });

    if (!authState.isLoggedIn) {
        // Not logged in, redirect to login page, preserving the intended location
        return <Navigate to="/login" state={{ from: window.location.pathname }} replace />;
    }

    // Check if specific roles are required AND if the user has one of the allowed roles
    if (allowedRoles && allowedRoles.length > 0 && !allowedRoles.includes(authState.userRole)) {
        console.warn(`Access Denied: Route requires roles [${allowedRoles.join(', ')}], user has role '${authState.userRole}'`);
        // Logged in, but doesn't have permission for this specific route
        return <Navigate to="/unauthorized" replace />;
    }

    // If logged in AND (no specific roles required OR user has an allowed role), render the nested route
    return <Outlet />; // Outlet renders the matched nested child route
};

// --- Main App Component ---
function App() {
    const { authState } = useAuth();

    // Determine redirect path for already logged-in users trying to access /login
    const getHomeRouteForRole = (role) => {
        switch (role) {
            case 'ROLE_ADMIN':
                return '/admin/dashboard';
            case 'ROLE_EMPLOYEE':
                return '/employee/dashboard';
            case 'ROLE_USER':
                return '/header'; // Customer dashboard
            default:
                return '/'; // Fallback to public home
        }
    };

    return (
        <ThemeProvider theme={theme}>
            <CssBaseline /> {/* Applies baseline MUI styles */}
            <Router>
                <Navbar /> {/* Navbar is always visible */}
                <Routes>
                    {/* --- Public Routes --- */}
                    <Route path="/" element={<HomePage />} />
                    <Route
                        path="/login"
                        element={
                            authState.isLoggedIn ? (
                                <Navigate to={getHomeRouteForRole(authState.userRole)} replace />
                            ) : (
                                <LoginPage />
                            )
                        }
                    />
                    <Route path="/register" element={<RegistrationPage />} />
                    <Route path="/employee" element={<JobApplicationForm />} />
                    <Route path="/unauthorized" element={<UnauthorizedPage />} />

                    {/* --- Customer Routes --- */}
                    {/* Accessible by USER, ADMIN, EMPLOYEE */}
                    <Route element={<ProtectedRoute allowedRoles={['ROLE_USER', 'ROLE_ADMIN', 'ROLE_EMPLOYEE']} />}>
                        <Route path="/header" element={<Header />} /> {/* Customer dashboard */}
                        <Route path="/transfer" element={<TransferMoney />} /> {/* Customer transfers own money */}
                        <Route path="/check-balance" element={<CheckBalancePage />} /> {/* Customer checks own balance */}
                        <Route path="/history" element={<TransactionHistoryPage />} /> {/* Customer downloads own history */}
                        <Route path="/apply-loan" element={<ApplyLoanPage/>}/>
                        <Route path='/my-loans' element={<MyLoansPage/>}/>
                        <Route path='/apply-fd' element={<ApplyFDPage/>}/>
                        <Route path='/my-fds' element={<MyFdsPage/>}/>

                    </Route>

                    {/* --- Admin Routes --- */}
                    {/* Accessible ONLY by ADMIN */}
                    <Route element={<ProtectedRoute allowedRoles={['ROLE_ADMIN']} />}>
                        <Route path="/admin/dashboard" element={<AdminDashboardPage />} />
                        <Route path="/admin/pending" element={<PendingApprovalsPage />} /> {/* Manage Customer Approvals */}
                        <Route path="/admin/applications" element={<AdminApplicationsListPage />} /> {/* List Job Apps */}
                        <Route path="/admin/applications/:appId" element={<AdminApplicationDetailPage />} /> {/* Detail Job App */}
                        <Route path="/admin/loan/pending" element={<PendingLoansPage />} /> 
                        <Route path="/admin/fd/pending" element={<PendingFdsPage />} />
                        {/* Admin access to Employee routes is granted by the next block */}
                    </Route>

                    {/* --- Employee Routes --- */}
                    {/* Accessible by EMPLOYEE and ADMIN */}
                    <Route element={<ProtectedRoute allowedRoles={['ROLE_EMPLOYEE', 'ROLE_ADMIN']} />}>
                        <Route path="/employee/dashboard" element={<EmployeeDashboardPage />} />
                        <Route path="/employee/deposit" element={<EmployeeDepositPage />} /> {/* Deposit for customer */}
                        <Route path="/employee/withdraw" element={<EmployeeWithdrawalPage />} /> {/* Withdraw for customer */}
                        <Route path="/employee/check-balance" element={<EmployeeCheckBalancePage />} /> {/* Check any customer balance */}
                        {/* <Route path="/employee/download-history" element={<EmployeeDownloadHistoryPage />} /> Check any customer balance */}
                    </Route>

                    {/* --- Catch-all for 404 Not Found --- */}
                    {/* This should be the last route */}
                    <Route path="*" element={<NotFoundPage />} />

                </Routes>
            </Router>
        </ThemeProvider>
    );
}

export default App;

--- App.test.js ---
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


--- index.css ---
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}


--- index.js ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { AuthProvider } from './context/AuthContext';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <AuthProvider >
      <App />
    </AuthProvider>
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();


--- reportWebVitals.js ---
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


--- setupTests.js ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';


--- component\common\Navbar.js ---
import React from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext'; // Make sure to import useAuth

function Navbar() {
  const { authState, logout } = useAuth(); // Get auth state and logout function
  const navigate = useNavigate();

  const redirectToHome = () => {
    navigate("/"); // Correct navigate usage
  };

  return (
    <div>
      {/* Top Logo Section */}
      <div className="d-flex justify-content-center align-items-center py-2" style={{ backgroundColor: '#ffe600', position: 'fixed' }}>
        {/* Optional Logo or Title */}
      </div>

      {/* Bottom Navigation Section */}
      <nav className="navbar bg-black px-3" data-bs-theme="dark" style={{ position: 'sticky', top: 0, left: 0, width: '100%', zIndex: 1000 }}>
        <div className="container-fluid">
          <div className="row w-100">
            {/* Home Button */}
            <div className="col text-center">
              <button onClick={redirectToHome} className="btn btn-outline-light w-100">Home</button>
            </div>

            {/* Conditional Links Based on Auth State */}
            {!authState.isLoggedIn && (
              <>
                <div className="col text-center">
                  <Link to="/login" className="btn btn-outline-light w-100">Customer Booth</Link>
                </div>
                <div className="col text-center">
                  <Link to="/employee" className="btn btn-outline-light w-100">Employee Booth</Link>
                </div>
                {/* <div className="col text-center">
                  <Link to="/admin" className="btn btn-outline-light w-100">Admin Booth</Link>
                </div> */}
              </>
            )}

            {/* Links for Logged-in Users */}
            {authState.isLoggedIn && authState.userRole === 'ROLE_USER' && (
              <div className="col text-center">
                <Link to="/header" className="btn btn-outline-light w-100">My Account</Link>
              </div>
            )}

            {authState.isLoggedIn && authState.userRole === 'ROLE_EMPLOYEE' && (
              <div className="col text-center">
                <Link to="/employee/dashboard" className="btn btn-outline-light w-100">Employee Portal</Link>
              </div>
            )}

            {authState.isLoggedIn && authState.userRole === 'ROLE_ADMIN' && (
              <div className="col text-center">
                <Link to="/admin/dashboard" className="btn btn-outline-light w-100">Admin Portal</Link>
              </div>
            )}

            {/* Logout Button */}
            {authState.isLoggedIn && (
              <div className="col text-center">
                <button onClick={logout} className="btn btn-outline-danger w-100">Logout</button>
              </div>
            )}
          </div>
        </div>
      </nav>
    </div>
  );
}

export default Navbar;


--- component\cssfiles\Account.css ---
    /* account.css */

body {
    background: linear-gradient(135deg, #f6d365, #fda085); /* Gradient background */
    font-family: 'Arial', sans-serif;
  }
  
  .container {
    width: 100%;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: rgba(0, 0, 0, 0.3);
    position: absolute;
  }
  
  .form-container {
    background: #fff;
    padding: 50px;
    border-radius: 15px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    width: 350px;
    position: relative;
    overflow: hidden;
    transition: transform 0.3s ease-in-out;
  }
  
  .form-container:hover {
    transform: translateY(-10px);
  }
  
  h2 {
    text-align: center;
    color: #333;
    font-size: 24px;
    margin-bottom: 20px;
    font-weight: 700;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  }
  
  input {
    width: 100%;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid #ddd;
    border-radius: 8px;
    box-sizing: border-box;
    font-size: 16px;
    outline: none;
    transition: border-color 0.3s ease;
  }
  
  input:focus {
    border-color: #fda085;
  }
  
  button {
    width: 100%;
    padding: 15px;
    border: none;
    background: #fda085;
    color: white;
    font-size: 16px;
    cursor: pointer;
    border-radius: 8px;
    margin-top: 10px;
    transition: background-color 0.3s ease;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
  }
  
  button:hover {
    background: #f6d365;
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
  }
  
  button:active {
    transform: scale(0.98);
  }
  
  footer {
    position: absolute;
    bottom: 10px;
    width: 100%;
    text-align: center;
    color: #fff;
    font-size: 14px;
  }
  

--- component\cssfiles\CheckBalance.css ---
.check-balance-container {
    background-color: black;
    color: red;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  
  h2 {
    margin-bottom: 20px;
  }
  
  form {
    display: flex;
    flex-direction: column;
    width: 300px;
  }
  
  input {
    margin-bottom: 15px;
    padding: 10px;
    border: 2px solid red;
    border-radius: 5px;
    background-color: black;
    color: red;
  }
  
  input::placeholder {
    color: rgba(255, 0, 0, 0.7);
  }
  
  button {
    padding: 10px;
    background-color: red;
    color: black;
    border: none;
    border-radius: 5px;
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.3s;
  }
  
  button:hover {
    background-color: darkred;
  }
  
  .balance-text {
    margin-top: 20px;
    font-size: 18px;
    color: red;
  }
  
  .error-text {
    margin-top: 20px;
    font-size: 18px;
    color: red;
  }
  

--- component\cssfiles\Common.css ---
/* common.css */

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  body {
    background: #f3f4f6;
    font-family: 'Roboto', sans-serif;
    color: #333;
  }
  
  h2 {
    color: #333;
    font-size: 24px;
    font-weight: 700;
    margin-bottom: 20px;
    text-align: center;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
  }
  
  .container {
    padding: 20px;
    width: 100%;
    max-width: 800px;
    margin: 0 auto;
  }
  
  form {
    background: #fff;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }
  
  input, select, textarea {
    width: 100%;
    padding: 12px;
    margin: 10px 0;
    border-radius: 8px;
    border: 1px solid #ddd;
    font-size: 16px;
    outline: none;
    box-sizing: border-box;
    transition: border-color 0.3s ease;
  }
  
  input:focus, select:focus, textarea:focus {
    border-color: #fda085;
  }
  
  button {
    padding: 15px 25px;
    background: #fda085;
    border: none;
    color: white;
    font-size: 18px;
    cursor: pointer;
    border-radius: 8px;
    margin-top: 20px;
    transition: background-color 0.3s ease, transform 0.2s ease;
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
  }
  
  button:hover {
    background: #f6d365;
  }
  
  button:active {
    transform: scale(0.98);
  }
  
  button:disabled {
    background: #ddd;
    cursor: not-allowed;
  }
  
  nav {
    background: #333;
    color: white;
    padding: 15px 0;
    text-align: center;
    position: sticky;
    top: 0;
  }
  
  nav a {
    color: white;
    text-decoration: none;
    margin: 0 15px;
    font-size: 18px;
    font-weight: 600;
    transition: color 0.3s ease;
  }
  
  nav a:hover {
    color: #fda085;
  }
  
  footer {
    text-align: center;
    margin-top: 30px;
    padding: 20px;
    background: #333;
    color: white;
    font-size: 14px;
  }
  
  footer a {
    color: #fda085;
    text-decoration: none;
  }
  
  footer a:hover {
    text-decoration: underline;
  }
  
  /* 3D Button Effect */
  button {
    position: relative;
    overflow: hidden;
  }
  
  button::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 300%;
    height: 300%;
    background: rgba(0, 0, 0, 0.1);
    transition: all 0.5s ease;
    border-radius: 50%;
    transform: translate(-50%, -50%) scale(0);
    opacity: 0;
  }
  
  button:active::after {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }
  

--- component\cssfiles\Customer_Dash.css ---
/* Overall Login Container */
.login-container {
  background-color: black;
  color: red;
  height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  font-family: Arial, sans-serif;
  padding: 20px;
}

/* Heading Styling */
h2.text-center {
  font-size: 32px;
  color: red;
  margin-bottom: 30px;
  text-transform: uppercase;
  font-weight: bold;
}

/* Form Styling */
form {
  width: 100%;
  max-width: 400px;
  padding: 20px;
  background-color: #111;
  border-radius: 8px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
}

.form-group {
  margin-bottom: 20px;
}

label {
  font-size: 14px;
  color: red;
  margin-bottom: 5px;
  display: block;
}

/* Input Field Styling */
input.form-control {
  width: 100%;
  padding: 10px;
  border: 2px solid red;
  border-radius: 5px;
  background-color: #222;
  color: red;
  font-size: 16px;
  outline: none;
}

input.form-control:focus {
  border-color: #ff4444;
  background-color: #333;
}

input::placeholder {
  color: rgba(255, 0, 0, 0.7);
}

/* Button Styling */
button.btn {
  padding: 12px;
  font-size: 16px;
  font-weight: bold;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  transition: background-color 0.3s ease, transform 0.2s;
}

button.btn-primary {
  background-color: red;
  color: black;
}

button.btn-primary:hover {
  background-color: darkred;
  transform: scale(1.05);
}

button.btn-success {
  background-color: green;
  color: black;
}

button.btn-success:hover {
  background-color: darkgreen;
  transform: scale(1.05);
}

/* Button Group Styling */
.button-group {
  display: flex;
  justify-content: space-between;
  gap: 10px;
}

/* Additional styling for larger screens */
@media (min-width: 768px) {
  .login-container {
    padding: 40px;
  }

  .form-group {
    margin-bottom: 25px;
  }
}


--- component\cssfiles\Deposit.css ---
/* Common.css */
body {
    font-family: Arial, sans-serif;
    background-color: #f4f4f9;
    margin: 0;
    padding: 0;
  }
  
  h2 {
    text-align: center;
    color: #333;
    margin-top: 20px;
  }
  
  form {
    max-width: 400px;
    margin: 0 auto;
    padding: 20px;
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  }
  
  input {
    width: 100%;
    padding: 12px;
    margin: 8px 0;
    border: 1px solid #ccc;
    border-radius: 4px;
    box-sizing: border-box;
    font-size: 14px;
  }
  
  input[type="number"] {
    -moz-appearance: textfield; /* Remove number input spinner in Firefox */
  }
  
  input:focus {
    outline: none;
    border-color: #007bff;
  }
  
  button {
    width: 100%;
    padding: 12px;
    background-color: #007bff;
    color: #fff;
    border: none;
    border-radius: 4px;
    font-size: 16px;
    cursor: pointer;
  }
  
  button:hover {
    background-color: #0056b3;
  }
  
  p {
    text-align: center;
    color: #ff0000;
    margin-top: 20px;
    font-size: 14px;
  }
  

--- component\cssfiles\Header.css ---


--- component\cssfiles\Registraion.css ---
/* Registration.css */
.registration-container {
    background-color: #121212;
    color: white;
    max-width: 600px;
    margin: 50px auto;
    padding: 30px;
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  }
  
  h2 {
    color: #ff3d3d;
    font-family: 'Arial', sans-serif;
  }
  
  .form-group label {
    color: #ff3d3d;
    font-weight: bold;
  }
  
  .form-control {
    background-color: #222222;
    color: white;
    border: 1px solid #ff3d3d;
    border-radius: 5px;
    padding: 10px;
    margin-top: 5px;
  }
  
  .form-control:focus {
    background-color: #333333;
    border-color: #ff3d3d;
    outline: none;
  }
  
  .btn-success {
    background-color: #ff3d3d;
    color: white;
    border: none;
    border-radius: 5px;
    padding: 12px;
    font-size: 16px;
    cursor: pointer;
  }
  
  .btn-success:hover {
    background-color: #e60000;
  }
  
  .form-row {
    margin-bottom: 15px;
  }
  
  .form-group {
    margin-bottom: 20px;
  }
  
  .text-center {
    text-align: center;
  }
  
  .mb-4 {
    margin-bottom: 30px;
  }
  
  .mt-3 {
    margin-top: 20px;
  }
  

--- component\cssfiles\TransferMoney.css ---
.transfer-container {
    background-color: black;
    color: red;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  
  h2 {
    margin-bottom: 20px;
    font-size: 24px;
  }
  
  form {
    display: flex;
    flex-direction: column;
    width: 300px;
  }
  
  input {
    margin-bottom: 15px;
    padding: 10px;
    border: 2px solid red;
    border-radius: 5px;
    background-color: black;
    color: red;
  }
  
  input::placeholder {
    color: rgba(255, 0, 0, 0.7);
  }
  
  button {
    padding: 10px;
    background-color: red;
    color: black;
    border: none;
    border-radius: 5px;
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.3s;
  }
  
  button:hover {
    background-color: darkred;
  }
  
  .transfer-message {
    margin-top: 20px;
    font-size: 18px;
    color: red;
  }
  

--- component\Page\ApplyLoanPage.js ---
import React, { useState } from 'react';
import axios from 'axios';
import {
    Container, Paper, Typography, Box, TextField, Button, CircularProgress, Alert, Grid, MenuItem, Select, InputLabel, FormControl
} from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext'; // Adjust path if needed
import ArrowBackIcon from '@mui/icons-material/ArrowBack';

const API_BASE_URL = 'http://localhost:8080'; // Your backend URL

// Example Loan Types & Terms (Ideally fetch from backend/config)
const loanTypes = ["PERSONAL", "HOME", "CAR", "EDUCATION", "BUSINESS"];
const loanTerms = [6, 12, 18, 24, 36, 48, 60, 72, 84, 96, 108, 120]; // In months
const employmentStatuses = ["Salaried", "Self-Employed", "Business Owner", "Student", "Retired", "Unemployed", "Other"];

export default function ApplyLoanPage() {
    const navigate = useNavigate();
    const { authState } = useAuth();
    const [formData, setFormData] = useState({
        loanType: '',
        requestedAmount: '',
        termInMonths: '',
        purpose: '',
        monthlyIncome: '',
        employmentStatus: ''
    });
    const [isLoading, setIsLoading] = useState(false);
    const [feedback, setFeedback] = useState({ type: '', message: '' });

    // Handle input changes
    const handleChange = (e) => {
        const { name, value } = e.target;
        setFormData(prev => ({ ...prev, [name]: value }));
        setFeedback({ type: '', message: '' }); // Clear feedback on any input change
    };

    // Handle form submission
    const handleSubmit = async (e) => {
        e.preventDefault();
        setIsLoading(true);
        setFeedback({ type: '', message: '' });

        // --- Frontend Validation ---
        let validationError = '';
        if (!formData.loanType) validationError = 'Loan Type is required.';
        else if (!formData.requestedAmount) validationError = 'Requested Amount is required.';
        else if (!formData.termInMonths) validationError = 'Repayment Term is required.';
        else if (!formData.purpose) validationError = 'Purpose of Loan is required.';

        const requestedAmt = parseFloat(formData.requestedAmount);
        if (!validationError && (isNaN(requestedAmt) || requestedAmt <= 0)) {
            validationError = 'Requested amount must be a positive number.';
        } else if (!validationError && requestedAmt < 1000) { // Example minimum
            validationError = 'Minimum loan amount is ₹1,000.';
        }

        const income = formData.monthlyIncome ? parseFloat(formData.monthlyIncome) : null;
        if (!validationError && income !== null && (isNaN(income) || income < 0)) {
            validationError = 'Monthly income, if entered, must be zero or positive.';
        }

        if (validationError) {
            setFeedback({ type: 'error', message: validationError });
            setIsLoading(false);
            return;
        }
        // --- End Validation ---

        try {
            // Prepare data for backend, ensuring numbers are parsed correctly
            const dataToSend = {
                loanType: formData.loanType,
                requestedAmount: requestedAmt,
                termInMonths: parseInt(formData.termInMonths, 10),
                purpose: formData.purpose,
                monthlyIncome: income, // Send parsed number or null
                employmentStatus: formData.employmentStatus,
            };

            // API Call
            const response = await axios.post(
                `${API_BASE_URL}/loan/apply`,
                dataToSend,
                { withCredentials: true } // Send auth cookies
            );

            // Handle Success
            if (response.data?.success) {
                setFeedback({ type: 'success', message: response.data.message || 'Loan application submitted successfully! Awaiting review.' });
                // Clear form
                setFormData({
                    loanType: '', requestedAmount: '', termInMonths: '', purpose: '', monthlyIncome: '', employmentStatus: ''
                });
                // Redirect after a short delay
                setTimeout(() => navigate('/my-loans'), 2500);
            } else {
                // Handle backend indicating failure {success: false, message: '...'}
                throw new Error(response.data?.message || 'Failed to submit loan application. Unknown server response.');
            }
        } catch (err) {
            // Handle API errors (network, server error status codes)
            console.error("Loan Application submission error:", err);
            const errorMsg = err.response?.data?.message // Check for message in error response body
                           || err.message // General axios/network error message
                           || 'An unexpected error occurred during submission.';
            setFeedback({ type: 'error', message: errorMsg });
        } finally {
            setIsLoading(false);
        }
    };

    // Check if user is logged in
    if (!authState.isLoggedIn) {
         return (
            <Container maxWidth="sm" sx={{ mt: 4 }}>
                <Paper elevation={3} sx={{ p: 3, textAlign: 'center' }}>
                    <Alert severity="warning">Please log in to apply for a Loan.</Alert>
                    <Button variant="contained" sx={{mt: 2}} onClick={() => navigate('/login')}>Login</Button>
                </Paper>
            </Container>
         );
    }

    // Render the form
    return (
        <Container maxWidth="md" sx={{ mt: 4, mb: 4 }}>
            <Paper elevation={3} sx={{ p: { xs: 2, sm: 4 }, borderRadius: 2 }}>
                {/* Header with Back Button */}
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
                    <Typography variant="h5" component="h1" sx={{ fontWeight: 'bold' }}>
                        Apply for Loan
                    </Typography>
                    <Button variant="outlined" size="small" startIcon={<ArrowBackIcon />} onClick={() => navigate('/header')}>
                        My Account
                    </Button>
                </Box>

                {/* Feedback Alert */}
                {feedback.message && (
                    <Alert severity={feedback.type || 'info'} sx={{ mb: 2 }} variant="outlined">
                        {feedback.message}
                    </Alert>
                )}

                {/* Loan Application Form */}
                <Box component="form" onSubmit={handleSubmit} noValidate>
                    <Grid container spacing={3}> {/* Increased spacing */}
                        {/* Row 1 */}
                        <Grid item xs={12} sm={6}>
                            <FormControl fullWidth required error={!formData.loanType && feedback.type === 'error'}>
                                <InputLabel id="loan-type-label">Loan Type *</InputLabel>
                                <Select
                                    labelId="loan-type-label"
                                    id="loanType"
                                    name="loanType"
                                    value={formData.loanType}
                                    label="Loan Type *"
                                    onChange={handleChange}
                                    disabled={isLoading}
                                >
                                    <MenuItem value="" disabled><em>Select Loan Type</em></MenuItem>
                                    {loanTypes.map(type => <MenuItem key={type} value={type}>{type}</MenuItem>)}
                                </Select>
                            </FormControl>
                        </Grid>
                        <Grid item xs={12} sm={6}>
                             <TextField
                                label="Requested Amount (₹) *"
                                id="requestedAmount"
                                name="requestedAmount"
                                type="number"
                                value={formData.requestedAmount}
                                onChange={handleChange}
                                fullWidth
                                required
                                disabled={isLoading}
                                error={(!formData.requestedAmount || parseFloat(formData.requestedAmount) <= 0) && feedback.type === 'error'}
                                inputProps={{ min: "1000" }} // Example minimum
                                />
                        </Grid>

                         {/* Row 2 */}
                        <Grid item xs={12} sm={6}>
                            <FormControl fullWidth required error={!formData.termInMonths && feedback.type === 'error'}>
                                <InputLabel id="term-label">Repayment Term *</InputLabel>
                                <Select
                                    labelId="term-label"
                                    id="termInMonths"
                                    name="termInMonths"
                                    value={formData.termInMonths}
                                    label="Repayment Term *"
                                    onChange={handleChange}
                                    disabled={isLoading}
                                >
                                     <MenuItem value="" disabled><em>Select Term (Months)</em></MenuItem>
                                    {loanTerms.map(term => <MenuItem key={term} value={term}>{term} Months</MenuItem>)}
                                </Select>
                            </FormControl>
                        </Grid>
                         <Grid item xs={12} sm={6}>
                            <FormControl fullWidth>
                                <InputLabel id="employment-label">Employment Status (Optional)</InputLabel>
                                <Select
                                    labelId="employment-label"
                                    id="employmentStatus"
                                    name="employmentStatus"
                                    value={formData.employmentStatus}
                                    label="Employment Status (Optional)"
                                    onChange={handleChange}
                                    disabled={isLoading}
                                >
                                     <MenuItem value=""><em>Select Status (Optional)</em></MenuItem>
                                    {employmentStatuses.map(status => <MenuItem key={status} value={status}>{status}</MenuItem>)}
                                </Select>
                            </FormControl>
                        </Grid>

                        {/* Row 3 */}
                         <Grid item xs={12}>
                              <TextField
                                label="Approx. Monthly Income (₹, Optional)"
                                id="monthlyIncome"
                                name="monthlyIncome"
                                type="number"
                                value={formData.monthlyIncome}
                                onChange={handleChange}
                                fullWidth
                                disabled={isLoading}
                                inputProps={{ min: "0" }}
                                error={(formData.monthlyIncome && parseFloat(formData.monthlyIncome) < 0) && feedback.type === 'error'}
                                />
                         </Grid>

                        {/* Row 4 */}
                         <Grid item xs={12}>
                              <TextField
                                label="Purpose of Loan *"
                                id="purpose"
                                name="purpose"
                                value={formData.purpose}
                                onChange={handleChange}
                                fullWidth
                                required
                                disabled={isLoading}
                                multiline
                                rows={4} // Make purpose field larger
                                placeholder="Briefly describe why you need the loan (e.g., home renovation, car purchase, medical expenses)..."
                                error={!formData.purpose && feedback.type === 'error'}/>
                         </Grid>

                        {/* Submit Button */}
                        <Grid item xs={12} sx={{ textAlign: 'center' }}> {/* Center button */}
                            <Button
                                type="submit"
                                variant="contained"
                                size="large"
                                sx={{ mt: 2, px: 5 }} // Padding and margin
                                disabled={isLoading}
                            >
                                {isLoading ? <CircularProgress size={24} color="inherit" /> : 'Submit Loan Application'}
                            </Button>
                        </Grid>
                    </Grid>
                </Box>
            </Paper>
        </Container>
    );
}

--- component\Page\CheckBalance.js ---
// --- src/component/Page/CheckBalance.js ---
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import { Container, Paper, Typography, Button, Box, CircularProgress, Alert } from '@mui/material';
import { useAuth } from '../../context/AuthContext';  // Use auth context

const API_BASE_URL = 'http://localhost:8080';

const CheckBalancePage = () => {
    const [balance, setBalance] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const [message, setMessage] = useState('');
    const { authState } = useAuth(); // Access authState (including customerId)

    const handleCheckBalance = async () => {
        if (!authState.isLoggedIn) {
            setMessage("Please log in to check your balance.");
            setBalance(null);
            return;
        }

        // *** FIX: No need to send customerId as param, backend gets it from authentication ***
        console.log("Frontend checking balance for authenticated user:", authState.customerId);
        setIsLoading(true);
        setBalance(null); // Reset balance view
        setMessage('');     // Clear previous messages

        try {
            // Make the GET request, relying on the backend to identify the user via authentication context
            const response = await axios.get(`${API_BASE_URL}/check-balance`, {
                withCredentials: true // Send necessary cookies/auth headers
                // REMOVED: params: { customerId: authState.customerId }
            });
             // *** END FIX ***

            console.log("Check Balance Raw Response:", response);

            // Response structure from backend seems to be { success: true, balance: "123.45" }
            if (response.data && response.data.success === true && response.data.balance !== undefined) {
                const fetchedBalance = parseFloat(response.data.balance);
                if (!isNaN(fetchedBalance)) {
                    setBalance(fetchedBalance);
                    // Don't necessarily need a success message if balance displays
                    // setMessage(`Balance fetched successfully!`);
                } else {
                    console.error("Received non-numeric balance:", response.data.balance);
                    setMessage("Failed to retrieve balance: Invalid format received.");
                    setBalance(null);
                }
            } else {
                // Backend might send error message in balance field or a dedicated message field
                 // Check if balance field contains the error string from backend
                 const errorMsg = response.data?.balance?.startsWith("ERROR:")
                    ? response.data.balance.replace("ERROR:", "").replace("_", " ") // Use balance field if it contains error
                    : response.data?.message || "Failed to retrieve balance. Unexpected response format."; // Otherwise check message field

                console.error("Balance check failed:", errorMsg, response.data);
                setMessage(errorMsg);
                setBalance(null);
            }
        } catch (error) {
            console.error('Error checking balance:', error);
            setBalance(null);
            if (error.response) {
                const errorData = error.response.data;
                // Try to parse error message from backend (might be in `message` or just the body)
                const errorMsg = errorData?.message ||
                                 (typeof errorData === 'string' && errorData.startsWith("ERROR:")) ? errorData.replace("ERROR:", "").replace("_", " ") : // Check if body is error string
                                 (typeof errorData === 'string' ? errorData : // Use body if it's just a string
                                 `Error: ${error.response.status}. Please ensure you are logged in correctly.`);

                setMessage(errorMsg);
                if (error.response.status === 401 || error.response.status === 403) {
                    setMessage("Authentication error. Please log out and log back in.");
                    // Consider calling logout() from context here if needed
                }
            } else if (error.request) {
                setMessage("Network error. Could not reach the server.");
            } else {
                setMessage("An unexpected error occurred while checking balance.");
            }
        } finally {
            setIsLoading(false);
        }
    };

    // Fetch balance automatically when the component mounts or auth state changes
    useEffect(() => {
        if (authState.isLoggedIn) {
            handleCheckBalance();
        } else {
            setMessage("Please log in to view your balance.");
            setBalance(null);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [authState.isLoggedIn, authState.customerId]); // Re-fetch if customerId changes (though unlikely in same session)

    return (
        <Container maxWidth="sm" sx={{ mt: 4 }}>
            <Paper elevation={3} sx={{ p: 3, display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                <Typography variant="h4" component="h1" gutterBottom>
                    Check Account Balance
                </Typography>

                <Box sx={{ my: 3, minHeight: '60px', textAlign: 'center', width: '100%' }}>
                    {isLoading && <CircularProgress />}
                    {!isLoading && balance !== null && (
                        <Typography variant="h5" color="primary" sx={{ fontWeight: 'bold' }}>
                            Current Balance: ₹{balance.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                        </Typography>
                    )}
                    {!isLoading && message && (
                        // Only show error severity if balance failed to load
                        <Alert severity={balance === null ? "error" : "info"} sx={{ width: '100%', mt: 1 }}>
                            {message}
                        </Alert>
                    )}
                     {!isLoading && balance === null && !message && authState.isLoggedIn && (
                         <Typography variant="body1" color="text.secondary">
                             Click the button below to refresh your balance.
                         </Typography>
                     )}
                    {!authState.isLoggedIn && !isLoading && (
                        <Alert severity="warning" sx={{ width: '100%', mt: 1 }}>
                            Please log in to view your balance.
                        </Alert>
                    )}
                </Box>

                <Button
                    variant="contained"
                    onClick={handleCheckBalance}
                    disabled={isLoading || !authState.isLoggedIn}
                    fullWidth
                    size="large"
                    sx={{ mt: 1 }}
                >
                    {isLoading ? 'Checking...' : 'Refresh Balance'}
                </Button>
            </Paper>
        </Container>
    );
};

export default CheckBalancePage;

--- component\Page\Customer_Dash.js ---
import React, { useState } from 'react';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext'; // ✅ Get login() from context

// Material UI Components
import {
    Container,
    Box,
    TextField,
    Button,
    Typography,
    CircularProgress,
    Alert,
    Paper // Import Paper for background styling
} from '@mui/material';

export default function Customer_Dash() {
    const navigate = useNavigate();
    const { login } = useAuth(); // ✅ Use login from context

    const [formData, setFormData] = useState({
        customerId: '',
        mobileNumber: '',
        password: ''
    });

    const [isLoading, setIsLoading] = useState(false);
    const [errorMessage, setErrorMessage] = useState('');

    const handleChange = (e) => {
        setFormData({ ...formData, [e.target.name]: e.target.value });
        if (errorMessage) setErrorMessage('');
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setIsLoading(true);
        setErrorMessage('');

        const loginData = {
            customerId: formData.customerId,
            mobileNumber: formData.mobileNumber,
            password: formData.password
        };

        try {
            const response = await axios.post("http://localhost:8080/login", loginData);
            console.log("Login Response:", response.data);

            // ✅ Check for success and extract role + ID
            if (response.data === true || response.data?.success === true) {
                const role = response.data?.role;
                const customerId = response.data?.customerId;

                if (!role || !customerId) {
                    setErrorMessage("Login failed: Invalid response from server.");
                    setIsLoading(false);
                    return;
                }

                login(role, customerId); // ✅ Save login info in context

                // ✅ Navigate based on role
                 // *** FIX: Added ROLE_EMPLOYEE navigation ***
                if (role === 'ROLE_ADMIN') {
                    navigate('/admin/dashboard');
                } else if (role === 'ROLE_EMPLOYEE') {
                    navigate('/employee/dashboard'); // Navigate employees to their dashboard
                }
                else if (role === 'ROLE_USER') {
                    navigate('/header');
                } else {
                    // Fallback for unknown roles or if navigation is needed before role determination
                    navigate('/');
                }
            } else {
                // Use message from backend response if available
                setErrorMessage(response.data?.message || "Login failed. Please check credentials or account status.");
            }
        } catch (error) {
             // Improved error message handling
            if (error.response) {
                 console.error("Login Error Response:", error.response);
                 const status = error.response.status;
                 const responseData = error.response.data;
                 let msg = `Login failed (Status: ${status})`; // Default for other errors

                if (status === 401) { // Unauthorized
                     // Use specific message from backend if available, otherwise generic
                     msg = responseData?.message || "Invalid credentials or account pending approval/disabled.";
                 } else if (responseData?.message) { // Use message from {success: false, message: '...'}
                     msg = responseData.message;
                 } else if (typeof responseData === 'string') { // If backend just sent a string error
                     msg = responseData;
                 }
                 setErrorMessage(msg);
             } else if (error.request) {
                 console.error("Login Network Error:", error.request);
                 setErrorMessage("Network error: Could not reach the server.");
             } else {
                 console.error("Login Setup Error:", error.message);
                 setErrorMessage("An unexpected error occurred during login setup.");
             }
        } finally {
            setIsLoading(false);
        }
    };

    const redirectToRegistration = () => {
        navigate("/register");
    };

    return (
        // Container to center content, adjust maxWidth as needed
        <Container component="main" maxWidth="xs" sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: 'calc(100vh - 64px)' }}>
            {/* Paper component to provide the white background and elevation */}
            <Paper elevation={4} sx={{
                padding: { xs: 2, sm: 4 }, // Responsive padding
                marginTop: 8,
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                width: '100%', // Ensure Paper takes container width
                backgroundColor: '#ffffff', // Explicitly set white background
                borderRadius: '12px' // Optional: slightly rounded corners
            }}>
                <Typography component="h1" variant="h5" sx={{ color: '#000000', mb: 1 }}> {/* Black text */}
                    Customer Login
                </Typography>

                {/* Error message display */}
                {errorMessage && (
                    <Alert severity="error" sx={{ width: '100%', mt: 2 }}>
                        {errorMessage}
                    </Alert>
                )}

                {/* Form Box */}
                <Box component="form" onSubmit={handleSubmit} noValidate sx={{ mt: 1, width: '100%' }}>
                    <TextField
                        margin="normal"
                        required
                        fullWidth
                        id="customerId"
                        label="Customer ID"
                        name="customerId"
                        autoComplete="username"
                        autoFocus
                        value={formData.customerId}
                        onChange={handleChange}
                        disabled={isLoading}
                         // Optional: Style input text/label if needed for contrast
                         // InputLabelProps={{ sx: { color: 'rgba(0, 0, 0, 0.6)' } }}
                         // InputProps={{ sx: { color: '#000000' } }}
                    />

                    {/* Optional Mobile Number */}
                    <TextField
                        margin="normal"
                        fullWidth
                        id="mobileNumber"
                        label="Mobile Number (Optional)"
                        name="mobileNumber"
                        autoComplete="tel"
                        value={formData.mobileNumber}
                        onChange={handleChange}
                        disabled={isLoading}
                    />

                    <TextField
                        margin="normal"
                        required
                        fullWidth
                        name="password"
                        label="Password"
                        type="password"
                        id="password"
                        autoComplete="current-password"
                        value={formData.password}
                        onChange={handleChange}
                        disabled={isLoading}
                    />

                    {/* Sign In Button */}
                    <Button
                        type="submit"
                        fullWidth
                        variant="contained"
                        sx={{ mt: 3, mb: 1 }} // Adjust margins as needed
                        disabled={isLoading}
                    >
                        {isLoading ? <CircularProgress size={24} color="inherit" /> : 'Sign In'}
                    </Button>

                    {/* Register Button */}
                    <Button
                        type="button"
                        fullWidth
                        variant="outlined" // Keep outlined for secondary action
                        sx={{ mb: 2 }}
                        onClick={redirectToRegistration}
                        disabled={isLoading}
                    >
                        Register New Account
                    </Button>
                </Box>
            </Paper> {/* End Paper component */}
        </Container>
    );
}

--- component\Page\Deposit.js ---
// Deposit.js
import React, { useState } from 'react';
import axios from 'axios';
import '../cssfiles/Deposit.css'
const Deposit = () => {
  const [mobileNo, setMobileNo] = useState('');
  const [accountNo, setAccountNo] = useState('');
  const [amount, setAmount] = useState('');
  const [message, setMessage] = useState('');

  const handleDeposit = async (e) => {
    e.preventDefault();

    const depositData = { mobileNo, accountNo, amount: parseFloat(amount) };

    try {
      const response = await axios.post('http://localhost:8080/deposit', depositData);
      setMessage(response.data); // Display success or error message from backend
    } catch (error) {
      console.error('Error depositing money:', error);
      setMessage('Error occurred while depositing money');
    }
  };

  return (
    <div>
      <h2>Deposit Money</h2>
      <form onSubmit={handleDeposit}>
        <input
          type="text"
          placeholder="Mobile Number"
          value={mobileNo}
          onChange={(e) => setMobileNo(e.target.value)}
        />
        <input
          type="text"
          placeholder="Account Number"
          value={accountNo}
          onChange={(e) => setAccountNo(e.target.value)}
        />
        <input
          type="number"
          placeholder="Amount"
          value={amount}
          onChange={(e) => setAmount(e.target.value)}
        />
        <button type="submit">Deposit</button>
      </form>
      {message && <p>{message}</p>}
    </div>
  );
};

export default Deposit;


--- component\Page\Employee_Dash.js ---
import React from 'react'

export default function () {
  return (
    <h1>
        well come to employee 
    </h1>
  )
}


--- component\Page\Fd.js ---
// this page is for apply FD by customer

import React, { useState, useEffect } from 'react';


import axios from 'axios';
import {
    Container, Paper, Typography, Box, TextField, Button, CircularProgress, Alert, Grid, MenuItem, Select, InputLabel, FormControl
} from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext'; // Adjust path if needed
import ArrowBackIcon from '@mui/icons-material/ArrowBack';

const API_BASE_URL = 'http://localhost:8080';

// Example FD Terms (In a real app, ideally fetch these from the backend or a config file)
const fdTerms = [
    { months: 6, label: '6 Months', minAmount: 1000, indicativeRate: 5.5 },
    { months: 12, label: '1 Year', minAmount: 1000, indicativeRate: 6.0 },
    { months: 24, label: '2 Years', minAmount: 2000, indicativeRate: 6.25 },
    { months: 36, label: '3 Years', minAmount: 5000, indicativeRate: 6.5 },
    { months: 60, label: '5 Years', minAmount: 10000, indicativeRate: 6.75 },
];

export default function ApplyFdPage() {
    const navigate = useNavigate();
    const { authState } = useAuth();
    const [principalAmount, setPrincipalAmount] = useState('');
    const [termInMonths, setTermInMonths] = useState('');
    const [selectedTermDetails, setSelectedTermDetails] = useState(null); // To store minAmount & rate
    const [customerBalance, setCustomerBalance] = useState(null);

    const [isLoading, setIsLoading] = useState(false);
    const [isFetchingBalance, setIsFetchingBalance] = useState(true);
    const [feedback, setFeedback] = useState({ type: '', message: '' });

    // Fetch customer's current balance on component mount
    useEffect(() => {
        const fetchBalance = async () => {
            if (!authState.isLoggedIn) {
                setIsFetchingBalance(false);
                return;
            }
            setIsFetchingBalance(true);
            try {
                const response = await axios.get(`${API_BASE_URL}/check-balance`, { withCredentials: true });
                if (response.data?.success && response.data.balance !== undefined) {
                    setCustomerBalance(parseFloat(response.data.balance));
                } else {
                    setFeedback({ type: 'warning', message: 'Could not fetch current account balance.' });
                }
            } catch (error) {
                console.error("Error fetching balance:", error);
                setFeedback({ type: 'error', message: 'Error fetching account balance. Please try again later.' });
            } finally {
                setIsFetchingBalance(false);
            }
        };
        fetchBalance();
    }, [authState.isLoggedIn]);

    // Handle term selection change
    const handleTermChange = (event) => {
        const selectedMonths = event.target.value;
        setTermInMonths(selectedMonths);
        const termDetail = fdTerms.find(term => term.months === parseInt(selectedMonths, 10));
        setSelectedTermDetails(termDetail || null);
        setFeedback({ type: '', message: '' }); // Clear previous feedback
    };

    // Handle amount input change
     const handleAmountChange = (event) => {
         setPrincipalAmount(event.target.value);
         setFeedback({ type: '', message: '' }); // Clear feedback
     };

    // Handle form submission
    const handleSubmit = async (e) => {
        e.preventDefault();
        setIsLoading(true);
        setFeedback({ type: '', message: '' });

        const amount = parseFloat(principalAmount);

        // --- Frontend Validation ---
        let validationError = '';
        if (!termInMonths) validationError = 'Please select a term for the Fixed Deposit.';
        else if (isNaN(amount) || amount <= 0) validationError = 'Please enter a valid positive amount.';
        else if (selectedTermDetails && amount < selectedTermDetails.minAmount) {
            validationError = `Minimum amount for the selected term (${selectedTermDetails.label}) is ₹${selectedTermDetails.minAmount.toLocaleString()}.`;
        } else if (customerBalance !== null && amount > customerBalance) {
            validationError = `Insufficient account balance (Available: ₹${customerBalance.toLocaleString()}).`;
        }

        if (validationError) {
            setFeedback({ type: 'error', message: validationError });
            setIsLoading(false);
            return;
        }
        // --- End Validation ---

        try {
            // API Call to apply for FD
            const response = await axios.post(
                `${API_BASE_URL}/fd/apply`,
                { principalAmount: amount, termInMonths: parseInt(termInMonths, 10) },
                { withCredentials: true } // Send auth cookies
            );

            // Handle Success
            if (response.data?.success) {
                setFeedback({ type: 'success', message: response.data.message || 'FD application submitted successfully! Awaiting approval.' });
                setPrincipalAmount('');
                setTermInMonths('');
                setSelectedTermDetails(null);
                // Redirect after a short delay
                setTimeout(() => navigate('/my-fds'), 2500);
            } else {
                // Handle backend indicating failure
                throw new Error(response.data?.message || 'Failed to submit FD application.');
            }
        } catch (err) {
            // Handle API errors
            console.error("FD Application error:", err);
            const errorMsg = err.response?.data?.message || err.message || 'An error occurred during submission.';
            setFeedback({ type: 'error', message: errorMsg });
        } finally {
            setIsLoading(false);
        }
    };

    // Check if user is logged in
    if (!authState.isLoggedIn) {
         return (
            <Container maxWidth="sm" sx={{ mt: 4 }}>
                <Paper elevation={3} sx={{ p: 3, textAlign: 'center' }}>
                    <Alert severity="warning">Please log in to apply for a Fixed Deposit.</Alert>
                    <Button variant="contained" sx={{mt: 2}} onClick={() => navigate('/login')}>Login</Button>
                 </Paper>
            </Container>
         );
     }

    // Render the form
    return (
        <Container maxWidth="sm" sx={{ mt: 4, mb: 4 }}>
            <Paper elevation={3} sx={{ p: { xs: 2, sm: 4 }, borderRadius: 2 }}>
                {/* Header with Back Button */}
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
                    <Typography variant="h5" component="h1" sx={{ fontWeight: 'bold' }}>
                        Apply for Fixed Deposit
                    </Typography>
                    <Button variant="outlined" size="small" startIcon={<ArrowBackIcon />} onClick={() => navigate('/header')}>
                        My Account
                    </Button>
                </Box>

                {/* Balance Information */}
                {isFetchingBalance ? (
                    <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', mb: 2 }}>
                        <CircularProgress size={20} sx={{ mr: 1 }} />
                        <Typography variant="body2" color="text.secondary">Fetching account balance...</Typography>
                    </Box>
                ) : customerBalance !== null && (
                    <Alert severity="info" sx={{ mb: 2 }} variant="outlined">
                         Your current savings account balance: <strong>₹{customerBalance.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</strong>
                     </Alert>
                 )}

                {/* Feedback Alert */}
                {feedback.message && (
                    <Alert severity={feedback.type || 'info'} sx={{ mb: 2 }} variant="outlined">
                        {feedback.message}
                    </Alert>
                )}

                {/* FD Application Form */}
                <Box component="form" onSubmit={handleSubmit} noValidate>
                    <Grid container spacing={3}>
                        <Grid item xs={12}>
                            <TextField
                                label="Principal Amount (₹) *"
                                id="principalAmount"
                                name="principalAmount"
                                type="number"
                                value={principalAmount}
                                onChange={handleAmountChange}
                                fullWidth
                                required
                                disabled={isLoading || isFetchingBalance}
                                error={ (selectedTermDetails && parseFloat(principalAmount) < selectedTermDetails.minAmount && principalAmount !== '') || (customerBalance !== null && parseFloat(principalAmount) > customerBalance) }
                                helperText={
                                    (customerBalance !== null && parseFloat(principalAmount) > customerBalance) ? `Amount exceeds available balance.` :
                                    (selectedTermDetails && parseFloat(principalAmount) < selectedTermDetails.minAmount && principalAmount !== '') ? `Min. amount for this term: ₹${selectedTermDetails.minAmount.toLocaleString()}` :
                                    "Enter the amount you wish to deposit."
                                }
                                InputProps={{ inputProps: { min: 0 } }}
                                autoFocus
                            />
                        </Grid>
                         <Grid item xs={12}>
                            <FormControl fullWidth required error={!termInMonths && feedback.type === 'error'}>
                                 <InputLabel id="term-select-label">Select Term *</InputLabel>
                                 <Select
                                    labelId="term-select-label"
                                    id="termInMonths"
                                    name="termInMonths"
                                    value={termInMonths}
                                    label="Select Term *"
                                    onChange={handleTermChange}
                                    disabled={isLoading || isFetchingBalance}
                                >
                                     <MenuItem value="" disabled><em>Select a duration</em></MenuItem>
                                     {fdTerms.map((term) => (
                                        <MenuItem key={term.months} value={term.months}>
                                             {term.label} (Min: ₹{term.minAmount.toLocaleString()}, Rate: {term.indicativeRate}%)
                                         </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>
                        </Grid>

                        {/* Indicative Interest and Maturity (Optional Display) */}
                        {selectedTermDetails && principalAmount && parseFloat(principalAmount) >= selectedTermDetails.minAmount && (
                             <Grid item xs={12}>
                                 <Typography variant="body2" color="text.secondary">
                                     Indicative Interest Rate: {selectedTermDetails.indicativeRate}% p.a. <br />
                                     {/* Note: Actual maturity amount is calculated by backend on approval */}
                                 </Typography>
                             </Grid>
                         )}

                         <Grid item xs={12} sx={{ textAlign: 'center' }}>
                            <Button
                                type="submit"
                                fullWidth
                                variant="contained"
                                size="large"
                                sx={{ mt: 2, px: 5 }}
                                disabled={isLoading || isFetchingBalance}
                            >
                                {isLoading ? <CircularProgress size={24} color="inherit" /> : 'Submit FD Application'}
                            </Button>
                        </Grid>
                    </Grid>
                </Box>
            </Paper>
        </Container>
    );
}

--- component\Page\Header.js ---
// --- src/component/Page/Header.js ---
import React from 'react';
import { Box, Button, Typography, Grid, Card, Container, Paper } from '@mui/material';
import { Link } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext'; // Import useAuth
import { Link as RouterLink, useNavigate } from 'react-router-dom';


// Import Icons
import AccountBalanceWalletIcon from '@mui/icons-material/AccountBalanceWallet';
import SwapHorizIcon from '@mui/icons-material/SwapHoriz';
import DownloadIcon from '@mui/icons-material/Download';
import LogoutIcon from '@mui/icons-material/Logout';
import SavingsIcon from '@mui/icons-material/Savings';         // <<< ENSURE THIS IS PRESENT
import ViewListIcon from '@mui/icons-material/ViewList';     

const Header = () => {
    const navigate = useNavigate();
    const { logout, authState } = useAuth(); // Get logout and authState

    const handleLogout = () => {
        logout();
        navigate("/login");
    };

    // Placeholder for download
    const handleDownloadHistory = async () => {
         alert('Download Transaction History - Backend endpoint not implemented yet.');
    };


    return (
        <Container maxWidth="md" sx={{ mt: 4, mb: 4 }}>
             <Paper elevation={3} sx={{ p: 3, mb: 4 }}>
                 <Typography variant="h4" component="h1" gutterBottom align="center">
                    My Account Dashboard
                 </Typography>
                 <Typography variant="body1" paragraph align="center">
                     Welcome, Customer {authState.customerId}!
                 </Typography>
             </Paper>

            {/* --- Action Cards --- */}
            <Grid container spacing={3} justifyContent="center">

                 {/* Card 1: Check Balance (Links to /check-balance page) */}
                 <Grid item xs={12} sm={6} md={4}>
                     <Card sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', p: 3, height: '100%', '&:hover': { boxShadow: 6 } }}>
                         <AccountBalanceWalletIcon color="primary" sx={{ fontSize: 40, mb: 1 }} />
                         <Typography variant="h6" gutterBottom>Check Balance</Typography>
                         {/* Link points to the separate CheckBalancePage route */}
                         <Button component={Link} to="/check-balance" variant="contained">
                             Check Now
                         </Button>
                     </Card>
                 </Grid>

                {/* Card 2: Transfer Money */}
                <Grid item xs={12} sm={6} md={4}>
                     <Card sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', p: 3, height: '100%', '&:hover': { boxShadow: 6 } }}>
                        <SwapHorizIcon color="secondary" sx={{ fontSize: 40, mb: 1 }} />
                        <Typography variant="h6" gutterBottom>Transfer Money</Typography>
                        {/* Link points to the separate TransferPage route */}
                        <Button component={Link} to="/transfer" variant="contained" color="secondary">
                            Go to Transfer
                        </Button>
                    </Card>
                </Grid>

                 {/* Card 3: Download History */}
                 <Grid item xs={12} sm={6} md={4}>
                     <Card sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', p: 3, height: '100%', '&:hover': { boxShadow: 6 } }}>
                        <DownloadIcon sx={{ fontSize: 40, mb: 1, color: 'success.main' }} />
                        <Typography variant="h6" gutterBottom>Transactions</Typography>
                        <Button component={Link} to="/history" variant="contained" color="success" fullWidth>
                            Download History
                        </Button>
                    </Card>
                  </Grid>
                    {/* Card 2: Transfer Money */}

                <Grid item xs={12} sm={6} md={4}>
                     <Card sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', p: 3, height: '100%', '&:hover': { boxShadow: 6 } }}>
                        <SwapHorizIcon color="secondary" sx={{ fontSize: 40, mb: 1 }} />
                        <Typography variant="h6" gutterBottom>Apply For Loan</Typography>
                        {/* Link points to the separate TransferPage route */}
                        <Button component={Link} to="/apply-loan" variant="contained" color="secondary">
                            Go to apply Loan
                        </Button>
                    </Card>
                </Grid> 

                {/* Card 4: Fixed Deposit */}
                    <Grid item xs={12} sm={6} md={4}>
                     <Card sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', p: 3, height: '100%', '&:hover': { boxShadow: 6 } }}>
                        <SavingsIcon sx={{ fontSize: 40, mb: 1, color: 'info.main' }} />
                        <Typography variant="h6" gutterBottom>Fixed Deposit</Typography>
                        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1, width: '100%', mt: 'auto' }}>
                            <Button component={RouterLink} to="/apply-fd" variant="contained" color="info" size="small" fullWidth>
                                Apply for New FD
                            </Button>
                            <Button component={RouterLink} to="/my-fds" variant="outlined" color="info" size="small" fullWidth startIcon={<ViewListIcon/>}>
                                View My FDs
                            </Button>
                         </Box>
                    </Card>
                  </Grid>
                {/* ... */}
        
            </Grid>
        </Container>
    );
};

export default Header;

--- component\Page\JobApplicationForm.js ---
// --- src/component/Page/JobApplicationForm.js ---
import React, { useState } from 'react';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';

// Import MUI components
import {
    Container,
    Box,
    TextField,
    Button,
    Typography,
    CircularProgress,
    Alert,
    Grid, // Keep Grid for layout, even if vertical
    Paper
} from '@mui/material';

const API_BASE_URL = 'http://localhost:8080'; // Your backend URL

export default function JobApplicationForm() {
    const navigate = useNavigate(); // To potentially redirect after success

    // State for form data
    const [formData, setFormData] = useState({
        applicantFirstName: '',
        applicantLastName: '',
        applicantEmail: '',
        applicantPhone: '',
        qualifications: '',
        experience: '',
        desiredRole: '',
        resumeLink: ''
    });

    // State for loading and feedback messages
    const [isLoading, setIsLoading] = useState(false);
    const [errorMessage, setErrorMessage] = useState('');
    const [successMessage, setSuccessMessage] = useState('');

    // Handle input changes
    const handleChange = (e) => {
        setFormData({ ...formData, [e.target.name]: e.target.value });
        // Clear messages when user types
        if (errorMessage) setErrorMessage('');
        if (successMessage) setSuccessMessage('');
    };

    // Handle form submission
    const handleSubmit = async (e) => {
        e.preventDefault();
        setErrorMessage('');
        setSuccessMessage('');
        setIsLoading(true);

        // Basic Frontend Validation (Backend validation is primary)
        if (!formData.applicantFirstName || !formData.applicantLastName || !formData.applicantEmail || !formData.applicantPhone || !formData.qualifications || !formData.desiredRole) {
            setErrorMessage('Please fill in all required fields marked with *.');
            setIsLoading(false);
            return;
        }

        console.log("Submitting Job Application Data:", formData);

        try {
            // Send data to the backend public endpoint (/apply-for-job)
            const response = await axios.post(`${API_BASE_URL}/apply-for-job`, formData);
            // No need for `withCredentials: true` here as it's a public submission

            console.log("Application submission successful:", response.data);
            setSuccessMessage(response.data?.message || "Application submitted successfully! We will contact you if you are shortlisted.");

            // Clear the form after successful submission
            setFormData({
                applicantFirstName: '', applicantLastName: '', applicantEmail: '',
                applicantPhone: '', qualifications: '', experience: '',
                desiredRole: '', resumeLink: ''
            });

            // Optional: Redirect after a delay
            // setTimeout(() => navigate('/'), 3000); // Redirect to home after 3 secs

        } catch (error) {
            // Enhanced Error Logging (Keep this)
            console.error("Application submission error:", error);
            if (error.response) {
                console.error("Error Response Data:", error.response.data);
                console.error("Error Response Status:", error.response.status);
                let backendMessage = error.response.data?.message ||
                                   (typeof error.response.data === 'string' ? error.response.data : null);
                setErrorMessage(backendMessage || `Submission failed (Status: ${error.response.status}). Please check details and try again.`);
            } else if (error.request) {
                console.error("Error Request:", error.request);
                setErrorMessage("Network error. Could not reach the server.");
            } else {
                console.error('Error Message:', error.message);
                setErrorMessage(`An unexpected error occurred: ${error.message}`);
            }
            // --- End Enhanced Logging ---
        } finally {
            setIsLoading(false);
        }
    };

    return (
        // Main container, centers the Paper component
        <Container component="main" maxWidth="sm" sx={{ mt: 4, mb: 4, display: 'flex', justifyContent: 'center' }}>
            {/* White background Paper component */}
            <Paper elevation={3} sx={{
                p: { xs: 2, sm: 4 }, // Responsive padding
                borderRadius: '12px',
                backgroundColor: '#ffffff', // Explicit white background
                width: '100%', // Takes the width of the maxWidth container
                display: 'flex',
                flexDirection: 'column', // Stack elements vertically inside Paper
                alignItems: 'center' // Center items horizontally within Paper
            }}>
                {/* Title */}
                <Typography component="h1" variant="h4" align="center" gutterBottom sx={{
                     fontWeight: 'bold',
                     color: '#000000', // Black text
                     width: '100%' // Ensure title takes full width for centering
                     }}>
                    Apply for a Position
                </Typography>
                {/* Subtitle */}
                <Typography variant="body1" align="center" color="text.secondary" sx={{
                     mb: 4,
                     color: '#333333' // Dark grey text
                     }}>
                    Fill out the form below to apply for a job at MEEWOO BANK. Fields marked with * are required.
                </Typography>

                {/* Feedback Messages */}
                {successMessage && (
                    <Alert severity="success" sx={{ width: '100%', mb: 2 }} variant="outlined">{successMessage}</Alert> // Outlined Alert
                )}
                {errorMessage && (
                    <Alert severity="error" sx={{ width: '100%', mb: 2 }} variant="outlined">{errorMessage}</Alert> // Outlined Alert
                )}

                {/* Form container */}
                <Box component="form" onSubmit={handleSubmit} noValidate sx={{ width: '100%', display: 'flex', flexDirection: 'column', gap: 2 }}>
                    {/* All TextFields arranged vertically */}
                    {/* Each TextField will take full width by default */}

                    <TextField name="applicantFirstName" required fullWidth id="applicantFirstName" label="First Name *" // Added * to label
                        value={formData.applicantFirstName} onChange={handleChange} disabled={isLoading}
                        autoComplete="given-name" autoFocus
                    />

                    <TextField name="applicantLastName" required fullWidth id="applicantLastName" label="Last Name *"
                        value={formData.applicantLastName} onChange={handleChange} disabled={isLoading}
                        autoComplete="family-name"
                    />

                    <TextField name="applicantEmail" required fullWidth id="applicantEmail" label="Email Address *" type="email"
                        value={formData.applicantEmail} onChange={handleChange} disabled={isLoading}
                        autoComplete="email"
                    />

                    <TextField name="applicantPhone" required fullWidth id="applicantPhone" label="Phone Number *" type="tel"
                        value={formData.applicantPhone} onChange={handleChange} disabled={isLoading}
                        autoComplete="tel"
                    />

                    <TextField name="desiredRole" required fullWidth id="desiredRole" label="Desired Role / Position *"
                        value={formData.desiredRole} onChange={handleChange} disabled={isLoading}
                        helperText="E.g., Teller, Loan Officer, IT Support"
                    />

                    <TextField name="qualifications" required fullWidth id="qualifications" label="Qualifications / Education *"
                        value={formData.qualifications} onChange={handleChange} disabled={isLoading}
                        multiline rows={4}
                        helperText="Summarize relevant education, certifications, skills."
                    />

                    <TextField name="experience" fullWidth id="experience" label="Work Experience (Optional)"
                        value={formData.experience} onChange={handleChange} disabled={isLoading}
                        multiline rows={4}
                        helperText="Describe relevant work history, roles, responsibilities."
                    />

                    <TextField name="resumeLink" fullWidth id="resumeLink" label="Link to Resume/CV/Portfolio (Optional)"
                        value={formData.resumeLink} onChange={handleChange} disabled={isLoading}
                        helperText="E.g., LinkedIn profile or shared document link"
                    />

                    {/* Submit Button - Centered */}
                    <Box sx={{ display: 'flex', justifyContent: 'center', mt: 2 }}> {/* Reduced top margin */}
                        <Button type="submit" variant="contained" color="primary"
                            sx={{ py: 1.5, px: 5, fontSize: '1rem' }}
                            disabled={isLoading}
                        >
                            {isLoading ? <CircularProgress size={24} color="inherit" /> : 'Submit Application'}
                        </Button>
                    </Box>
                </Box> {/* End Form Box */}
            </Paper> {/* End Paper */}
        </Container> // End Container
    );
}

--- component\Page\MyFD.js ---
import React, { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import {
    Container, Typography, Paper, TableContainer, Table, TableHead, TableRow, TableCell, TableBody,
    CircularProgress, Alert, Box, Chip, Button, Collapse, IconButton, Grid
} from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext'; // Adjust path
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';
import KeyboardArrowUpIcon from '@mui/icons-material/KeyboardArrowUp';
import AddIcon from '@mui/icons-material/Add';

const API_BASE_URL = 'http://localhost:8080';

// --- Helper Functions ---
const formatDate = (dateString) => {
    if (!dateString) return 'N/A';
    try {
        return new Date(dateString).toLocaleDateString('en-IN', { year: 'numeric', month: 'short', day: 'numeric' });
    } catch (e) { return 'Invalid Date'; }
};
const formatDateTime = (dateTimeString) => {
    if (!dateTimeString) return 'N/A';
    try {
        return new Date(dateTimeString).toLocaleString('en-IN', { dateStyle: 'medium', timeStyle: 'short' });
    } catch (e) { return 'Invalid Date'; }
};
const formatCurrency = (amount) => {
    if (amount === null || amount === undefined) return 'N/A';
    return `₹ ${amount.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
};
const getFdStatusChip = (status) => {
    let color = 'default';
    let label = status ? status : 'Unknown';
    switch (status) {
        case 'PENDING': color = 'warning'; break;
        case 'ACTIVE': color = 'success'; break;
        case 'REJECTED': color = 'error'; break;
        case 'MATURED': color = 'info'; break;
        case 'CLOSED': color = 'default'; break; // For premature closure
        default: color = 'default';
    }
    return <Chip label={label} color={color} size="small" variant="outlined" />;
};
// --- End Helper Functions ---


// --- FdRow Sub-component ---
function FdRow({ fd }) {
    const [open, setOpen] = useState(false); // State for collapse

    return (
        <React.Fragment>
            {/* Main visible row */}
            <TableRow hover sx={{ '& > *': { borderBottom: 'unset' } }}>
                <TableCell sx={{ width: '5%' }}>
                    <IconButton aria-label="expand row" size="small" onClick={() => setOpen(!open)}>
                        {open ? <KeyboardArrowUpIcon /> : <KeyboardArrowDownIcon />}
                    </IconButton>
                </TableCell>
                <TableCell component="th" scope="row" sx={{ width: '10%' }}>{fd.id}</TableCell>
                <TableCell sx={{ width: '20%' }}>{formatDateTime(fd.applicationDate)}</TableCell>
                <TableCell sx={{ width: '20%' }} align="right">{formatCurrency(fd.principalAmount)}</TableCell>
                <TableCell sx={{ width: '15%' }}>{fd.termInMonths} Months</TableCell>
                <TableCell sx={{ width: '15%' }} align="right">{fd.interestRate?.toFixed(2)}%</TableCell>
                <TableCell sx={{ width: '15%' }} align="center">{getFdStatusChip(fd.status)}</TableCell>
            </TableRow>
            {/* Collapsible details row */}
            <TableRow>
                <TableCell style={{ paddingBottom: 0, paddingTop: 0 }} colSpan={7}>
                    <Collapse in={open} timeout="auto" unmountOnExit>
                        <Box sx={{ margin: 1, p: 2, border: '1px dashed #e0e0e0', borderRadius: 1, backgroundColor: '#f9f9f9' }}>
                            <Typography variant="subtitle2" gutterBottom component="div" sx={{ fontWeight: 'bold', mb: 1 }}>
                                Details for FD ID: {fd.id}
                            </Typography>
                            <Grid container spacing={1} sx={{ fontSize: '0.9rem' }}>
                                <Grid item xs={12} sm={6}><strong>Source Account:</strong> {fd.sourceAccountNumber || 'N/A'}</Grid>
                                <Grid item xs={12} sm={6}><strong>Start Date:</strong> {fd.status === 'ACTIVE' || fd.status === 'MATURED' ? formatDate(fd.startDate) : 'Pending Approval'}</Grid>
                                <Grid item xs={12} sm={6}><strong>Maturity Date:</strong> {formatDate(fd.maturityDate)}</Grid>
                                <Grid item xs={12} sm={6}><strong>Maturity Amount:</strong> {formatCurrency(fd.maturityAmount)}</Grid>
                                {fd.status === 'ACTIVE' && fd.approvalDate && (
                                    <Grid item xs={12} sm={6}><strong>Approved On:</strong> {formatDateTime(fd.approvalDate)}</Grid>
                                )}
                                {fd.status === 'REJECTED' && (
                                    <Grid item xs={12}>
                                        <Typography color="error" component="span"><strong>Rejection Reason:</strong> {fd.rejectionReason || 'Not specified'}</Typography>
                                    </Grid>
                                )}
                            </Grid>
                        </Box>
                    </Collapse>
                </TableCell>
            </TableRow>
        </React.Fragment>
    );
}
// --- End FdRow Sub-component ---


// --- MyFdsPage Main Component ---
export default function MyFdsPage() {
    const navigate = useNavigate();
    const { authState } = useAuth();
    const [fds, setFds] = useState([]);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');

    // Fetch user's FDs
    const fetchMyFds = useCallback(async () => {
        if (!authState.isLoggedIn) return;
        setIsLoading(true);
        setError('');
        try {
            const response = await axios.get(`${API_BASE_URL}/fd/my-fds`, { withCredentials: true });
            if (response.data?.success && Array.isArray(response.data.fixedDeposits)) {
                setFds(response.data.fixedDeposits);
            } else {
                 throw new Error(response.data?.message || "Could not fetch your fixed deposits.");
            }
        } catch (err) {
            console.error("Error fetching My FDs:", err);
            setError(err.response?.data?.message || err.message || 'Failed to load your fixed deposits.');
            setFds([]);
        } finally {
            setIsLoading(false);
        }
    }, [authState.isLoggedIn]);

    // Fetch FDs on component mount
    useEffect(() => {
        fetchMyFds();
    }, [fetchMyFds]);

    // Render login prompt if not logged in
     if (!authState.isLoggedIn) {
         return (
            <Container maxWidth="sm" sx={{ mt: 4 }}>
                <Paper elevation={3} sx={{ p: 3, textAlign: 'center' }}>
                    <Alert severity="warning">Please log in to view your Fixed Deposits.</Alert>
                     <Button variant="contained" sx={{mt: 2}} onClick={() => navigate('/login')}>Login</Button>
                 </Paper>
            </Container>
          );
     }

    // Main render
    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            <Paper elevation={2} sx={{ p: { xs: 2, md: 3 }, borderRadius: 2 }}>
                 {/* Header */}
                 <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3, borderBottom: 1, borderColor: 'divider', pb: 2 }}>
                     <Typography variant="h5" component="h1" sx={{ fontWeight: 'bold' }}>My Fixed Deposits</Typography>
                      <Button variant="outlined" size="small" startIcon={<ArrowBackIcon />} onClick={() => navigate('/header')}>My Account</Button>
                 </Box>

                {/* Loading Indicator */}
                {isLoading && <Box sx={{ display: 'flex', justifyContent: 'center', my: 5 }}><CircularProgress /></Box>}

                {/* Error Alert */}
                {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}

                {/* FD Table */}
                {!isLoading && !error && (
                    <TableContainer component={Paper} variant="outlined">
                        <Table aria-label="collapsible fixed deposits table">
                            <TableHead sx={{ backgroundColor: 'primary.lighter', '& th': { fontWeight: 'bold', color: 'primary.contrastText' } }}>
                                <TableRow>
                                    <TableCell /> {/* For collapse button */}
                                    <TableCell>FD ID</TableCell>
                                    <TableCell>Applied On</TableCell>
                                    <TableCell align="right">Principal (₹)</TableCell>
                                    <TableCell>Term</TableCell>
                                    <TableCell align="right">Interest Rate</TableCell>
                                    <TableCell align="center">Status</TableCell>
                                </TableRow>
                            </TableHead>
                            <TableBody>
                                {fds.length === 0 ? (
                                    <TableRow>
                                        <TableCell colSpan={7} align="center" sx={{ py: 4, fontStyle: 'italic', color: 'text.secondary' }}>
                                            You haven't opened any Fixed Deposits yet.
                                             <Button size="small" sx={{ml: 2}} variant='text' startIcon={<AddIcon />} onClick={() => navigate('/apply-fd')}>Apply for an FD</Button>
                                        </TableCell>
                                    </TableRow>
                                ) : (
                                    fds.map((fd) => <FdRow key={fd.id} fd={fd} />)
                                )}
                            </TableBody>
                        </Table>
                    </TableContainer>
                )}

                {/* Button to Apply for Another FD (shown if FDs exist or always) */}
                 {!isLoading && ( // Show this button whether FDs exist or not, as long as not loading
                     <Box sx={{ display: 'flex', justifyContent: 'center', mt: 3 }}>
                         <Button variant="contained" color="info" startIcon={<AddIcon />} onClick={() => navigate('/apply-fd')}>
                             Apply for a New FD
                         </Button>
                     </Box>
                 )}
            </Paper>
        </Container>
    );
}

--- component\Page\MyLoanPage.js ---
import React, { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import {
    Container, Typography, Paper, TableContainer, Table, TableHead, TableRow, TableCell, TableBody,
    CircularProgress, Alert, Box, Chip, Button, Collapse, IconButton, Tooltip, Grid
} from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext'; // Adjust path
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';
import KeyboardArrowUpIcon from '@mui/icons-material/KeyboardArrowUp';
import AddIcon from '@mui/icons-material/Add'; // For Apply button

const API_BASE_URL = 'http://localhost:8080';

// --- Helper Functions ---
const formatDate = (dateString) => {
    if (!dateString) return 'N/A';
    try {
        return new Date(dateString).toLocaleString('en-IN', { dateStyle: 'medium', timeStyle: 'short' });
    } catch (e) { return 'Invalid Date'; }
};
const formatCurrency = (amount) => {
    if (amount === null || amount === undefined) return 'N/A';
    return `₹ ${amount.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
};
const getLoanStatusChip = (status) => {
    let color = 'default';
    let label = status ? status.replace('_', ' ') : 'Unknown';
    switch (status) {
        case 'PENDING': color = 'warning'; break;
        case 'UNDER_REVIEW': color = 'info'; break;
        case 'APPROVED': color = 'success'; break;
        case 'REJECTED': color = 'error'; break;
        case 'DISBURSED': color = 'primary'; break; // Future state
        case 'CLOSED': color = 'default'; break;      // Future state
        default: color = 'default';
    }
    return <Chip label={label} color={color} size="small" variant="outlined" />;
};
// --- End Helper Functions ---


// --- LoanRow Sub-component ---
function LoanRow({ loan }) {
    const [open, setOpen] = useState(false); // State for collapse

    return (
        <React.Fragment>
            {/* Main visible row */}
            <TableRow hover sx={{ '& > *': { borderBottom: 'unset' } }}>
                {/* Collapse button cell */}
                <TableCell sx={{ width: '5%' }}>
                    <IconButton aria-label="expand row" size="small" onClick={() => setOpen(!open)}>
                        {open ? <KeyboardArrowUpIcon /> : <KeyboardArrowDownIcon />}
                    </IconButton>
                </TableCell>
                {/* Data cells */}
                <TableCell component="th" scope="row" sx={{ width: '10%' }}>{loan.id}</TableCell>
                <TableCell sx={{ width: '25%' }}>{formatDate(loan.applicationDate)}</TableCell>
                <TableCell sx={{ width: '20%' }}>{loan.loanType || 'N/A'}</TableCell>
                <TableCell sx={{ width: '20%' }} align="right">{formatCurrency(loan.requestedAmount)}</TableCell>
                <TableCell sx={{ width: '20%' }} align="center">{getLoanStatusChip(loan.status)}</TableCell>
            </TableRow>
            {/* Collapsible details row */}
            <TableRow>
                <TableCell style={{ paddingBottom: 0, paddingTop: 0 }} colSpan={6}>
                    <Collapse in={open} timeout="auto" unmountOnExit>
                        <Box sx={{ margin: 1, p: 2, border: '1px dashed #e0e0e0', borderRadius: 1, backgroundColor: '#f9f9f9' }}>
                            <Typography variant="subtitle2" gutterBottom component="div" sx={{ fontWeight: 'bold', mb: 1 }}>
                                Details for Loan ID: {loan.id}
                            </Typography>
                            <Grid container spacing={1} sx={{ fontSize: '0.9rem' }}> {/* Slightly smaller font for details */}
                                {/* Row 1 of details */}
                                <Grid item xs={12} sm={4}><strong>Term:</strong> {loan.termInMonths} Months</Grid>
                                <Grid item xs={12} sm={4}><strong>Income:</strong> {formatCurrency(loan.monthlyIncome)}</Grid>
                                <Grid item xs={12} sm={4}><strong>Employment:</strong> {loan.employmentStatus || 'N/A'}</Grid>

                                {/* Row 2 - Conditional based on status */}
                                {loan.status === 'APPROVED' && (
                                    <>
                                        <Grid item xs={12} sm={4}><strong>Approved Amt:</strong> {formatCurrency(loan.approvedAmount)}</Grid>
                                        <Grid item xs={12} sm={4}><strong>Interest Rate:</strong> {loan.interestRate?.toFixed(2)}%</Grid>
                                        <Grid item xs={12} sm={4}><strong>Approved On:</strong> {formatDate(loan.approvalDate)}</Grid>
                                    </>
                                )}
                                {loan.status === 'REJECTED' && (
                                    <Grid item xs={12}>
                                        <Typography color="error" component="span"><strong>Rejection Reason:</strong> {loan.rejectionReason || 'Not specified'}</Typography>
                                    </Grid>
                                )}

                                {/* Row 3 - Purpose */}
                                <Grid item xs={12} mt={1}>
                                    <strong>Purpose:</strong>
                                    <Typography variant="body2" sx={{ whiteSpace: 'pre-wrap', mt: 0.5 }}>{loan.purpose || 'N/A'}</Typography>
                                </Grid>
                            </Grid>
                        </Box>
                    </Collapse>
                </TableCell>
            </TableRow>
        </React.Fragment>
    );
}
// --- End LoanRow Sub-component ---


// --- MyLoansPage Main Component ---
export default function MyLoansPage() {
    const navigate = useNavigate();
    const { authState } = useAuth();
    const [loans, setLoans] = useState([]);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');

    // Fetch user's loans
    const fetchMyLoans = useCallback(async () => {
        if (!authState.isLoggedIn) return; // Guard clause
        setIsLoading(true);
        setError('');
        try {
            const response = await axios.get(`${API_BASE_URL}/loan/my-loans`, { withCredentials: true });
             if (response.data?.success && Array.isArray(response.data.loanApplications)) {
                 setLoans(response.data.loanApplications);
             } else {
                 throw new Error(response.data?.message || "Could not fetch your loan applications.");
            }
        } catch (err) {
            console.error("Error fetching My Loans:", err);
            setError(err.response?.data?.message || err.message || 'Failed to load loan applications.');
            setLoans([]); // Clear loans on error
        } finally {
            setIsLoading(false);
        }
    }, [authState.isLoggedIn]); // Depend only on login status

    // Fetch loans on component mount
    useEffect(() => {
        fetchMyLoans();
    }, [fetchMyLoans]);

    // Render login prompt if not logged in
    if (!authState.isLoggedIn) {
        return (
             <Container maxWidth="sm" sx={{ mt: 4 }}>
                <Paper elevation={3} sx={{ p: 3, textAlign: 'center' }}>
                    <Alert severity="warning">Please log in to view your Loan Applications.</Alert>
                     <Button variant="contained" sx={{mt: 2}} onClick={() => navigate('/login')}>Login</Button>
                 </Paper>
             </Container>
         );
    }

    // Main render
    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            <Paper elevation={2} sx={{ p: { xs: 2, md: 3 }, borderRadius: 2 }}>
                 {/* Header */}
                 <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3, borderBottom: 1, borderColor: 'divider', pb: 2 }}>
                     <Typography variant="h5" component="h1" sx={{ fontWeight: 'bold' }}>My Loan Applications</Typography>
                      <Button variant="outlined" size="small" startIcon={<ArrowBackIcon />} onClick={() => navigate('/header')}>My Account</Button>
                 </Box>

                {/* Loading Indicator */}
                {isLoading && <Box sx={{ display: 'flex', justifyContent: 'center', my: 5 }}><CircularProgress /></Box>}

                {/* Error Alert */}
                {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}

                {/* Loan Table */}
                {!isLoading && !error && (
                    <TableContainer component={Paper} variant="outlined">
                        <Table aria-label="collapsible loan applications table">
                            <TableHead sx={{ backgroundColor: 'primary.lighter', '& th': { fontWeight: 'bold', color: 'primary.contrastText' } }}>
                                <TableRow>
                                    <TableCell /> {/* Collapse icon cell */}
                                    <TableCell>App ID</TableCell>
                                    <TableCell>Applied On</TableCell>
                                    <TableCell>Loan Type</TableCell>
                                    <TableCell align="right">Requested Amt.</TableCell>
                                    <TableCell align="center">Status</TableCell>
                                </TableRow>
                            </TableHead>
                            <TableBody>
                                {loans.length === 0 ? (
                                    <TableRow>
                                        <TableCell colSpan={6} align="center" sx={{ py: 4, fontStyle: 'italic', color: 'text.secondary' }}>
                                            You haven't applied for any loans yet.
                                             <Button size="small" sx={{ml: 2}} variant='text' startIcon={<AddIcon />} onClick={() => navigate('/apply-loan')}>Apply for a Loan</Button>
                                        </TableCell>
                                    </TableRow>
                                ) : (
                                    // Map through loans and render LoanRow for each
                                    loans.map((loan) => <LoanRow key={loan.id} loan={loan} />)
                                )}
                            </TableBody>
                        </Table>
                    </TableContainer>
                )}

                {/* Button to Apply for Another Loan (shown only if loans exist) */}
                 {!isLoading && loans.length > 0 && (
                     <Box sx={{ display: 'flex', justifyContent: 'center', mt: 3 }}>
                         <Button variant="contained" color="warning" startIcon={<AddIcon />} onClick={() => navigate('/apply-loan')}>
                             Apply for Another Loan
                         </Button>
                     </Box>
                 )}
            </Paper>
        </Container>
    );
}

--- component\Page\Registration.js ---
import React, { useState } from 'react';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';

// Import MUI components
import {
    Container,
    Box,
    TextField,
    Button,
    Typography,
    CircularProgress,
    Alert,
    Grid // Grid is essential for responsiveness
} from '@mui/material';

export default function Registration() {
    const navigate = useNavigate();

    // --- State Management (same as before) ---
    const [formData, setFormData] = useState({
        mobileNumber: '', email: '', fname: '', lname: '', fathername: '',
        address: '', pincode: '', dob: '', password: '', confirmPassword: ''
    });
    const [isLoading, setIsLoading] = useState(false);
    const [errorMessage, setErrorMessage] = useState('');
    const [successMessage, setSuccessMessage] = useState('');

    // --- Handlers (same as before) ---
    const handleChange = (e) => {
        setFormData({ ...formData, [e.target.name]: e.target.value });
        if (errorMessage) setErrorMessage('');
        if (successMessage) setSuccessMessage('');
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setErrorMessage('');
        setSuccessMessage('');

        if (formData.password !== formData.confirmPassword) {
            setErrorMessage("Passwords do not match!");
            return;
        }

        setIsLoading(true);
        const { confirmPassword, ...dataToSend } = formData;

        console.log("Submitting Registration Data:", dataToSend);

        try {
            const response = await axios.post("http://localhost:8080/register", dataToSend);
            console.log("Registration successful:", response.data);
            setSuccessMessage(response.data?.message || "Registration successful! Redirecting to login...");
            setFormData({ // Clear form
                 mobileNumber: '', email: '', fname: '', lname: '', fathername: '',
                 address: '', pincode: '', dob: '', password: '', confirmPassword: ''
            });
            setTimeout(() => navigate('/login'), 2500); // Redirect after showing message

        } catch (error) {
            console.error("Registration error:", error);
             if (error.response) {
                setErrorMessage(error.response.data?.message || error.response.data || `Registration failed (Status: ${error.response.status})`);
            } else if (error.request) {
                setErrorMessage("Network error. Could not reach the server.");
            } else {
                setErrorMessage("An unexpected error occurred.");
            }
        } finally {
            setIsLoading(false);
        }
    };

    // --- Responsive JSX with Vertical Inputs ---
    return (
        // Use maxWidth="sm" for a narrower form if all inputs are vertical, or keep "md"
        <Container component="main" maxWidth="sm"> {/* Adjusted maxWidth for better vertical form appearance */}
            <Box
                sx={{
                    marginTop: 8, // More top margin for better spacing
                    marginBottom: 4, // Add bottom margin
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    padding: { xs: 2, sm: 3 }, // Add some padding inside the box, responsive
                    border: '1px solid', // Optional: add border/shadow for visual grouping
                    borderColor: 'divider',
                    borderRadius: 2, // Optional: rounded corners
                    // boxShadow: 3, // Optional: subtle shadow
                }}
            >
                <Typography component="h1" variant="h5" sx={{ mb: 3 }}> {/* Add bottom margin to title */}
                    Register New Account
                </Typography>

                {/* Feedback Messages */}
                {successMessage && (
                    <Alert severity="success" sx={{ width: '100%', mb: 2 }}>{successMessage}</Alert>
                )}
                {errorMessage && (
                    <Alert severity="error" sx={{ width: '100%', mb: 2 }}>{errorMessage}</Alert>
                )}

                <Box component="form" onSubmit={handleSubmit} noValidate sx={{ width: '100%' }}> {/* Ensure form box takes full width of container */}
                    {/* Grid container to manage layout */}
                    {/* spacing={2} adds space between grid items */}
                    <Grid container spacing={2}>

                        {/* First Name: Full width on all screens */}
                        <Grid item xs={12}>
                            <TextField name="fname" required fullWidth id="fname" label="First Name"
                                value={formData.fname} onChange={handleChange} disabled={isLoading}
                                autoComplete="given-name" autoFocus />
                        </Grid>

                        {/* Last Name: Full width on all screens */}
                        <Grid item xs={12}>
                            <TextField name="lname" required fullWidth id="lname" label="Last Name"
                                value={formData.lname} onChange={handleChange} disabled={isLoading}
                                autoComplete="family-name" />
                        </Grid>

                        {/* Father's Name: Always full width */}
                        <Grid item xs={12}>
                            <TextField name="fathername" required fullWidth id="fathername" label="Father's Name"
                                value={formData.fathername} onChange={handleChange} disabled={isLoading} />
                        </Grid>

                        {/* Email: Full width on all screens */}
                        <Grid item xs={12}>
                             <TextField name="email" required fullWidth id="email" label="Email Address" type="email"
                                value={formData.email} onChange={handleChange} disabled={isLoading}
                                autoComplete="email" />
                        </Grid>

                        {/* Mobile Number: Full width on all screens */}
                        <Grid item xs={12}>
                            <TextField name="mobileNumber" required fullWidth id="mobileNumber" label="Mobile Number" type="tel"
                                value={formData.mobileNumber} onChange={handleChange} disabled={isLoading}
                                autoComplete="tel" />
                        </Grid>

                        {/* Address: Always full width, multiline */}
                         <Grid item xs={12}>
                            <TextField name="address" required fullWidth id="address" label="Full Address"
                                value={formData.address} onChange={handleChange} disabled={isLoading}
                                multiline rows={3} />
                        </Grid>

                        {/* Pincode: Full width on all screens */}
                         <Grid item xs={12}>
                           <TextField name="pincode" required fullWidth id="pincode" label="Pincode" type="text"
                                value={formData.pincode} onChange={handleChange} disabled={isLoading}
                                autoComplete="postal-code" />
                        </Grid>

                        {/* Date of Birth: Full width on all screens */}
                        <Grid item xs={12}>
                            <TextField name="dob" required fullWidth id="dob" label="Date of Birth" type="date"
                                value={formData.dob} onChange={handleChange} disabled={isLoading}
                                InputLabelProps={{ shrink: true }} />
                        </Grid>

                        {/* Password: Always full width */}
                        <Grid item xs={12}>
                            <TextField name="password" required fullWidth id="password" label="Password" type="password"
                                value={formData.password} onChange={handleChange} disabled={isLoading}
                                error={!!errorMessage && errorMessage.toLowerCase().includes('password')}
                                autoComplete="new-password" />
                        </Grid>

                         {/* Confirm Password: Always full width */}
                         <Grid item xs={12}>
                            <TextField name="confirmPassword" required fullWidth id="confirmPassword" label="Confirm Password" type="password"
                                value={formData.confirmPassword} onChange={handleChange} disabled={isLoading}
                                error={!!errorMessage && errorMessage.toLowerCase().includes('password')}
                                autoComplete="new-password" />
                        </Grid>
                    </Grid> {/* End Grid container */}

                    {/* Submit Button */}
                    <Button type="submit" fullWidth variant="contained"
                        sx={{ mt: 3, mb: 2, bgcolor: '#28a745', '&:hover': { bgcolor: '#218838' } }}
                        disabled={isLoading} >
                        {isLoading ? <CircularProgress size={24} color="inherit" /> : 'Register'}
                    </Button>

                    {/* Link back to Login */}
                     <Grid container justifyContent="center"> {/* Aligns item to the center */}
                         <Grid item>
                            <Button variant="text" onClick={() => navigate('/login')} disabled={isLoading} >
                                Already have an account? Login
                            </Button>
                         </Grid>
                    </Grid>
                </Box>
            </Box>
        </Container>
    );
}

--- component\Page\TransactionHistoryPage.js ---
// --- src/component/Page/TransactionHistoryPage.js ---
import React, { useState } from 'react';
import { Container, Paper, Typography, Box, TextField, Button, Alert, CircularProgress } from '@mui/material';
import { useAuth } from '../../context/AuthContext'; // Verify this path is correct
import axios from 'axios';
import DownloadIcon from '@mui/icons-material/Download';
import { useNavigate } from 'react-router-dom';
import ArrowBackIcon from '@mui/icons-material/ArrowBack'; // Added for back button

// Ensure your backend API base URL is correct
const API_BASE_URL = 'http://localhost:8080';

// Renamed component to clearly indicate it's for the CUSTOMER
export default function CustomerTransactionHistoryPage() {
    const { authState } = useAuth(); // Get authentication state
    const navigate = useNavigate();

    // State for date inputs and component feedback
    // No targetCustomerId state needed here
    const [startDate, setStartDate] = useState('');
    const [endDate, setEndDate] = useState('');
    const [error, setError] = useState(''); // Holds error messages for display
    const [loading, setLoading] = useState(false); // Tracks loading state for API call
    const [successMessage, setSuccessMessage] = useState(''); // Holds success messages

    /**
     * Helper function to parse user-friendly error messages from Axios errors.
     * (Same helper function as in the Employee version)
     * @param {Error} err - The error object caught (typically an Axios error).
     * @returns {string} A user-friendly error message string.
     */
    const getErrorMessage = (err) => {
        let message = 'An unexpected error occurred. Please try again.'; // Default message
        if (err.response) {
            console.error("API Error Response:", err.response);
            const status = err.response.status;
            const responseData = err.response.data;

            if (status === 403) {
                // This shouldn't happen if logged in as approved customer, but handle just in case
                message = 'Forbidden: You do not have permission to download history.';
            } else if (status === 401) {
                 message = 'Unauthorized: Please log in again.';
            } else if (status === 400) {
                 message = responseData?.message || 'Bad Request: Please check the dates.';
            } else if (responseData?.message) {
                message = responseData.message;
            } else if (typeof responseData === 'string' && responseData.length > 0 && responseData.length < 200) {
                message = responseData;
            } else if (err.response.statusText) {
                 message = `Error: ${status} ${err.response.statusText}`;
            }
        } else if (err.request) {
            console.error("API No Response Error:", err.request);
            message = 'Network Error: Could not connect to the server.';
        } else {
            console.error('API Request Setup Error:', err.message);
            message = `Error: ${err.message}`;
        }
        return message;
    };

    /**
     * Handles the form submission to download the customer's OWN history PDF.
     */
    const handleDownload = async () => {
        // Clear previous messages
        setError('');
        setSuccessMessage('');

        // --- 1. Frontend Input Validation ---
        let validationError = '';
         if (!startDate) { // No targetCustomerId to check here
            validationError = 'Please select a Start Date.';
        } else if (!endDate) {
            validationError = 'Please select an End Date.';
        } else {
            const start = new Date(startDate);
            const end = new Date(endDate);
            end.setHours(23, 59, 59, 999); // Make end date inclusive
            if (start > end) {
                validationError = 'Start date cannot be after end date.';
            }
        }

        if (validationError) {
            setError(validationError);
            return; // Stop if validation fails
        }

        // --- 2. Start Loading and Prepare API Call ---
        setLoading(true);

        // Construct URL for the CUSTOMER download endpoint
        // *** CRITICAL: NO targetCustomerId parameter is sent ***
        const downloadUrl = `${API_BASE_URL}/transactions/download?startDate=${startDate}&endDate=${endDate}`;
        console.log("Requesting download from (Customer Endpoint):", downloadUrl);

        // --- 3. Make API Request ---
        try {
            const response = await axios.get(downloadUrl, {
                responseType: 'blob', // Expect binary data (the PDF)
                withCredentials: true // Send necessary authentication (cookies/headers)
            });

            // --- 4. Process Successful Response (PDF received) ---
            if (response.status === 200 && response.data?.type === 'application/pdf') {
                const blob = new Blob([response.data], { type: 'application/pdf' });
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;

                const contentDisposition = response.headers['content-disposition'];
                // Use logged-in customer ID for default filename if needed, otherwise use header
                let filename = `transaction_history_${authState.customerId}_${startDate}_to_${endDate}.pdf`; // Default using logged-in ID
                if (contentDisposition) {
                    const filenameMatch = contentDisposition.match(/filename="?([^"]+)"?/i);
                    if (filenameMatch && filenameMatch.length > 1) {
                        filename = filenameMatch[1];
                    }
                }

                link.setAttribute('download', filename);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                window.URL.revokeObjectURL(url);

                console.log(`Own transaction history download initiated.`);
                setSuccessMessage(`Your download started successfully!`);

            } else {
                // Handle unexpected success response
                console.error("Received unexpected successful response:", response);
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const errorJson = JSON.parse(e.target.result);
                        setError(errorJson.message || "Download failed: Server returned unexpected data.");
                    } catch (parseError) {
                        setError(`Download failed: ${e.target.result || 'Server returned non-PDF data.'}`);
                    }
                }
                reader.onerror = () => setError("Download failed: Could not read response data.");
                reader.readAsText(response.data);
            }

        // --- 5. Handle API Call Errors ---
        } catch (err) {
            console.error(`Error downloading own history:`, err);
            setError(getErrorMessage(err)); // Use helper
        } finally {
            // --- 6. Stop Loading ---
            setLoading(false);
        }
    };

    // --- 7. JSX Rendering ---
    // Check if user is logged in
    if (!authState.isLoggedIn) {
         // Optionally navigate to login or show message
         // navigate('/login'); // Or
         return (
             <Container maxWidth="sm" sx={{ mt: 4 }}>
                 <Paper elevation={3} sx={{ p: 4, textAlign: 'center' }}>
                    <Alert severity="warning">Please log in to view or download your transaction history.</Alert>
                    <Button variant="contained" sx={{mt: 2}} onClick={() => navigate('/login')}>Login</Button>
                 </Paper>
             </Container>
         );
    }

    return (
        <Container maxWidth="sm" sx={{ mt: 4, mb: 4 }}>
            <Paper elevation={3} sx={{ p: { xs: 2, sm: 3, md: 4 } }}>
                 <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                    <Typography variant="h5" component="h1" gutterBottom>
                        Download Your History
                    </Typography>
                    {/* Back button might navigate to customer dashboard */}
                    <Button
                        variant="outlined"
                        size="small"
                        startIcon={<ArrowBackIcon />}
                        onClick={() => navigate('/header')} // Navigate to customer dashboard/header
                    >
                        My Account
                    </Button>
                 </Box>
                <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
                    Select a date range to download your transaction history as a PDF.
                </Typography>

                 <Box component="form" onSubmit={(e) => { e.preventDefault(); handleDownload(); }} noValidate>
                    {/* Input Fields - NO targetCustomerId input here */}
                     <TextField
                        label="Start Date"
                        id="startDate"
                        type="date"
                        value={startDate}
                        onChange={(e) => { setStartDate(e.target.value); setError(''); setSuccessMessage(''); }}
                        InputLabelProps={{ shrink: true }}
                        fullWidth
                        required
                        margin="normal"
                        disabled={loading}
                        autoFocus // Focus start date first
                    />
                    <TextField
                        label="End Date"
                        id="endDate"
                        type="date"
                        value={endDate}
                        onChange={(e) => { setEndDate(e.target.value); setError(''); setSuccessMessage(''); }}
                        InputLabelProps={{ shrink: true }}
                        fullWidth
                        required
                        margin="normal"
                        disabled={loading}
                    />

                    {/* Display Error Message */}
                    {error && (
                        <Alert severity="error" sx={{ width: '100%', mt: 2, mb: 1 }}>
                            {error}
                        </Alert>
                    )}
                    {/* Display Success Message */}
                    {successMessage && (
                        <Alert severity="success" sx={{ width: '100%', mt: 2, mb: 1 }}>
                            {successMessage}
                        </Alert>
                    )}

                    {/* Submit Button */}
                    <Button
                        type="submit"
                        variant="contained"
                        color="primary"
                        // Disable button if loading or dates are empty
                        disabled={loading || !startDate || !endDate}
                        fullWidth
                        size="large"
                        sx={{ mt: 2 }}
                        startIcon={loading ? <CircularProgress size={20} color="inherit" /> : <DownloadIcon />}
                    >
                        {loading ? 'Generating...' : 'Download PDF'}
                    </Button>
                 </Box>
            </Paper>
        </Container>
    );
}

// Ensure you replace the existing TransactionHistoryPage component export/usage in App.js
// If you named this file TransactionHistoryPage.js initially, just update its content.
// If you created a new file, update the import and Route path in App.js for the customer section.
// Example update in App.js:
// import CustomerTransactionHistoryPage from './component/Page/CustomerTransactionHistoryPage'; // Or TransactionHistoryPage if renamed
// ...
// <Route path="/history" element={<CustomerTransactionHistoryPage />} /> // Ensure element matches component name

--- component\Page\TransferMoney.js ---
// src/component/Page/SimplifiedTransferPage.js

import React, { useState, useEffect } from 'react';
import axios from 'axios';
import { Container, Paper, Typography, TextField, Button, Box, CircularProgress, Alert } from '@mui/material';
import { useAuth } from '../../context/AuthContext';

const API_BASE_URL = 'http://localhost:8080';

const SimplifiedTransferPage = () => {
  const { authState } = useAuth();

  const [balance, setBalance] = useState(null);
  const [formData, setFormData] = useState({
    amount: '',
    // senderPassword: '', // REMOVED senderPassword from state
    receiverCustomerId: '',
    receiverMobileNo: ''
  });
  const [loading, setLoading] = useState(false);
  const [message, setMessage] = useState('');
  const [severity, setSeverity] = useState('info');

  useEffect(() => {
    if (!authState.isLoggedIn) return;

    const fetchBalance = async () => {
      try {
        const res = await axios.get(`${API_BASE_URL}/check-balance`, {
          withCredentials: true
        });
        if (res.data.success && res.data.balance !== undefined) {
          setBalance(parseFloat(res.data.balance));
        } else {
          throw new Error(res.data.message || 'Balance fetch failed');
        }
      } catch (err) {
        setMessage('Error fetching balance');
        setSeverity('error');
      }
    };

    fetchBalance();
  }, [authState]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value
    }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    // REMOVED senderPassword from destructuring
    const { amount, receiverCustomerId, receiverMobileNo } = formData;

    if (!amount || !receiverCustomerId || !receiverMobileNo) {
      setMessage('Please fill in all fields.');
      setSeverity('warning');
      return;
    }

    if (parseFloat(amount) <= 0) {
      setMessage('Amount must be greater than zero.');
      setSeverity('warning');
      return;
    }

    if (balance !== null && parseFloat(amount) > balance) {
      setMessage('Insufficient balance.');
      setSeverity('warning');
      return;
    }

    setLoading(true);
    setMessage('');

    try {
      const res = await axios.post(`${API_BASE_URL}/transfer`, {
        amount: amount,
        receiverCustomerId: receiverCustomerId,
        receiverMobileNo // senderPassword is not sent here
      }, {
        withCredentials: true
      });

      if (res.data.success) {
        setMessage('Transfer successful.');
        setSeverity('success');
        setFormData({
          amount: '',
          // senderPassword: '', // REMOVED clearing senderPassword
          receiverCustomerId: '',
          receiverMobileNo: ''
        });

        // Refresh balance
        const balanceRes = await axios.get(`${API_BASE_URL}/check-balance`, {
          withCredentials: true
        });
        if (balanceRes.data.success) {
          setBalance(parseFloat(balanceRes.data.balance));
        }
      } else {
        throw new Error(res.data.message);
      }
    } catch (err) {
      setMessage(err.response?.data?.message || 'Transfer failed');
      setSeverity('error');
    } finally {
      setLoading(false);
    }
  };

  if (!authState.isLoggedIn) {
    return (
      <Container maxWidth="sm">
        <Paper sx={{ p: 3, mt: 4 }}>
          <Alert severity="warning">Please log in to access this page.</Alert>
        </Paper>
      </Container>
    );
  }

  return (
    <Container maxWidth="sm">
      <Paper sx={{ p: 3, mt: 4 }}>
         <Typography variant="h5" gutterBottom textAlign={'center'} width='100%'>Transfer Money</Typography>

        <Typography variant="body1">
          Balance: {balance !== null ? `₹${balance.toFixed(2)}` : <CircularProgress size={18} />}
        </Typography>

        <Box component="form" onSubmit={handleSubmit} sx={{ mt: 2 }}>
          <TextField
            label="Amount"
            name="amount"
            type="number"
            value={formData.amount}
            onChange={handleChange}
            fullWidth
            margin="normal"
            required
          />
          {/* senderPassword TextField has been completely removed */}
          <TextField
            label="Receiver Customer ID"
            name="receiverCustomerId"
            value={formData.receiverCustomerId}
            onChange={handleChange}
            fullWidth
            margin="normal"
            required
          />
          <TextField
            label="Receiver Mobile No"
            name="receiverMobileNo"
            value={formData.receiverMobileNo}
            onChange={handleChange}
            fullWidth
            margin="normal"
            required
          />

          {message && (
            <Alert severity={severity} sx={{ mt: 2 }}>{message}</Alert>
          )}

          <Button
            type="submit"
            variant="contained"
            color="primary"
            fullWidth
            disabled={loading}
            sx={{ mt: 2 }}
          >
            {loading ? 'Transferring...' : 'Transfer'}
          </Button>
        </Box>
      </Paper>
    </Container>
  );
};

export default SimplifiedTransferPage;

--- component\Page\Withdraw.js ---
import React, { useState } from 'react';
import axios from 'axios';
import '../cssfiles/Deposit.css';

const Withdraw = () => {
  const [mobileNo, setMobileNo] = useState('');
  const [accountNo, setAccountNo] = useState('');
  const [amount, setAmount] = useState('');
  const [password, setPassword] = useState('');
  const [message, setMessage] = useState('');

  const handleWithdraw = async (e) => {
    e.preventDefault();

    const withdrawData = { mobileNo, accountNo, amount: parseFloat(amount), password };

    try {
      const response = await axios.post('http://localhost:8080/withdrawal', withdrawData);
      setMessage(response.data); // Display success or error message from backend
    } catch (error) {
      console.error('Error withdrawing money:', error);
      setMessage('Error occurred while withdrawing money');
    }
  };

  return (
    <div>
      <h2>Withdraw Money</h2>
      <form onSubmit={handleWithdraw}>
        <input
          type="text"
          placeholder="Mobile Number"
          value={mobileNo}
          onChange={(e) => setMobileNo(e.target.value)}
        />
        <input
          type="text"
          placeholder="Account Number"
          value={accountNo}
          onChange={(e) => setAccountNo(e.target.value)}
        />
        <input
          type="number"
          placeholder="Amount"
          value={amount}
          onChange={(e) => setAmount(e.target.value)}
        />
        <input
          type="password"
          placeholder="Password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
        <button type="submit">Withdraw</button>
      </form>
      {message && <p>{message}</p>}
    </div>
  );
};

export default Withdraw;


--- component\Page\Admin\AdminApplicationDetailPage.js ---
// --- src/component/Page/Admin/AdminApplicationDetailPage.js ---
import React, { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate, Link as RouterLink } from 'react-router-dom';
import axios from 'axios';
import {
    Container, Paper, Typography, Box, Button, CircularProgress, Alert, Grid, TextField,
    Dialog, DialogActions, DialogContent, DialogContentText, DialogTitle, Chip, Tooltip, IconButton
} from '@mui/material';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import ScheduleIcon from '@mui/icons-material/Schedule';
import ThumbDownAltIcon from '@mui/icons-material/ThumbDownAlt';
import ThumbUpAltIcon from '@mui/icons-material/ThumbUpAlt';
import CheckCircleIcon from '@mui/icons-material/CheckCircle'; // Hired
import CancelIcon from '@mui/icons-material/Cancel'; // Rejected
import HourglassEmptyIcon from '@mui/icons-material/HourglassEmpty'; // Pending/Review


const API_BASE_URL = 'http://localhost:8080';

// Helper functions (reuse from List page if possible)
const formatDateTime = (dateTimeString) => { /* ... same as in List page ... */ };
const getStatusChip = (status) => { /* ... same as in List page ... */ };

export default function AdminApplicationDetailPage() {
    const { appId } = useParams();
    const navigate = useNavigate();

    const [application, setApplication] = useState(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState('');
    const [actionLoading, setActionLoading] = useState(false); // For button actions
    const [feedback, setFeedback] = useState({ type: '', message: '' });

    // State for modals/dialogs
    const [openScheduleDialog, setOpenScheduleDialog] = useState(false);
    const [openRejectDialog, setOpenRejectDialog] = useState(false);
    const [interviewDate, setInterviewDate] = useState('');
    const [rejectionReason, setRejectionReason] = useState('');

    const fetchApplicationDetails = useCallback(async () => {
        setIsLoading(true);
        setError('');
        setFeedback({ type: '', message: '' });
        try {
            const response = await axios.get(`${API_BASE_URL}/admin/applications/${appId}`, {
                withCredentials: true,
            });
            if (response.data) {
                setApplication(response.data);
            } else {
                throw new Error("Application not found or invalid response.");
            }
        } catch (err) {
            console.error("Error fetching application details:", err);
            setError(err.response?.data?.message || err.message || 'Failed to load application details.');
        } finally {
            setIsLoading(false);
        }
    }, [appId]);

    useEffect(() => {
        fetchApplicationDetails();
    }, [fetchApplicationDetails]);

    // --- Action Handlers ---

    const handleScheduleInterview = async () => {
        if (!interviewDate) {
            setFeedback({ type: 'error', message: 'Please select an interview date and time.' });
            return;
        }
        setActionLoading(true);
        setFeedback({ type: '', message: '' });
        try {
            const response = await axios.post(
                `${API_BASE_URL}/admin/applications/${appId}/schedule-interview`,
                { interviewDate: interviewDate }, // Send as ISO string if backend expects LocalDateTime
                { withCredentials: true }
            );
             setFeedback({ type: 'success', message: 'Interview scheduled successfully!' });
             setApplication(response.data); // Update application state with new data
             setOpenScheduleDialog(false);
             setInterviewDate(''); // Reset date field
        } catch (err) {
             console.error("Error scheduling interview:", err);
             setFeedback({ type: 'error', message: err.response?.data?.message || 'Failed to schedule interview.' });
        } finally {
            setActionLoading(false);
        }
    };

    const handleRejectApplication = async () => {
         if (!rejectionReason) {
             setFeedback({ type: 'error', message: 'Please provide a rejection reason.' });
             return;
         }
         setActionLoading(true);
         setFeedback({ type: '', message: '' });
         try {
             const response = await axios.post(
                 `${API_BASE_URL}/admin/applications/${appId}/reject`,
                 { reason: rejectionReason },
                 { withCredentials: true }
             );
              setFeedback({ type: 'success', message: 'Application rejected successfully.' });
              setApplication(response.data); // Update application state
              setOpenRejectDialog(false);
              setRejectionReason(''); // Reset reason field
         } catch (err) {
             console.error("Error rejecting application:", err);
             setFeedback({ type: 'error', message: err.response?.data?.message || 'Failed to reject application.' });
         } finally {
             setActionLoading(false);
         }
    };

     const handleHireApplicant = async () => {
        if (!window.confirm("Are you sure you want to mark this applicant as hired and create an employee account?")) {
             return;
         }
         setActionLoading(true);
         setFeedback({ type: '', message: '' });
         try {
             const response = await axios.post(
                 `${API_BASE_URL}/admin/applications/${appId}/hire`,
                 null, // No body needed for hire action itself
                 { withCredentials: true }
             );
              setFeedback({ type: 'success', message: 'Applicant hired successfully! Employee account created.' });
              setApplication(response.data); // Update application state
         } catch (err) {
             console.error("Error hiring applicant:", err);
             setFeedback({ type: 'error', message: err.response?.data?.message || 'Failed to hire applicant. Check if email/mobile already exist.' });
         } finally {
             setActionLoading(false);
         }
     };


    // --- Render Logic ---

    if (isLoading) {
        return <Container sx={{ textAlign: 'center', mt: 5 }}><CircularProgress /></Container>;
    }

    if (error) {
        return (
            <Container maxWidth="md" sx={{ mt: 4 }}>
                <Alert severity="error">{error}</Alert>
                <Button startIcon={<ArrowBackIcon />} onClick={() => navigate('/admin/applications')} sx={{ mt: 2 }}>
                    Back to List
                </Button>
            </Container>
        );
    }

    if (!application) {
        return <Container sx={{ textAlign: 'center', mt: 5 }}><Typography>Application not found.</Typography></Container>;
    }

    // Determine if actions should be enabled based on status
    const canSchedule = !['HIRED', 'REJECTED'].includes(application.status);
    const canReject = !['HIRED', 'REJECTED'].includes(application.status);
    const canHire = application.status === 'INTERVIEW_SCHEDULED'; // Example: Only hire after interview

    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            <Paper elevation={3} sx={{ p: { xs: 2, md: 4 } }}>
                {/* Header and Back Button */}
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
                    <Typography variant="h4" component="h1">
                        Application Details
                    </Typography>
                    <Button variant="outlined" startIcon={<ArrowBackIcon />} onClick={() => navigate('/admin/applications')}>
                        Back to List
                    </Button>
                </Box>

                {/* Feedback Alert */}
                {feedback.message && (
                    <Alert severity={feedback.type || 'info'} sx={{ mb: 2 }}>
                        {feedback.message}
                    </Alert>
                )}

                {/* Application Info Grid */}
                <Grid container spacing={3}>
                    <Grid item xs={12} md={6}>
                        <Typography variant="h6" gutterBottom>Applicant Information</Typography>
                        <Typography><strong>Name:</strong> {application.applicantFirstName} {application.applicantLastName}</Typography>
                        <Typography><strong>Email:</strong> {application.applicantEmail}</Typography>
                        <Typography><strong>Phone:</strong> {application.applicantPhone}</Typography>
                        <Typography><strong>Applied On:</strong> {formatDateTime(application.applicationDate)}</Typography>
                         <Typography sx={{ display: 'flex', alignItems: 'center', mt: 1 }}>
                            <strong>Status:</strong>  {getStatusChip(application.status)}
                         </Typography>
                          {application.interviewDate && (
                             <Typography sx={{ mt: 1 }}><strong>Interview Scheduled:</strong> {formatDateTime(application.interviewDate)}</Typography>
                         )}
                    </Grid>
                    <Grid item xs={12} md={6}>
                        <Typography variant="h6" gutterBottom>Professional Details</Typography>
                        <Typography><strong>Desired Role:</strong> {application.desiredRole}</Typography>
                         <Typography><strong>Qualifications:</strong></Typography>
                         <Typography variant="body2" sx={{ whiteSpace: 'pre-wrap', maxHeight: 150, overflowY: 'auto', border: '1px solid #eee', p: 1, borderRadius: 1 }}>{application.qualifications || 'N/A'}</Typography>
                        <Typography sx={{mt:1}}><strong>Experience:</strong></Typography>
                        <Typography variant="body2" sx={{ whiteSpace: 'pre-wrap', maxHeight: 150, overflowY: 'auto', border: '1px solid #eee', p: 1, borderRadius: 1 }}>{application.experience || 'N/A'}</Typography>
                        {application.resumeLink && <Typography sx={{mt:1}}><strong>Resume/Link:</strong> <a href={application.resumeLink} target="_blank" rel="noopener noreferrer">{application.resumeLink}</a></Typography>}
                    </Grid>
                      {application.adminNotes && (
                        <Grid item xs={12}>
                            <Typography variant="h6" gutterBottom>Admin Notes</Typography>
                            <Typography variant="body2" sx={{ whiteSpace: 'pre-wrap', border: '1px solid #eee', p: 1, borderRadius: 1, background: '#f9f9f9' }}>
                                {application.adminNotes}
                                {application.reviewerAdminId && ` (by Admin: ${application.reviewerAdminId})`}
                            </Typography>
                        </Grid>
                     )}
                </Grid>

                 {/* Action Buttons */}
                 <Box sx={{ mt: 4, display: 'flex', justifyContent: 'center', gap: 2, flexWrap: 'wrap' }}>
                    {canSchedule && (
                         <Button
                            variant="contained"
                            color="primary"
                            startIcon={<ScheduleIcon />}
                            onClick={() => setOpenScheduleDialog(true)}
                            disabled={actionLoading}
                         >
                            Schedule Interview
                         </Button>
                     )}
                    {canReject && (
                        <Button
                            variant="contained"
                            color="error"
                            startIcon={<ThumbDownAltIcon />}
                             onClick={() => setOpenRejectDialog(true)}
                             disabled={actionLoading}
                        >
                            Reject Application
                        </Button>
                     )}
                     {canHire && ( // Only show hire if appropriate (e.g., after interview)
                         <Button
                            variant="contained"
                            color="success"
                            startIcon={<ThumbUpAltIcon />}
                             onClick={handleHireApplicant}
                             disabled={actionLoading}
                        >
                             {actionLoading ? <CircularProgress size={20} color="inherit"/> : 'Hire Applicant'}
                         </Button>
                     )}
                </Box>
            </Paper>

             {/* Schedule Interview Dialog */}
             <Dialog open={openScheduleDialog} onClose={() => setOpenScheduleDialog(false)}>
                <DialogTitle>Schedule Interview</DialogTitle>
                <DialogContent>
                    <DialogContentText>
                        Select the date and time for the interview.
                    </DialogContentText>
                     {feedback.type === 'error' && <Alert severity="error" sx={{ mb: 1 }}>{feedback.message}</Alert>}
                    <TextField
                        autoFocus
                        margin="dense"
                        id="interviewDate"
                        label="Interview Date and Time"
                        type="datetime-local" // Use datetime-local input
                        fullWidth
                        variant="standard"
                        value={interviewDate}
                        onChange={(e) => setInterviewDate(e.target.value)}
                        InputLabelProps={{
                            shrink: true,
                        }}
                        required
                    />
                 </DialogContent>
                <DialogActions>
                    <Button onClick={() => setOpenScheduleDialog(false)} disabled={actionLoading}>Cancel</Button>
                    <Button onClick={handleScheduleInterview} disabled={actionLoading}>
                         {actionLoading ? <CircularProgress size={20} /> : 'Schedule'}
                     </Button>
                 </DialogActions>
             </Dialog>

            {/* Reject Application Dialog */}
             <Dialog open={openRejectDialog} onClose={() => setOpenRejectDialog(false)}>
                 <DialogTitle>Reject Application</DialogTitle>
                 <DialogContent>
                    <DialogContentText>
                        Please provide a reason for rejecting this application. This will be recorded in the notes.
                     </DialogContentText>
                     {feedback.type === 'error' && <Alert severity="error" sx={{ mb: 1 }}>{feedback.message}</Alert>}
                     <TextField
                        autoFocus
                        margin="dense"
                        id="rejectionReason"
                        label="Rejection Reason"
                        type="text"
                        fullWidth
                        multiline
                        rows={3}
                        variant="standard"
                        value={rejectionReason}
                        onChange={(e) => setRejectionReason(e.target.value)}
                        required
                     />
                 </DialogContent>
                 <DialogActions>
                     <Button onClick={() => setOpenRejectDialog(false)} disabled={actionLoading}>Cancel</Button>
                     <Button onClick={handleRejectApplication} color="error" disabled={actionLoading}>
                         {actionLoading ? <CircularProgress size={20} /> : 'Confirm Rejection'}
                     </Button>
                 </DialogActions>
            </Dialog>

        </Container>
    );
}

--- component\Page\Admin\AdminApplicationsListPage.js ---
// --- src/component/Page/Admin/AdminApplicationsListPage.js ---
// Enhanced version with logging and improved rendering logic

import React, { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import { Link as RouterLink, useNavigate } from 'react-router-dom';

// Import MUI components
import {
    Container, Typography, Box, Button, Paper, Grid, Tooltip, Chip, IconButton,
    TableContainer, Table, TableHead, TableRow, TableCell, TableBody,
    CircularProgress, Alert, Link as MuiLink // Import necessary MUI components
} from '@mui/material';
// Import Icons
import RefreshIcon from '@mui/icons-material/Refresh';
import VisibilityIcon from '@mui/icons-material/Visibility';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';

// Backend API Base URL
const API_BASE_URL = 'http://localhost:8080';

// --- Helper Functions ---

// Formats date-time string for display
const formatDateTime = (dateTimeString) => {
    if (!dateTimeString) return 'N/A';
    try {
        // Options for formatting: e.g., "Aug 23, 2023, 10:30 AM"
        const options = { year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true };
        return new Intl.DateTimeFormat('en-US', options).format(new Date(dateTimeString));
    } catch (e) {
        console.error("Date formatting error:", e);
        return 'Invalid Date';
    }
};

// Creates a styled Chip based on application status
const getStatusChip = (status) => {
    let color = 'default';
    let label = 'Unknown';

    if (status) {
        label = status.replace('_', ' '); // Replace underscores for readability
        switch (status) {
            case 'PENDING': color = 'warning'; break;
            case 'UNDER_REVIEW': color = 'info'; break;
            case 'INTERVIEW_SCHEDULED': color = 'primary'; break;
            case 'HIRED': color = 'success'; break;
            case 'REJECTED': color = 'error'; break;
            default: color = 'default'; label = status; // Show original if not matched
        }
    }
    // Return MUI Chip component
    return <Chip label={label} color={color} size="small" variant="outlined" />;
};

// --- Component ---

export default function AdminApplicationsListPage() {
    // --- State Variables ---
    const [applications, setApplications] = useState([]); // Holds the fetched application data
    const [isLoading, setIsLoading] = useState(false); // Tracks loading state for fetch
    const [error, setError] = useState(''); // Stores any fetch error messages
    const navigate = useNavigate(); // Hook for programmatic navigation

    // --- Data Fetching Logic ---
    const fetchApplications = useCallback(async () => {
        setIsLoading(true); // Start loading indicator
        setError(''); // Clear previous errors
        console.log("[Frontend] Fetching applications from /admin/applications..."); // LOG 1

        try {
            // Make API call to backend endpoint
            const response = await axios.get(`${API_BASE_URL}/admin/applications`, {
                withCredentials: true // Necessary for authenticated admin endpoints
            });

            console.log("[Frontend] Raw API Response:", response); // LOG 2
            console.log("[Frontend] Response Data:", response.data); // LOG 3

            // Validate the received data
            if (response && Array.isArray(response.data)) {
                console.log(`[Frontend] Received valid array with ${response.data.length} items. Setting state.`); // LOG 4
                setApplications(response.data); // Update state with the array of applications
            } else {
                console.error("[Frontend] Invalid data received. Expected an array, got:", response.data); // LOG 5
                setError("Received unexpected data format from server."); // Set error message
                setApplications([]); // Reset state to empty array
            }
        } catch (err) {
            // Handle API call errors
            console.error("[Frontend] API call failed:", err); // LOG 6
            if (err.response) { // Log details if available
                console.error("[Frontend] Error response data:", err.response.data);
                console.error("[Frontend] Error response status:", err.response.status);
            }
            // Set user-friendly error message
            setError(err.response?.data?.message || err.response?.data || err.message || 'Failed to fetch job applications.');
            setApplications([]); // Reset state on error
        } finally {
            setIsLoading(false); // Stop loading indicator regardless of outcome
        }
    }, []); // `useCallback` with empty dependency array means this function is created once

    // --- Initial Data Fetch ---
    useEffect(() => {
        fetchApplications(); // Fetch data when the component mounts
    }, [fetchApplications]); // Dependency array ensures fetchApplications isn't recreated unnecessarily

    // --- State Change Logger (for debugging) ---
    useEffect(() => {
        console.log("[Frontend] 'applications' state updated to:", applications); // LOG 7
    }, [applications]); // Runs whenever the `applications` state value changes

    // --- Navigation Handler ---
    const handleViewDetails = (appId) => {
        // Navigate to the detail page for the specific application ID
        navigate(`/admin/applications/${appId}`);
    };

    // --- Render Logic ---
    return (
        <Container maxWidth="xl" sx={{ mt: 4, mb: 4 }}> {/* Wider container */}

             {/* Styled Header */}
            <Paper elevation={4} sx={{
                p: 2, mb: 3, textAlign: 'center',
                background: 'linear-gradient(45deg, #ff9800 30%, #f57c00 90%)', // Orange gradient
                color: 'white', borderRadius: '8px'
            }}>
                 <Typography variant="h4" component="h1" sx={{ fontWeight: 'bold' }}>
                    Manage Job Applications
                </Typography>
            </Paper>

             {/* Main Content Area */}
             <Paper elevation={2} sx={{ p: { xs: 1, sm: 2, md: 3 }, borderRadius: '8px' }}>
                 {/* Top Bar: Back Button & Refresh */}
                 <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2, borderBottom: '1px solid #eee', pb: 1 }}>
                     <Button variant="outlined" color="primary" size="small" startIcon={<ArrowBackIcon />}
                        onClick={() => navigate('/admin/dashboard')}>
                        Admin Dashboard
                    </Button>
                    <Tooltip title="Refresh List">
                        <span> {/* Wrapper for tooltip when button is disabled */}
                            <IconButton onClick={fetchApplications} color="primary" disabled={isLoading}>
                                <RefreshIcon />
                            </IconButton>
                        </span>
                    </Tooltip>
                 </Box>

                {/* Loading State Indicator */}
                {isLoading && (
                    <Box sx={{ display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', my: 5, minHeight: '300px' }}>
                        <CircularProgress size={50} />
                        <Typography variant="h6" color="text.secondary" sx={{mt: 2}}>Loading Applications...</Typography>
                    </Box>
                )}

                {/* Error State Display */}
                {!isLoading && error && (
                    <Box sx={{ my: 3, textAlign: 'center' }}> {/* Centered error */}
                        <Alert severity="error" sx={{ mb: 2, justifyContent: 'center' }}>{error}</Alert>
                        <Button onClick={fetchApplications} variant="contained">Try Again</Button>
                    </Box>
                )}

                {/* Table Display (only when not loading and no error) */}
                {!isLoading && !error && (
                    <TableContainer component={Paper} variant="outlined">
                        <Table stickyHeader aria-label="job applications table">
                            <TableHead>
                                <TableRow sx={{ '& th': { fontWeight: 'bold', backgroundColor: 'grey.200' } }}> {/* Styled header */}
                                    <TableCell>Applicant Name</TableCell>
                                    <TableCell>Email</TableCell>
                                    <TableCell>Phone</TableCell>
                                    <TableCell>Desired Role</TableCell>
                                    <TableCell>Applied On</TableCell>
                                    <TableCell align="center">Status</TableCell>
                                    <TableCell align="center">Actions</TableCell>
                                </TableRow>
                            </TableHead>
                            <TableBody>
                                {/* Conditional Rendering: Show message or map data */}
                                { !Array.isArray(applications) || applications.length === 0 ? (
                                    // Display when applications is not an array or is empty
                                    <TableRow>
                                        <TableCell colSpan={7} align="center" sx={{ py: 5, fontStyle: 'italic', color: 'text.secondary' }}>
                                            No submitted job applications found.
                                         </TableCell>
                                    </TableRow>
                                ) : (
                                    // Map and render rows only if applications is a non-empty array
                                    applications.map((app, index) => (
                                        <TableRow
                                            hover
                                            key={app.id} // Use unique ID from application data
                                            sx={{
                                                '&:last-child td, &:last-child th': { border: 0 },
                                                backgroundColor: index % 2 !== 0 ? 'action.hover' : 'background.paper' // Alternate row bg
                                             }}
                                        >
                                            {/* Display application data - use 'N/A' as fallback */}
                                            <TableCell sx={{fontSize: '0.875rem'}}>{`${app.applicantFirstName || 'N/A'} ${app.applicantLastName || ''}`.trim()}</TableCell>
                                            <TableCell sx={{fontSize: '0.875rem'}}>{app.applicantEmail || 'N/A'}</TableCell>
                                            <TableCell sx={{fontSize: '0.875rem'}}>{app.applicantPhone || 'N/A'}</TableCell>
                                            <TableCell sx={{fontSize: '0.875rem'}}>{app.desiredRole || 'N/A'}</TableCell>
                                            <TableCell sx={{fontSize: '0.875rem'}}>{formatDateTime(app.applicationDate)}</TableCell>
                                            <TableCell align="center">{getStatusChip(app.status)}</TableCell>
                                            <TableCell align="center">
                                                {/* Action button to view details */}
                                                <Tooltip title="View Details & Actions">
                                                    <IconButton color="primary" size="small" onClick={() => handleViewDetails(app.id)}>
                                                        <VisibilityIcon fontSize="small" />
                                                    </IconButton>
                                                </Tooltip>
                                            </TableCell>
                                        </TableRow>
                                    ))
                                )}
                            </TableBody>
                        </Table>
                    </TableContainer>
                )}
            </Paper> {/* End Content Paper */}
        </Container>
    );
}

--- component\Page\Admin\AdminDashboardPage.js ---

import React from 'react'; // Only React needed now
import { Link as RouterLink } from 'react-router-dom'; // Import RouterLink for navigation
import SavingsIcon from '@mui/icons-material/Savings'; // <<< ADD THIS LIN

import {
    Container, Typography, Box, Button, Paper, Grid, Card, CardContent, CardActions
} from '@mui/material';
// Import MUI Icons
import PeopleAltIcon from '@mui/icons-material/PeopleAlt'; // For Customers Approvals card
import WorkOutlineIcon from '@mui/icons-material/WorkOutline'; // For Job Applications card
import ManageAccountsIcon from '@mui/icons-material/ManageAccounts'; // For Employee Actions card
import CreditScoreIcon from '@mui/icons-material/CreditScore';
// ... other imports ...

export default function AdminDashboardPage() {
    // Removed ALL state, useEffect, useCallback, and functions related to
    // fetching or handling pending customers. This component is now purely presentational/navigational.

    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            {/* Dashboard Header */}
            <Paper elevation={3} sx={{ p: { xs: 2, md: 3 }, mb: 4, textAlign: 'center', background: 'linear-gradient(45deg, #673ab7 30%, #3f51b5 90%)', color: 'white' }}>
                <Typography variant="h4" component="h1" gutterBottom sx={{ fontWeight: 'bold' }}>
                    Admin Dashboard
                </Typography>
                <Typography variant="body1" sx={{ color: 'rgba(255, 255, 255, 0.8)' }}>
                    Select an area to manage customer accounts, job applications, or perform employee actions.
                </Typography>
            </Paper>

            {/* Action Cards Grid - Now centered */}
            <Grid container spacing={4} justifyContent="center" alignItems="stretch">

                {/* Card 1: Customer Approvals */}
                <Grid item xs={12} sm={6} md={4}> {/* Cards can now take up more space if needed */}
                    <Card sx={{ display: 'flex', flexDirection: 'column', height: '100%', '&:hover': { boxShadow: 8, transform: 'scale(1.02)' }, transition: 'box-shadow 0.3s, transform 0.3s', borderTop: '4px solid', borderColor: 'primary.main' }}>
                        <CardContent sx={{ flexGrow: 1, textAlign: 'center', p: 3 }}>
                            <PeopleAltIcon color="primary" sx={{ fontSize: 60, mb: 2 }} />
                            <Typography gutterBottom variant="h5" component="h2" sx={{ fontWeight: 500 }}>
                                Customer Approvals
                            </Typography>
                            <Typography variant="body2" color="text.secondary" sx={{ minHeight: '40px' }}>
                                View and manage pending customer registrations.
                            </Typography>
                        </CardContent>
                        <CardActions sx={{ justifyContent: 'center', pb: 3 }}>
                            <Button
                                component={RouterLink}
                                // Ensure path matches App.js route for PendingApprovalsPage
                                to="/admin/pending"
                                size="medium"
                                variant="contained"
                                color="primary"
                            >
                                Manage Customers
                            </Button>
                        </CardActions>
                    </Card>
                </Grid>

                {/* Card 2: Job Applications */}
                <Grid item xs={12} sm={6} md={4}>
                    <Card sx={{ display: 'flex', flexDirection: 'column', height: '100%', '&:hover': { boxShadow: 8, transform: 'scale(1.02)' }, transition: 'box-shadow 0.3s, transform 0.3s', borderTop: '4px solid', borderColor: 'secondary.main' }}>
                        <CardContent sx={{ flexGrow: 1, textAlign: 'center', p: 3 }}>
                            <WorkOutlineIcon color="secondary" sx={{ fontSize: 60, mb: 2 }} />
                            <Typography gutterBottom variant="h5" component="h2" sx={{ fontWeight: 500 }}>
                                Job Applications
                            </Typography>
                            <Typography variant="body2" color="text.secondary" sx={{ minHeight: '40px' }}>
                                Review submitted applications and manage hiring.
                            </Typography>
                        </CardContent>
                        <CardActions sx={{ justifyContent: 'center', pb: 3 }}>
                            <Button
                                component={RouterLink}
                                to="/admin/applications" // Link to the applications list page
                                size="medium"
                                variant="contained"
                                color="secondary"
                            >
                                Manage Applications
                            </Button>
                        </CardActions>
                    </Card>
                </Grid>

                {/* Card 3: Employee Actions Portal */}
                <Grid item xs={12} sm={6} md={4}>
                     <Card sx={{ display: 'flex', flexDirection: 'column', height: '100%', '&:hover': { boxShadow: 8, transform: 'scale(1.02)' }, transition: 'box-shadow 0.3s, transform 0.3s', borderTop: '4px solid', borderColor: 'success.main' }}>
                        <CardContent sx={{ flexGrow: 1, textAlign: 'center', p: 3 }}>
                             <ManageAccountsIcon sx={{ fontSize: 60, mb: 2, color: 'success.main' }} />
                             <Typography gutterBottom variant="h5" component="h2" sx={{ fontWeight: 500 }}>
                                Employee Actions
                             </Typography>
                             <Typography variant="body2" color="text.secondary" sx={{ minHeight: '40px' }}>
                                Access employee functions (deposit, withdrawal, etc.).
                             </Typography>
                        </CardContent>
                        <CardActions sx={{ justifyContent: 'center', pb: 3 }}>
                            <Button
                                component={RouterLink}
                                to="/employee/dashboard" // Link to the main employee dashboard
                                size="medium"
                                variant="contained"
                                color="success"
                            >
                                Go to Employee Portal
                            </Button>
                        </CardActions>
                    </Card>
                </Grid>

                <Grid item xs={12} sm={6} md={4}>
                     <Card sx={{ display: 'flex', flexDirection: 'column', height: '100%', '&:hover': { boxShadow: 8, transform: 'scale(1.02)' }, transition: 'box-shadow 0.3s ease, transform 0.3s ease', borderTop: '4px solid', borderColor: 'warning.main', borderRadius: 2 }}>
                        <CardContent sx={{ flexGrow: 1, textAlign: 'center', p: 3 }}>
                             <CreditScoreIcon sx={{ fontSize: 50, mb: 1.5, color: 'warning.main' }} /> {/* Loan Icon */}
                             <Typography gutterBottom variant="h5" component="h2" sx={{ fontWeight: 500 }}>
                                Loan Approvals
                             </Typography>
                             <Typography variant="body2" color="text.secondary" sx={{ minHeight: '40px', px: 1 }}>
                                Review and approve/reject pending Loan Applications.
                             </Typography>
                        </CardContent>
                        <CardActions sx={{ justifyContent: 'center', p: 2 }}>
                            <Button
                                component={RouterLink}
                                to="/admin/loan/pending" // Link to the Admin Loan Pending Page
                                size="medium"
                                variant="contained"
                                color="warning" // Use a distinct color
                            >
                                Manage Loans
                            </Button>
                        </CardActions>
                    </Card>
                </Grid>

                {/* Card 3: Fixed Deposit Approvals */}
                <Grid item xs={12} sm={6} md={4}>
                    <Card sx={{ display: 'flex', flexDirection: 'column', height: '100%', '&:hover': { boxShadow: 8, transform: 'scale(1.02)' }, /* ... other styles ... */ borderTop: '4px solid', borderColor: 'info.main', borderRadius: 2 }}>
                        <CardContent sx={{ flexGrow: 1, textAlign: 'center', p: 3 }}>
                             <SavingsIcon sx={{ fontSize: 50, mb: 1.5, color: 'info.main' }} />
                             <Typography gutterBottom variant="h5" component="h2" sx={{ fontWeight: 500 }}>
                                FD Approvals
                             </Typography>
                             <Typography variant="body2" color="text.secondary" sx={{ minHeight: '40px', px: 1 }}>
                                Review and approve/reject pending Fixed Deposits.
                             </Typography>
                        </CardContent>
                        <CardActions sx={{ justifyContent: 'center', p: 2 }}>
                            <Button component={RouterLink} to="/admin/fd/pending" size="medium" variant="contained" color="info">
                                Manage FDs
                            </Button>
                        </CardActions>
                    </Card>
                </Grid>
                {/* Removed the duplicate "Customer Section" card from your last input */}

            </Grid> {/* End Action Cards Grid */}

            {/* No Table or Snackbar needed here anymore */}

        </Container>
    );
}

--- component\Page\Admin\PendingApprovaslPage.js ---
// --- src/pages/Admin/PendingApprovalsPage.js ---
import React, { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import { useAuth } from '../../../context/AuthContext'; // Correct path assumed

// Import MUI components
import {
    Container, Typography, Paper, TableContainer, Table, TableHead, TableRow, TableCell, TableBody, Button,
    CircularProgress, Alert, Snackbar, Box
} from '@mui/material';

// Base URL for your backend
const API_BASE_URL = 'http://localhost:8080';

export default function PendingApprovalsPage() {
    const [pendingUsers, setPendingUsers] = useState([]);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [successMessage, setSuccessMessage] = useState('');
    const { authState } = useAuth(); // Get auth state

    // Helper function to extract error message string (keep this)
    const getErrorMessage = (err) => {
        let message = 'An unexpected error occurred.'; // Default
        if (err.response) {
            // Log the full error response for detailed debugging
            console.error("API Error Response:", err.response);
            if (err.response.status === 403) {
                message = 'Forbidden: You do not have permission to access this resource. Please ensure you are logged in as an Admin.';
            } else if (err.response.data?.message && typeof err.response.data.message === 'string') {
                message = err.response.data.message;
            } else if (err.response.data && typeof err.response.data === 'string') {
                message = err.response.data;
            } else if (err.response.statusText) {
                 message = `Error: ${err.response.status} ${err.response.statusText}`;
            }
        } else if (err.message) {
            message = err.message; // Network errors, etc.
        }
        return message;
    };

    // Function to fetch pending users
    const fetchPendingUsers = useCallback(async () => {
        // Ensure user is logged in and is an admin before fetching
        if (!authState.isLoggedIn || authState.userRole !== 'ROLE_ADMIN') {
             setError("Access Denied: You must be logged in as an Admin.");
             setIsLoading(false);
             setPendingUsers([]);
             return; // Stop execution if not admin
        }

        setIsLoading(true);
        setError('');
        console.log("Attempting to fetch /admin/pending..."); // Add log

        try {
            const response = await axios.get(`${API_BASE_URL}/admin/pending`, {
                 withCredentials: true // Essential for sending session cookie
            });

            console.log("Response from /admin/pending:", response); // Log success response

            if (Array.isArray(response.data)) {
                setPendingUsers(response.data);
            } else {
                console.warn("Received non-array data for pending users:", response.data);
                setPendingUsers([]);
                setError("Received unexpected data format from server.");
            }

        } catch (err) {
            // *** Log the error object itself for detailed inspection ***
            console.error("Error fetching pending users (Full Error Object):", err);
            setError(getErrorMessage(err)); // Use helper to set user-friendly message
            setPendingUsers([]);
        } finally {
            setIsLoading(false);
        }
        // Depend on authState to re-check permissions if needed
    }, [authState.isLoggedIn, authState.userRole]);


    // Fetch users when component mounts or auth state changes
    useEffect(() => {
        fetchPendingUsers();
    }, [fetchPendingUsers]); // fetchPendingUsers includes authState dependencies

    // --- handleApprove and handleReject remain the same, but will benefit ---
    // --- from the improved getErrorMessage helper                       ---

    // Handler for Approving a user
    const handleApprove = async (customerId) => {
        setError('');
        setSuccessMessage('');
        try {
            const response = await axios.post(`${API_BASE_URL}/admin/approve/${customerId}`, null, {
                 withCredentials: true
            });
            setSuccessMessage(typeof response.data === 'string' ? response.data : `User ${customerId} approved successfully!`);
            fetchPendingUsers(); // Refresh
        } catch (err) {
            console.error(`Error approving user ${customerId}:`, err);
            setError(getErrorMessage(err));
        }
    };

    // Handler for Rejecting a user
    const handleReject = async (customerId) => {
        if (!window.confirm(`Are you sure you want to reject and remove user ${customerId}?`)) {
            return;
        }
        setError('');
        setSuccessMessage('');
        try {
            const response = await axios.post(`${API_BASE_URL}/admin/reject/${customerId}`, null, {
                 withCredentials: true
            });
            setSuccessMessage(typeof response.data === 'string' ? response.data : `User ${customerId} rejected successfully!`);
            fetchPendingUsers(); // Refresh
        } catch (err) {
            console.error(`Error rejecting user ${customerId}:`, err);
            setError(getErrorMessage(err));
        }
    };

    // --- JSX Rendering ---
    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
              <Paper elevation={3} sx={{ p: { xs: 2, md: 3 }, mb: 2, textAlign: 'center', background: 'linear-gradient(45deg, #673ab7 30%, #3f51b5 90%)', color: 'white' }}>
                         <Typography variant="h4" component="h2" gutterBottom sx={{ fontWeight: 'bold' }}>
                         Pending Customer Approvals
                        </Typography>
                </Paper>

            {/* Loading Indicator */}
            {isLoading && (
                <Box sx={{ display: 'flex', justifyContent: 'center', my: 3 }}>
                    <CircularProgress />
                </Box>
            )}

            {/* Error Alert */}
            {error && (
                <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>
            )}

            {/* Success Snackbar */}
             <Snackbar
                open={!!successMessage}
                autoHideDuration={6000}
                onClose={() => setSuccessMessage('')}
                message={successMessage}
             />

            {/* Table of Pending Users */}
            {/* Render table only when not loading */}
            {!isLoading && (
                <Paper sx={{ width: '100%', overflow: 'hidden' }}>
                    <TableContainer sx={{ maxHeight: 600 }}>
                        <Table stickyHeader aria-label="pending users table">
                            <TableHead>
                                <TableRow>
                                    <TableCell sx={{ backgroundColor: 'primary.light', color: 'primary.contrastText', fontWeight: 'bold' }}>Customer ID</TableCell>
                                    <TableCell sx={{ backgroundColor: 'primary.light', color: 'primary.contrastText', fontWeight: 'bold' }}>Name</TableCell>
                                    <TableCell sx={{ backgroundColor: 'primary.light', color: 'primary.contrastText', fontWeight: 'bold' }}>Email</TableCell>
                                    <TableCell sx={{ backgroundColor: 'primary.light', color: 'primary.contrastText', fontWeight: 'bold' }}>Mobile</TableCell>
                                    <TableCell sx={{ backgroundColor: 'primary.light', color: 'primary.contrastText', fontWeight: 'bold' }}>Account No</TableCell>
                                    <TableCell sx={{ backgroundColor: 'primary.light', color: 'primary.contrastText', fontWeight: 'bold', textAlign: 'center' }}>Actions</TableCell>
                                </TableRow>
                            </TableHead>
                            <TableBody>
                                {/* Show message if loading is finished and there are no users AND no error */}
                                {!error && pendingUsers.length === 0 ? (
                                     <TableRow>
                                         <TableCell colSpan={6} align="center" sx={{ py: 3, fontStyle: 'italic', color: 'text.secondary' }}>
                                            No pending registrations found.
                                         </TableCell>
                                     </TableRow>
                                ) : (
                                     Array.isArray(pendingUsers) && pendingUsers.map((user) => (
                                        <TableRow hover key={user.customerId}>
                                            <TableCell>{user.customerId || 'N/A'}</TableCell>
                                            <TableCell>{`${user.fname || ''} ${user.lname || ''}`.trim() || 'N/A'}</TableCell>
                                            <TableCell>{user.email || 'N/A'}</TableCell>
                                            <TableCell>{user.mobileNumber || 'N/A'}</TableCell>
                                            <TableCell>{user.accountNumber || 'N/A'}</TableCell>
                                            <TableCell align="center">
                                                <Button
                                                    variant="contained"
                                                    color="success"
                                                    size="small"
                                                    onClick={() => handleApprove(user.customerId)}
                                                     sx={{ mr: 1, minWidth: '80px' }}
                                                >
                                                    Approve
                                                </Button>
                                                <Button
                                                    variant="contained"
                                                    color="error"
                                                    size="small"
                                                    onClick={() => handleReject(user.customerId)}
                                                     sx={{ minWidth: '80px' }}
                                                >
                                                    Reject
                                                </Button>
                                            </TableCell>
                                        </TableRow>
                                    ))
                                )}
                            </TableBody>
                        </Table>
                    </TableContainer>
                </Paper>
            )}
        </Container>
    );
}

--- component\Page\Admin\PendingFdsPage.js ---
import React, { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import {
    Container, Typography, Paper, TableContainer, Table, TableHead, TableRow, TableCell, TableBody,
    Button, CircularProgress, Alert, Snackbar, Box, Dialog, DialogActions, DialogContent,
    DialogContentText, DialogTitle, TextField, Tooltip, IconButton, Grid, Chip, Collapse
} from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../../context/AuthContext'; // Adjust path
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import CheckCircleOutlineIcon from '@mui/icons-material/CheckCircleOutline';
import CancelIcon from '@mui/icons-material/Cancel';
import RefreshIcon from '@mui/icons-material/Refresh';
import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';
import KeyboardArrowUpIcon from '@mui/icons-material/KeyboardArrowUp';
// <<< MOVE THE FORMATTERS IMPORT HERE >>>
import { formatDate,  formatDateTime, formatCurrency, getFdStatusChip } from '../../../utils/formatters';

const API_BASE_URL = 'http://localhost:8080'; // Now this is after all imports


// --- PendingFdRow Sub-component (Admin View) ---
function PendingFdRow({ fd, onApproveClick, onRejectClick, actionLoadingId }) {
    const [open, setOpen] = useState(false);
    const isLoading = actionLoadingId === fd.id; // Is action loading for *this* specific row?

    return (
        <React.Fragment>
            {/* Main visible row */}
            <TableRow hover sx={{ '& > *': { borderBottom: 'unset' } }}>
                <TableCell sx={{ width: '5%' }}>
                    <IconButton aria-label="expand row" size="small" onClick={() => setOpen(!open)}>
                        {open ? <KeyboardArrowUpIcon /> : <KeyboardArrowDownIcon />}
                    </IconButton>
                </TableCell>
                <TableCell sx={{ width: '5%' }}>{fd.id}</TableCell>
                <TableCell sx={{ width: '15%' }}>{fd.customerId}</TableCell>
                <TableCell sx={{ width: '20%' }}>{formatDateTime(fd.applicationDate)}</TableCell>
                <TableCell sx={{ width: '15%' }} align="right">{formatCurrency(fd.principalAmount)}</TableCell>
                <TableCell sx={{ width: '10%' }}>{fd.termInMonths} Mo</TableCell>
                <TableCell sx={{ width: '15%' }} align="center">
                    {/* Action Buttons */}
                     <Tooltip title="Approve FD">
                         <span> {/* Wrapper for disabled button tooltip */}
                             <IconButton size="small" onClick={() => onApproveClick(fd.id)} color="success" disabled={isLoading}>
                                {isLoading ? <CircularProgress size={18} color="inherit"/> : <CheckCircleOutlineIcon fontSize='small' />}
                             </IconButton>
                        </span>
                     </Tooltip>
                     <Tooltip title="Reject FD">
                          <span>
                              <IconButton size="small" onClick={() => onRejectClick(fd.id)} color="error" disabled={isLoading}>
                                 <CancelIcon fontSize='small'/>
                              </IconButton>
                          </span>
                     </Tooltip>
                </TableCell>
            </TableRow>
            {/* Collapsible details row */}
            <TableRow>
                 <TableCell style={{ paddingBottom: 0, paddingTop: 0 }} colSpan={7}> {/* Span all columns */}
                    <Collapse in={open} timeout="auto" unmountOnExit>
                         <Box sx={{ margin: 1, p: 2, border: '1px dashed #e0e0e0', borderRadius: 1, backgroundColor: '#fafafa' }}>
                             <Typography variant="subtitle2" gutterBottom component="div" sx={{ fontWeight: 'bold', mb: 1 }}>
                                 FD Details (ID: {fd.id}, Customer: {fd.customerId})
                             </Typography>
                            <Grid container spacing={1} sx={{ fontSize: '0.9rem' }}>
                                <Grid item xs={6} sm={4}><strong>Source Acc:</strong> {fd.sourceAccountNumber || 'N/A'}</Grid>
                                <Grid item xs={6} sm={4}><strong>Interest Rate:</strong> {fd.interestRate?.toFixed(2)}%</Grid>
                                <Grid item xs={12} sm={4}><strong>Maturity Amt:</strong> {formatCurrency(fd.maturityAmount)}</Grid>
                                {/* Add any other details relevant for admin review from fd object */}
                            </Grid>
                         </Box>
                    </Collapse>
                </TableCell>
            </TableRow>
        </React.Fragment>
    );
}
// --- End PendingFdRow Sub-component ---


// --- PendingFdsPage Main Component ---
export default function PendingFdsPage() {
    const navigate = useNavigate();
    const { authState } = useAuth();
    const [pendingFds, setPendingFds] = useState([]);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'info' });
    const [actionLoadingId, setActionLoadingId] = useState(null); // Tracks which FD action is processing

    // State for rejection dialog
    const [rejectDialogOpen, setRejectDialogOpen] = useState(false);
    const [currentFdId, setCurrentFdId] = useState(null); // ID of FD for dialog
    const [rejectionReason, setRejectionReason] = useState('');

    // Fetch pending FDs
    const fetchPendingFds = useCallback(async () => {
        if (!authState.isLoggedIn || authState.userRole !== 'ROLE_ADMIN') {
            setError("Access Denied: Admin privileges required.");
            setIsLoading(false);
            return;
        }
        setIsLoading(true);
        setError('');
        try {
            const response = await axios.get(`${API_BASE_URL}/admin/fd/pending`, { withCredentials: true });
            if (Array.isArray(response.data)) {
                setPendingFds(response.data);
            } else {
                throw new Error("Received unexpected data format from server.");
            }
        } catch (err) {
            console.error("Error fetching pending FDs:", err);
            setError(err.response?.data?.message || err.message || 'Failed to load pending FD applications.');
            setPendingFds([]);
        } finally {
            setIsLoading(false);
        }
    }, [authState.isLoggedIn, authState.userRole]);

    // Fetch on mount
    useEffect(() => {
        fetchPendingFds();
    }, [fetchPendingFds]);

    // Snackbar handlers
    const handleSnackbarClose = (event, reason) => { if (reason === 'clickaway') return; setSnackbar({ ...snackbar, open: false }); };
    const showSnackbar = (message, severity = 'success') => { setSnackbar({ open: true, message, severity }); };

    // --- Dialog Open/Close for Rejection ---
    const openRejectDialog = (fdId) => {
        setCurrentFdId(fdId);
        setRejectionReason(''); // Clear previous reason
        setRejectDialogOpen(true);
    };
    const closeRejectDialog = () => {
        setRejectDialogOpen(false);
        setCurrentFdId(null);
    };

    // --- Action Handlers (Approve & Reject) ---
    const handleApprove = async (fdId) => {
        setActionLoadingId(fdId);
        setError('');
        try {
            const response = await axios.post(`${API_BASE_URL}/admin/fd/approve/${fdId}`, null, { withCredentials: true });
            showSnackbar(response.data?.message || `FD ${fdId} approved successfully!`, 'success');
            fetchPendingFds(); // Refresh the list
        } catch (err) {
             console.error(`Error approving FD ${fdId}:`, err);
             const errorMsg = err.response?.data?.message || `Failed to approve FD ${fdId}. Ensure customer has sufficient balance.`;
             setError(errorMsg); // Show error prominently
             showSnackbar(errorMsg, 'error');
        } finally {
             setActionLoadingId(null);
        }
    };

    const handleReject = async () => {
        if (!rejectionReason.trim()) {
            showSnackbar('Please provide a non-empty rejection reason.', 'warning');
            return;
        }
        setActionLoadingId(currentFdId);
        setError('');
        try {
           const response = await axios.post(
               `${API_BASE_URL}/admin/fd/reject/${currentFdId}`,
               { reason: rejectionReason }, // Send reason in request body
               { withCredentials: true }
           );
           showSnackbar(response.data?.message || `FD ${currentFdId} rejected successfully.`, 'success');
           closeRejectDialog();
           fetchPendingFds(); // Refresh
       } catch (err) {
            console.error(`Error rejecting FD ${currentFdId}:`, err);
            const errorMsg = err.response?.data?.message || `Failed to reject FD ${currentFdId}.`;
            showSnackbar(errorMsg, 'error'); // Show error in snackbar
            // Optionally, you could set the main `error` state too, or display error in dialog
       } finally {
            setActionLoadingId(null);
       }
    };

    // Render access denied if not admin
    if (!authState.isLoggedIn || authState.userRole !== 'ROLE_ADMIN') {
        return (
            <Container maxWidth="md" sx={{ mt: 4 }}><Alert severity="error">Access Denied. Admin privileges required.</Alert></Container>
        );
    }

    // Main Render
    return (
        <Container maxWidth="xl" sx={{ mt: 4, mb: 4 }}>
            <Paper elevation={2} sx={{ p: { xs: 2, md: 3 }, borderRadius: 2 }}>
                 {/* Header */}
                 <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3, borderBottom: 1, borderColor: 'divider', pb: 2 }}>
                    <Typography variant="h5" component="h1" sx={{ fontWeight: 'bold' }}>Pending Fixed Deposit Applications</Typography>
                    <Box>
                         <Tooltip title="Refresh List">
                            <IconButton onClick={fetchPendingFds} disabled={isLoading || !!actionLoadingId} color="primary" sx={{ mr: 1 }}>
                                <RefreshIcon />
                             </IconButton>
                         </Tooltip>
                         <Button variant="outlined" size="small" startIcon={<ArrowBackIcon />} onClick={() => navigate('/admin/dashboard')}>Admin Dashboard</Button>
                     </Box>
                 </Box>

                {/* Loading / Error / Snackbar */}
                {isLoading && <Box sx={{ display: 'flex', justifyContent: 'center', my: 5 }}><CircularProgress /></Box>}
                {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}
                <Snackbar open={snackbar.open} autoHideDuration={5000} onClose={handleSnackbarClose} anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}>
                    <Alert onClose={handleSnackbarClose} severity={snackbar.severity} sx={{ width: '100%' }} variant="filled">
                        {snackbar.message}
                    </Alert>
                </Snackbar>

                {/* Table */}
                {!isLoading && !error && (
                    <TableContainer component={Paper} variant="outlined">
                        <Table stickyHeader aria-label="collapsible pending fixed deposit applications table">
                            <TableHead sx={{ backgroundColor: 'primary.lighter', '& th': { fontWeight: 'bold', color: 'primary.contrastText' } }}>
                                <TableRow>
                                     <TableCell /> {/* Collapse icon */}
                                    <TableCell>FD ID</TableCell>
                                    <TableCell>Customer ID</TableCell>
                                    <TableCell>Applied On</TableCell>
                                    <TableCell align="right">Principal (₹)</TableCell>
                                    <TableCell>Term</TableCell>
                                    <TableCell align="center">Actions</TableCell>
                                </TableRow>
                            </TableHead>
                            <TableBody>
                                {pendingFds.length === 0 ? (
                                    <TableRow><TableCell colSpan={7} align="center" sx={{ py: 4, fontStyle: 'italic', color: 'text.secondary' }}>No pending FD applications found.</TableCell></TableRow>
                                ) : (
                                    pendingFds.map((fd) => (
                                        <PendingFdRow
                                            key={fd.id}
                                            fd={fd}
                                            onApproveClick={handleApprove} // Pass ID directly
                                            onRejectClick={openRejectDialog} // Pass ID to open dialog
                                            actionLoadingId={actionLoadingId}
                                        />
                                    ))
                                )}
                            </TableBody>
                        </Table>
                    </TableContainer>
                )}
            </Paper>

            {/* Rejection Reason Dialog */}
             <Dialog open={rejectDialogOpen} onClose={closeRejectDialog} maxWidth="xs" fullWidth>
                 <DialogTitle>Reject FD (ID: {currentFdId})</DialogTitle>
                <DialogContent>
                    <DialogContentText sx={{mb: 2}}>
                        Please provide a reason for rejecting this Fixed Deposit application.
                    </DialogContentText>
                    <TextField
                        autoFocus
                        margin="dense"
                        id="rejectionReason"
                        label="Rejection Reason"
                        type="text"
                        fullWidth
                        multiline
                        rows={3}
                        variant="outlined"
                        value={rejectionReason}
                        onChange={(e) => setRejectionReason(e.target.value)}
                        required
                    />
                </DialogContent>
                <DialogActions sx={{p: '16px 24px'}}>
                    <Button onClick={closeRejectDialog} disabled={actionLoadingId === currentFdId}>Cancel</Button>
                    <Button
                        onClick={handleReject}
                        color="error"
                        variant="contained"
                        disabled={actionLoadingId === currentFdId || !rejectionReason.trim()}
                    >
                        {actionLoadingId === currentFdId ? <CircularProgress size={20} color="inherit" /> : 'Confirm Rejection'}
                    </Button>
                </DialogActions>
            </Dialog>
        </Container>
    );
}

// Define helpers if not already globally available or imported
// const formatDateTime = (_dateTimeString) => { /* ... */ };
// const formatCurrency = (_amount) => { /* ... */ };



--- component\Page\Admin\PendingLoansPage.js ---
import React, { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import {
    Container, Typography, Paper, TableContainer, Table, TableHead, TableRow, TableCell, TableBody,
    Button, CircularProgress, Alert, Snackbar, Box, Dialog, DialogActions, DialogContent,
    DialogContentText, DialogTitle, TextField, Tooltip, IconButton, Grid, Chip, Collapse // Added Collapse
} from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../../context/AuthContext'; // Adjust path
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import CheckCircleOutlineIcon from '@mui/icons-material/CheckCircleOutline';
import CancelIcon from '@mui/icons-material/Cancel';
import RefreshIcon from '@mui/icons-material/Refresh';
import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';
import KeyboardArrowUpIcon from '@mui/icons-material/KeyboardArrowUp';

const API_BASE_URL = 'http://localhost:8080';

// --- Helper Functions (reuse or define here) ---
const formatDate = (dateString) => {
    if (!dateString) return 'N/A';
    try { return new Date(dateString).toLocaleString('en-IN', { dateStyle: 'short', timeStyle: 'short' }); }
    catch (e) { return 'Invalid Date'; }
};
const formatCurrency = (amount) => {
    if (amount === null || amount === undefined) return 'N/A';
    return `₹ ${amount.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
};
const getLoanStatusChip = (status) => { /* ... (same as MyLoansPage) ... */
    let color = 'default'; let label = status ? status.replace('_', ' ') : 'Unknown';
    switch (status) { /* ... cases ... */ }
    return <Chip label={label} color={color} size="small" variant="outlined" />;
};
// --- End Helper Functions ---


// --- PendingLoanRow Sub-component (Admin View) ---
function PendingLoanRow({ loan, onApproveClick, onRejectClick, actionLoadingId }) {
    const [open, setOpen] = useState(false);
    const isLoading = actionLoadingId === loan.id; // Check if action is loading for *this* row

    return (
        <React.Fragment>
            {/* Main visible row */}
            <TableRow hover sx={{ '& > *': { borderBottom: 'unset' } }}>
                <TableCell sx={{ width: '5%' }}>
                    <IconButton aria-label="expand row" size="small" onClick={() => setOpen(!open)}>
                        {open ? <KeyboardArrowUpIcon /> : <KeyboardArrowDownIcon />}
                    </IconButton>
                </TableCell>
                <TableCell sx={{ width: '5%' }}>{loan.id}</TableCell>
                <TableCell sx={{ width: '15%' }}>{loan.customerId}</TableCell>
                <TableCell sx={{ width: '20%' }}>{formatDate(loan.applicationDate)}</TableCell>
                <TableCell sx={{ width: '15%' }}>{loan.loanType}</TableCell>
                <TableCell sx={{ width: '15%' }} align="right">{formatCurrency(loan.requestedAmount)}</TableCell>
                <TableCell sx={{ width: '15%' }} align="center">
                    {/* Action Buttons */}
                    <Tooltip title="Approve Loan">
                         <span> {/* Required for tooltip on disabled button */}
                             <IconButton size="small" onClick={() => onApproveClick(loan)} color="success" disabled={isLoading}>
                                {isLoading ? <CircularProgress size={18} color="inherit"/> : <CheckCircleOutlineIcon fontSize='small' />}
                             </IconButton>
                        </span>
                     </Tooltip>
                     <Tooltip title="Reject Loan">
                          <span>
                              <IconButton size="small" onClick={() => onRejectClick(loan)} color="error" disabled={isLoading}>
                                 <CancelIcon fontSize='small'/>
                              </IconButton>
                          </span>
                     </Tooltip>
                </TableCell>
            </TableRow>
            {/* Collapsible details row */}
            <TableRow>
                <TableCell style={{ paddingBottom: 0, paddingTop: 0 }} colSpan={7}> {/* Span all columns */}
                    <Collapse in={open} timeout="auto" unmountOnExit>
                        <Box sx={{ margin: 1, p: 2, border: '1px dashed #e0e0e0', borderRadius: 1, backgroundColor: '#fafafa' }}>
                            <Typography variant="subtitle2" gutterBottom component="div" sx={{ fontWeight: 'bold', mb: 1 }}>
                                Details for Loan ID: {loan.id} (Customer: {loan.customerId})
                            </Typography>
                            {/* Display details relevant for admin review */}
                            <Grid container spacing={1} sx={{ fontSize: '0.9rem' }}>
                                <Grid item xs={6} sm={3}><strong>Term:</strong> {loan.termInMonths} Months</Grid>
                                <Grid item xs={6} sm={3}><strong>Income:</strong> {formatCurrency(loan.monthlyIncome)}</Grid>
                                <Grid item xs={12} sm={6}><strong>Employment:</strong> {loan.employmentStatus || 'N/A'}</Grid>
                                <Grid item xs={12} mt={1}>
                                    <strong>Purpose:</strong>
                                    <Typography variant="body2" sx={{ whiteSpace: 'pre-wrap', mt: 0.5 }}>{loan.purpose || 'N/A'}</Typography>
                                </Grid>
                            </Grid>
                        </Box>
                    </Collapse>
                </TableCell>
            </TableRow>
        </React.Fragment>
    );
}
// --- End PendingLoanRow Sub-component ---


// --- PendingLoansPage Main Component ---
export default function PendingLoansPage() {
    const navigate = useNavigate();
    const { authState } = useAuth();
    const [pendingLoans, setPendingLoans] = useState([]);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'info' });
    const [actionLoadingId, setActionLoadingId] = useState(null); // Tracks which loan action is processing

    // State for dialogs
    const [approveDialogOpen, setApproveDialogOpen] = useState(false);
    const [rejectDialogOpen, setRejectDialogOpen] = useState(false);
    const [currentLoan, setCurrentLoan] = useState(null); // Holds the loan object for the active dialog
    const [rejectionReason, setRejectionReason] = useState('');
    const [approvalDetails, setApprovalDetails] = useState({ approvedAmount: '', interestRate: '' });

    // Fetch pending loans
    const fetchPendingLoans = useCallback(async () => {
        if (!authState.isLoggedIn || authState.userRole !== 'ROLE_ADMIN') {
            setError("Access Denied: Admin privileges required.");
            setIsLoading(false); // Stop loading if not authorized
            return;
        }
        setIsLoading(true);
        setError('');
        try {
            // Call the backend endpoint for pending loans
            const response = await axios.get(`${API_BASE_URL}/admin/loan/pending`, { withCredentials: true });
            if (Array.isArray(response.data)) {
                setPendingLoans(response.data);
            } else {
                console.warn("Received non-array data for pending loans:", response.data);
                throw new Error("Received unexpected data format from server.");
            }
        } catch (err) {
            console.error("Error fetching pending Loans:", err);
            setError(err.response?.data?.message || err.message || 'Failed to load pending loan applications.');
            setPendingLoans([]);
        } finally {
            setIsLoading(false);
        }
    }, [authState.isLoggedIn, authState.userRole]); // Re-fetch if auth state changes

    // Fetch on mount
    useEffect(() => {
        fetchPendingLoans();
    }, [fetchPendingLoans]);

    // Snackbar handlers
    const handleSnackbarClose = (event, reason) => { if (reason === 'clickaway') return; setSnackbar({ ...snackbar, open: false }); };
    const showSnackbar = (message, severity = 'success') => { setSnackbar({ open: true, message, severity }); };

     // --- Dialog Open/Close ---
     const openApproveDialog = (loan) => {
         setCurrentLoan(loan);
         // Pre-fill amount, clear rate
         setApprovalDetails({ approvedAmount: loan.requestedAmount?.toString() || '', interestRate: '' });
         setApproveDialogOpen(true);
     };
     const closeApproveDialog = () => { setApproveDialogOpen(false); setCurrentLoan(null); setApprovalDetails({ approvedAmount: '', interestRate: '' }); };

     const openRejectDialog = (loan) => { setCurrentLoan(loan); setRejectionReason(''); setRejectDialogOpen(true); };
     const closeRejectDialog = () => { setRejectDialogOpen(false); setCurrentLoan(null); };

    // --- Action Handlers ---
    const handleApprove = async () => {
        // Validation inside dialog
        const amount = parseFloat(approvalDetails.approvedAmount);
        const rate = parseFloat(approvalDetails.interestRate);
        if (isNaN(amount) || amount <= 0) { showSnackbar('Approved amount must be a positive number.', 'warning'); return; }
        if (isNaN(rate) || rate <= 0.1) { showSnackbar('Interest rate must be positive (e.g., > 0.1%).', 'warning'); return; }

        setActionLoadingId(currentLoan.id); // Indicate loading for this specific loan
        setError('');
        try {
            const response = await axios.post(
                `${API_BASE_URL}/admin/loan/approve/${currentLoan.id}`,
                { approvedAmount: amount, interestRate: rate },
                { withCredentials: true }
            );
            showSnackbar(response.data?.message || `Loan ${currentLoan.id} approved successfully!`, 'success');
            closeApproveDialog();
            fetchPendingLoans(); // Refresh the list
        } catch (err) {
             console.error(`Error approving Loan ${currentLoan.id}:`, err);
             const errorMsg = err.response?.data?.message || `Failed to approve Loan ${currentLoan.id}.`;
             showSnackbar(errorMsg, 'error'); // Show error in snackbar
             // Consider if dialog should stay open on error
        } finally {
             setActionLoadingId(null); // Stop loading indicator for this loan
        }
    };

     const handleReject = async () => {
         if (!rejectionReason.trim()) { // Ensure reason is not just whitespace
             showSnackbar('Please provide a non-empty rejection reason.', 'warning');
             return;
         }
         setActionLoadingId(currentLoan.id);
         setError('');
         try {
            const response = await axios.post(
                `${API_BASE_URL}/admin/loan/reject/${currentLoan.id}`,
                { reason: rejectionReason },
                { withCredentials: true }
            );
            showSnackbar(response.data?.message || `Loan ${currentLoan.id} rejected successfully.`, 'success');
            closeRejectDialog();
            fetchPendingLoans(); // Refresh
        } catch (err) {
             console.error(`Error rejecting Loan ${currentLoan.id}:`, err);
             const errorMsg = err.response?.data?.message || `Failed to reject Loan ${currentLoan.id}.`;
             showSnackbar(errorMsg, 'error');
             setError(errorMsg); // Might show main error as well
        } finally {
             setActionLoadingId(null);
        }
     };

    // Render access denied if not admin
    if (!authState.isLoggedIn || authState.userRole !== 'ROLE_ADMIN') {
         return (
             <Container maxWidth="md" sx={{ mt: 4 }}>
                 <Alert severity="error">Access Denied. You do not have permission to view this page.</Alert>
             </Container>
         );
     }

    // Main Render
    return (
        <Container maxWidth="xl" sx={{ mt: 4, mb: 4 }}>
            <Paper elevation={2} sx={{ p: { xs: 2, md: 3 }, borderRadius: 2 }}>
                 {/* Header */}
                 <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3, borderBottom: 1, borderColor: 'divider', pb: 2 }}>
                     <Typography variant="h5" component="h1" sx={{ fontWeight: 'bold' }}>Pending Loan Applications</Typography>
                     <Box>
                         <Tooltip title="Refresh List">
                            <IconButton onClick={fetchPendingLoans} disabled={isLoading || !!actionLoadingId} color="primary" sx={{ mr: 1 }}>
                                <RefreshIcon />
                             </IconButton>
                         </Tooltip>
                         <Button variant="outlined" size="small" startIcon={<ArrowBackIcon />} onClick={() => navigate('/admin/dashboard')}>Admin Dashboard</Button>
                     </Box>
                 </Box>

                {/* Loading / Error / Snackbar */}
                {isLoading && <Box sx={{ display: 'flex', justifyContent: 'center', my: 5 }}><CircularProgress /></Box>}
                {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}
                <Snackbar open={snackbar.open} autoHideDuration={5000} onClose={handleSnackbarClose} anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}>
                     <Alert onClose={handleSnackbarClose} severity={snackbar.severity} sx={{ width: '100%' }} variant="filled">
                         {snackbar.message}
                     </Alert>
                 </Snackbar>

                {/* Table */}
                {!isLoading && !error && (
                    <TableContainer component={Paper} variant="outlined">
                        <Table stickyHeader aria-label="collapsible pending loan applications table">
                             <TableHead sx={{ backgroundColor: 'primary.lighter', '& th': { fontWeight: 'bold', color: 'primary.contrastText' } }}>
                                <TableRow>
                                     <TableCell /> {/* Collapse icon */}
                                    <TableCell>ID</TableCell>
                                    <TableCell>Customer ID</TableCell>
                                    <TableCell>Applied On</TableCell>
                                    <TableCell>Loan Type</TableCell>
                                    <TableCell align="right">Requested Amt</TableCell>
                                    <TableCell align="center">Actions</TableCell>
                                </TableRow>
                            </TableHead>
                            <TableBody>
                                {pendingLoans.length === 0 ? (
                                    <TableRow><TableCell colSpan={7} align="center" sx={{ py: 4, fontStyle: 'italic', color: 'text.secondary' }}>No pending loan applications found.</TableCell></TableRow>
                                ) : (
                                    pendingLoans.map((loan) => (
                                        <PendingLoanRow
                                            key={loan.id}
                                            loan={loan}
                                            onApproveClick={openApproveDialog}
                                            onRejectClick={openRejectDialog}
                                            actionLoadingId={actionLoadingId} // Pass loading ID
                                        />
                                    ))
                                )}
                            </TableBody>
                        </Table>
                    </TableContainer>
                )}
            </Paper>

            {/* Approval Dialog */}
             <Dialog open={approveDialogOpen} onClose={closeApproveDialog} maxWidth="xs" fullWidth>
                 <DialogTitle>Approve Loan (ID: {currentLoan?.id})</DialogTitle>
                 <DialogContent>
                     <DialogContentText sx={{mb: 1}}>Requested: {formatCurrency(currentLoan?.requestedAmount)}</DialogContentText>
                     <TextField
                         autoFocus
                         margin="dense"
                         id="approvedAmount"
                         name="approvedAmount"
                         label="Approved Amount (₹)"
                         type="number"
                         fullWidth
                         variant="outlined"
                         value={approvalDetails.approvedAmount}
                         onChange={(e) => setApprovalDetails({...approvalDetails, approvedAmount: e.target.value})}
                         required
                         sx={{ mb: 2 }}
                         inputProps={{ min: "1" }}
                     />
                     <TextField
                         margin="dense"
                         id="interestRate"
                         name="interestRate"
                         label="Annual Interest Rate (%)"
                         type="number"
                         fullWidth
                         variant="outlined"
                         value={approvalDetails.interestRate}
                         onChange={(e) => setApprovalDetails({...approvalDetails, interestRate: e.target.value})}
                         required
                         inputProps={{ step: "0.01", min: "0.1" }}
                     />
                 </DialogContent>
                 <DialogActions sx={{p: '16px 24px'}}>
                    <Button onClick={closeApproveDialog} disabled={actionLoadingId === currentLoan?.id}>Cancel</Button>
                     <Button
                        onClick={handleApprove}
                        color="success"
                        variant="contained"
                        disabled={actionLoadingId === currentLoan?.id || !approvalDetails.approvedAmount || !approvalDetails.interestRate || parseFloat(approvalDetails.approvedAmount) <= 0 || parseFloat(approvalDetails.interestRate) <= 0}
                      >
                         {actionLoadingId === currentLoan?.id ? <CircularProgress size={20} color="inherit"/> : 'Confirm Approval'}
                     </Button>
                 </DialogActions>
             </Dialog>

             {/* Rejection Dialog */}
              <Dialog open={rejectDialogOpen} onClose={closeRejectDialog} maxWidth="sm" fullWidth>
                 <DialogTitle>Reject Loan (ID: {currentLoan?.id})</DialogTitle>
                 <DialogContent>
                     <DialogContentText sx={{mb: 2}}>Please provide a reason for rejection.</DialogContentText>
                     <TextField
                         autoFocus
                         margin="dense"
                         id="rejectionReason"
                         label="Rejection Reason"
                         type="text"
                         fullWidth
                         multiline
                         rows={3}
                         variant="outlined"
                         value={rejectionReason}
                         onChange={(e) => setRejectionReason(e.target.value)}
                         required
                     />
                 </DialogContent>
                 <DialogActions sx={{p: '16px 24px'}}>
                     <Button onClick={closeRejectDialog} disabled={actionLoadingId === currentLoan?.id}>Cancel</Button>
                     <Button
                        onClick={handleReject}
                        color="error"
                        variant="contained"
                        disabled={actionLoadingId === currentLoan?.id || !rejectionReason.trim()}
                     >
                         {actionLoadingId === currentLoan?.id ? <CircularProgress size={20} color="inherit"/> : 'Confirm Rejection'}
                     </Button>
                 </DialogActions>
             </Dialog>

        </Container>
    );
}

--- component\Page\Employee\EmployeeCheckBalancePage.js ---
// --- src/component/Page/Employee/EmployeeCheckBalancePage.js ---
import React, { useState } from 'react';
import axios from 'axios';
import {
    Container, Paper, Typography, Box, TextField, Button, CircularProgress, Alert
} from '@mui/material';
import { useNavigate } from 'react-router-dom';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';

const API_BASE_URL = 'http://localhost:8080';

export default function EmployeeCheckBalancePage() {
    const navigate = useNavigate();
    const [targetCustomerId, setTargetCustomerId] = useState('');
    const [balanceInfo, setBalanceInfo] = useState(null); // Store balance info
    const [isLoading, setIsLoading] = useState(false);
    const [feedback, setFeedback] = useState({ type: '', message: '' });

    const handleSubmit = async (e) => {
        e.preventDefault();
        setIsLoading(true);
        setFeedback({ type: '', message: '' });
        setBalanceInfo(null); // Clear previous balance

        if (!targetCustomerId) {
            setFeedback({ type: 'error', message: 'Please enter a Customer ID or Account No.' });
            setIsLoading(false);
            return;
        }

        try {
            // Note the endpoint structure: /employee/check-balance/{targetCustomerId}
            const response = await axios.get(
                `${API_BASE_URL}/employee/check-balance/${targetCustomerId}`,
                { withCredentials: true }
            );

            if (response.data?.success) {
                 setBalanceInfo({
                    customerId: targetCustomerId, // Keep track of who was checked
                    balance: response.data.balance
                 });
                 setFeedback({ type: 'success', message: 'Balance retrieved successfully.' });
            } else {
                // Handle case where success might be false but data exists
                throw new Error(response.data?.message || 'Failed to retrieve balance.');
            }
        } catch (err) {
            console.error("Check balance error:", err);
             // Backend might return 404 directly or error in body
             if (err.response && err.response.status === 404) {
                 setFeedback({ type: 'error', message: err.response.data?.message || `Customer '${targetCustomerId}' not found.` });
             } else {
                setFeedback({ type: 'error', message: err.response?.data?.message || err.message || 'An error occurred checking balance.' });
             }
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Container maxWidth="sm" sx={{ mt: 4, mb: 4 }}>
            <Paper elevation={3} sx={{ p: 4 }}>
                 <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                    <Typography variant="h5" component="h1" gutterBottom>
                         Check Customer Balance
                    </Typography>
                     <Button
                         variant="outlined"
                         size="small"
                         startIcon={<ArrowBackIcon />}
                         onClick={() => navigate('/employee/dashboard')}
                     >
                         Dashboard
                     </Button>
                 </Box>

                 {/* Separate feedback and result display */}
                 {feedback.message && feedback.type !== 'success' && ( // Show only non-success feedback here
                     <Alert severity={feedback.type || 'info'} sx={{ mb: 2 }}>
                         {feedback.message}
                     </Alert>
                 )}

                <Box component="form" onSubmit={handleSubmit} noValidate>
                    <TextField
                        margin="normal"
                        required
                        fullWidth
                        id="targetCustomerId"
                        label="Target Customer ID or Account No"
                        name="targetCustomerId"
                        value={targetCustomerId}
                        onChange={(e) => setTargetCustomerId(e.target.value)}
                        disabled={isLoading}
                        autoFocus
                    />
                    <Button
                        type="submit"
                        fullWidth
                        variant="contained"
                        color="success" // Different color
                        sx={{ mt: 2, mb: 2 }} // Adjusted margin
                        disabled={isLoading}
                    >
                        {isLoading ? <CircularProgress size={24} /> : 'Check Balance'}
                    </Button>
                </Box>

                {/* Display Balance Result */}
                {balanceInfo && (
                     <Alert severity="success" sx={{ mt: 2 }}>
                        Balance for Customer '{balanceInfo.customerId}':
                         <Typography variant="h6" component="span" sx={{ fontWeight: 'bold', ml: 1 }}>
                            ₹{parseFloat(balanceInfo.balance).toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                        </Typography>
                     </Alert>
                )}
            </Paper>
        </Container>
    );
}

--- component\Page\Employee\EmployeeDashboardPage.js ---
// --- src/component/Page/Employee/EmployeeDashboardPage.js ---
import React from 'react';
import { Container, Typography, Paper, Grid, Card, CardContent, CardActions, Button, Box } from '@mui/material';
import { Link as RouterLink } from 'react-router-dom';
import { useAuth } from '../../../context/AuthContext'; // Path may differ: '../../context/AuthContext'

// Import relevant icons
import AccountBalanceIcon from '@mui/icons-material/AccountBalance'; // Check Balance
import AddCardIcon from '@mui/icons-material/AddCard'; // Deposit
import PaymentsIcon from '@mui/icons-material/Payments'; // Withdrawal
import HistoryIcon from '@mui/icons-material/History'; // Get History

export default function EmployeeDashboardPage() {
    const { authState } = useAuth(); // Get auth state to display welcome message

    // Placeholder content - Replace with actual links and functionality
    // when corresponding pages and backend endpoints are ready.
    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            {/* Dashboard Header */}
            <Paper elevation={3} sx={{
                 p: { xs: 2, md: 3 },
                 mb: 4,
                 textAlign: 'center',
                 background: 'linear-gradient(45deg, #4caf50 30%, #81c784 90%)', // Example Green Gradient
                 color: 'white'
            }}>
                <Typography variant="h4" component="h1" gutterBottom sx={{ fontWeight: 'bold' }}>
                    Employee Portal
                </Typography>
                {/* Display logged-in employee/admin ID */}
                <Typography variant="body1" sx={{ color: 'rgba(255, 255, 255, 0.9)' }}>
                    Welcome, {authState.customerId}! Access customer service tools below.
                </Typography>
            </Paper>

            {/* Action Cards Grid */}
             <Grid container spacing={4} justifyContent="center" alignItems="stretch">

                {/* Card: Deposit */}
                 <Grid item xs={12} sm={6} md={4} lg={3}>
                     <Card sx={{ display: 'flex', flexDirection: 'column', height: '100%', '&:hover': { boxShadow: 6 }, transition: 'box-shadow 0.3s' }}>
                        <CardContent sx={{ flexGrow: 1, textAlign: 'center', p: 3 }}>
                           <AddCardIcon fontSize="large" color="primary" sx={{ mb: 1 }} />
                           <Typography variant="h6" gutterBottom>Deposit Funds</Typography>
                           <Typography variant="caption" color="text.secondary">Make a deposit into a customer's account.</Typography>
                        </CardContent>
                        <CardActions sx={{ justifyContent: 'center', pb: 2 }}>
                            {/* Link to the actual Employee Deposit page */}
                             <Button component={RouterLink} to="/employee/deposit" variant="contained" size="small">Go to Deposit</Button>
                         </CardActions>
                     </Card>
                 </Grid>

                 {/* Card: Withdrawal */}
                 <Grid item xs={12} sm={6} md={4} lg={3}>
                     <Card sx={{ display: 'flex', flexDirection: 'column', height: '100%', '&:hover': { boxShadow: 6 }, transition: 'box-shadow 0.3s' }}>
                         <CardContent sx={{ flexGrow: 1, textAlign: 'center', p: 3 }}>
                           <PaymentsIcon fontSize="large" color="secondary" sx={{ mb: 1 }}/>
                           <Typography variant="h6" gutterBottom>Withdraw Funds</Typography>
                            <Typography variant="caption" color="text.secondary">Process a withdrawal from a customer's account.</Typography>
                        </CardContent>
                         <CardActions sx={{ justifyContent: 'center', pb: 2 }}>
                             {/* Link to the actual Employee Withdrawal page */}
                              <Button component={RouterLink} to="/employee/withdraw" variant="contained" color="secondary" size="small">Go to Withdrawal</Button>
                         </CardActions>
                     </Card>
                 </Grid>

                 {/* Card: Check Balance */}
                  <Grid item xs={12} sm={6} md={4} lg={3}>
                     <Card sx={{ display: 'flex', flexDirection: 'column', height: '100%', '&:hover': { boxShadow: 6 }, transition: 'box-shadow 0.3s' }}>
                         <CardContent sx={{ flexGrow: 1, textAlign: 'center', p: 3 }}>
                           <AccountBalanceIcon fontSize="large" sx={{ color: 'success.main', mb: 1 }} />
                           <Typography variant="h6" gutterBottom>Check Balance</Typography>
                            <Typography variant="caption" color="text.secondary">View the current balance of a customer's account.</Typography>
                        </CardContent>
                         <CardActions sx={{ justifyContent: 'center', pb: 2 }}>
                            {/* Link to the actual Employee Check Balance page */}
                              <Button component={RouterLink} to="/employee/check-balance" variant="contained" color="success" size="small">Check Balance</Button>
                         </CardActions>
                     </Card>
                 </Grid>

                 {/* Card: Get History */}
                  <Grid item xs={12} sm={6} md={4} lg={3}>
                     <Card sx={{ display: 'flex', flexDirection: 'column', height: '100%', '&:hover': { boxShadow: 6 }, transition: 'box-shadow 0.3s' }}>
                         <CardContent sx={{ flexGrow: 1, textAlign: 'center', p: 3 }}>
                           <HistoryIcon fontSize="large" color="warning" sx={{ mb: 1 }}/>
                            <Typography variant="h6" gutterBottom>Transaction History</Typography>
                            <Typography variant="caption" color="text.secondary">Download a statement of a customer's transactions.</Typography>
                        </CardContent>
                         <CardActions sx={{ justifyContent: 'center', pb: 2 }}>
                             {/* Link to the actual Employee Download History page */}
                              <Button component={RouterLink} to="/employee/download-history" variant="contained" color="warning" size="small">Get History</Button>
                         </CardActions>
                     </Card>
                 </Grid>

                 {/* Example Card: Customer Search (Add when implementing) */}
                 {/*
                 <Grid item xs={12} sm={6} md={4} lg={3}>
                     <Card sx={{ display: 'flex', flexDirection: 'column', height: '100%', '&:hover': { boxShadow: 6 }, transition: 'box-shadow 0.3s' }}>
                         <CardContent sx={{ flexGrow: 1, textAlign: 'center', p: 3 }}>
                           <SearchIcon fontSize="large" color="info" sx={{ mb: 1 }} />
                            <Typography variant="h6" gutterBottom>Find Customer</Typography>
                            <Typography variant="caption" color="text.secondary">Search for customer accounts by ID, name, or number.</Typography>
                        </CardContent>
                         <CardActions sx={{ justifyContent: 'center', pb: 2 }}>
                              <Button component={RouterLink} to="/employee/customer-search" variant="contained" color="info" size="small">Search</Button>
                         </CardActions>
                     </Card>
                 </Grid>
                 */}

            </Grid>
        </Container>
    );
}

--- component\Page\Employee\EmployeeDepositPage.js ---
// --- src/component/Page/Employee/EmployeeDepositPage.js ---
import React, { useState } from 'react';
import axios from 'axios';
import {
    Container, Paper, Typography, Box, TextField, Button, CircularProgress, Alert
} from '@mui/material';
import { useNavigate } from 'react-router-dom';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';

const API_BASE_URL = 'http://localhost:8080';

export default function EmployeeDepositPage() {
    const navigate = useNavigate();
    const [targetCustomerId, setTargetCustomerId] = useState('');
    const [amount, setAmount] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [feedback, setFeedback] = useState({ type: '', message: '' });

    const handleSubmit = async (e) => {
        e.preventDefault();
        setIsLoading(true);
        setFeedback({ type: '', message: '' });

        if (!targetCustomerId || !amount || parseFloat(amount) <= 0) {
            setFeedback({ type: 'error', message: 'Please enter a valid Customer ID and a positive amount.' });
            setIsLoading(false);
            return;
        }

        try {
            const response = await axios.post(
                `${API_BASE_URL}/employee/deposit`,
                { targetCustomerId, amount: parseFloat(amount) },
                { withCredentials: true } // Send authentication cookies/headers
            );

            if (response.data?.success) {
                setFeedback({ type: 'success', message: response.data.message || 'Deposit successful!' });
                setTargetCustomerId(''); // Clear form on success
                setAmount('');
            } else {
                throw new Error(response.data?.message || 'Deposit failed.');
            }
        } catch (err) {
            console.error("Deposit error:", err);
            setFeedback({ type: 'error', message: err.response?.data?.message || err.message || 'An error occurred during deposit.' });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Container maxWidth="sm" sx={{ mt: 4, mb: 4 }}>
            <Paper elevation={3} sx={{ p: 4 }}>
                 <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                      <Typography variant="h5" component="h1" gutterBottom>
                         Deposit Funds for Customer
                     </Typography>
                      <Button
                         variant="outlined"
                         size="small"
                         startIcon={<ArrowBackIcon />}
                         onClick={() => navigate('/employee/dashboard')}
                     >
                         Dashboard
                     </Button>
                </Box>


                {feedback.message && (
                    <Alert severity={feedback.type || 'info'} sx={{ mb: 2 }}>
                        {feedback.message}
                    </Alert>
                )}

                <Box component="form" onSubmit={handleSubmit} noValidate>
                    <TextField
                        margin="normal"
                        required
                        fullWidth
                        id="targetCustomerId"
                        label="Target Customer ID or Account No"
                        name="targetCustomerId"
                        value={targetCustomerId}
                        onChange={(e) => setTargetCustomerId(e.target.value)}
                        disabled={isLoading}
                        autoFocus
                    />
                    <TextField
                        margin="normal"
                        required
                        fullWidth
                        id="amount"
                        label="Amount to Deposit (₹)"
                        name="amount"
                        type="number"
                        value={amount}
                        onChange={(e) => setAmount(e.target.value)}
                        disabled={isLoading}
                        inputProps={{ step: "0.01", min: "0.01" }} // Allow decimals, enforce positive
                    />
                    <Button
                        type="submit"
                        fullWidth
                        variant="contained"
                        sx={{ mt: 3, mb: 2 }}
                        disabled={isLoading}
                    >
                        {isLoading ? <CircularProgress size={24} /> : 'Perform Deposit'}
                    </Button>
                </Box>
            </Paper>
        </Container>
    );
}

--- component\Page\Employee\EmployeeWithdrawalPage.js ---
// --- src/component/Page/Employee/EmployeeWithdrawalPage.js ---
import React, { useState } from 'react';
import axios from 'axios';
import {
    Container, Paper, Typography, Box, TextField, Button, CircularProgress, Alert
} from '@mui/material';
import { useNavigate } from 'react-router-dom';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';


const API_BASE_URL = 'http://localhost:8080';

export default function EmployeeWithdrawalPage() {
    const navigate = useNavigate();
    const [targetCustomerId, setTargetCustomerId] = useState('');
    const [amount, setAmount] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [feedback, setFeedback] = useState({ type: '', message: '' });

    const handleSubmit = async (e) => {
        e.preventDefault();
        setIsLoading(true);
        setFeedback({ type: '', message: '' });

        if (!targetCustomerId || !amount || parseFloat(amount) <= 0) {
            setFeedback({ type: 'error', message: 'Please enter a valid Customer ID and a positive amount.' });
            setIsLoading(false);
            return;
        }

        try {
            const response = await axios.post(
                `${API_BASE_URL}/employee/withdraw`, // Correct endpoint
                { targetCustomerId, amount: parseFloat(amount) },
                { withCredentials: true }
            );

            if (response.data?.success) {
                setFeedback({ type: 'success', message: response.data.message || 'Withdrawal successful!' });
                setTargetCustomerId('');
                setAmount('');
            } else {
                throw new Error(response.data?.message || 'Withdrawal failed.');
            }
        } catch (err) {
            console.error("Withdrawal error:", err);
            setFeedback({ type: 'error', message: err.response?.data?.message || err.message || 'An error occurred during withdrawal.' });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Container maxWidth="sm" sx={{ mt: 4, mb: 4 }}>
            <Paper elevation={3} sx={{ p: 4 }}>
                 <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                      <Typography variant="h5" component="h1" gutterBottom>
                         Withdraw Funds for Customer
                     </Typography>
                     <Button
                         variant="outlined"
                         size="small"
                         startIcon={<ArrowBackIcon />}
                         onClick={() => navigate('/employee/dashboard')}
                     >
                         Dashboard
                     </Button>
                 </Box>

                {feedback.message && (
                    <Alert severity={feedback.type || 'info'} sx={{ mb: 2 }}>
                        {feedback.message}
                    </Alert>
                )}

                <Box component="form" onSubmit={handleSubmit} noValidate>
                    <TextField
                        margin="normal"
                        required
                        fullWidth
                        id="targetCustomerId"
                        label="Target Customer ID or Account No"
                        name="targetCustomerId"
                        value={targetCustomerId}
                        onChange={(e) => setTargetCustomerId(e.target.value)}
                        disabled={isLoading}
                        autoFocus
                    />
                    <TextField
                        margin="normal"
                        required
                        fullWidth
                        id="amount"
                        label="Amount to Withdraw (₹)"
                        name="amount"
                        type="number"
                        value={amount}
                        onChange={(e) => setAmount(e.target.value)}
                        disabled={isLoading}
                        inputProps={{ step: "0.01", min: "0.01" }}
                    />
                    <Button
                        type="submit"
                        fullWidth
                        variant="contained"
                        color="secondary" // Different color for withdrawal
                        sx={{ mt: 3, mb: 2 }}
                        disabled={isLoading}
                    >
                        {isLoading ? <CircularProgress size={24} /> : 'Perform Withdrawal'}
                    </Button>
                </Box>
            </Paper>
        </Container>
    );
}

--- component\pages\FeaturesSection.css ---
/* Features Section */
.features-section {
  padding: 50px 20px;
  background-color: #f5f5f5;
  text-align: center;
}

.section-title h2 {
  font-size: 3rem;
  color: #333;
  font-weight: bold;
  text-transform: uppercase;
  letter-spacing: 2px;
  position: relative;
  display: inline-block;
  animation: floatEffect 2s ease-in-out infinite;
}

.three-d-effect {
  text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.3), -2px -2px 10px rgba(255, 255, 255, 0.6);
}

/* Adding a floating effect to the section title */
@keyframes floatEffect {
  0% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-10px);
  }
  100% {
    transform: translateY(0);
  }
}

/* Slider Container */
.slider-container {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 30px;
}

/* Feature Card Style */
.feature-card {
  background-color: #ffffff;
  border-radius: 10px;
  padding: 20px;
  width: 80%;
  max-width: 400px;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
  box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
  transform: perspective(500px) rotateY(0deg);
  animation: cardEffect 1.5s ease-in-out infinite;
}

.feature-card:hover {
  transform: translateY(-10px) rotateY(15deg);
  box-shadow: 0 12px 20px rgba(0, 0, 0, 0.2);
}

/* Adding a 3D effect */
@keyframes cardEffect {
  0% {
    transform: perspective(500px) rotateY(0deg);
  }
  50% {
    transform: perspective(500px) rotateY(10deg);
  }
  100% {
    transform: perspective(500px) rotateY(0deg);
  }
}

.feature-card h3 {
  font-size: 1.8rem;
  color: #007BFF;
  margin-bottom: 15px;
}

.feature-card p {
  font-size: 1.2rem;
  color: #555;
  line-height: 1.5;
}

/* Footer Section */
.footer-section {
  background-color: #333;
  color: #fff;
  padding: 40px 20px;
}

.footer-container {
  display: flex;
  justify-content: space-between;
  flex-wrap: wrap;
}

.footer-column {
  width: 48%;
  margin-bottom: 20px;
}

.footer-column h4 {
  font-size: 1.5rem;
  margin-bottom: 10px;
}

.footer-column p {
  font-size: 1rem;
  line-height: 1.6;
}

@media screen and (max-width: 768px) {
  .footer-container {
    flex-direction: column;
    align-items: center;
  }

  .footer-column {
    width: 100%;
    text-align: center;
  }
}


--- component\pages\Home.js ---
import React from 'react'
import { Divider, Toolbar, Typography, Box, Grid, Paper, Link } from '@mui/material'
import { styled } from '@mui/system'

// Feature Box Styling
const FeatureBox = styled(Paper)(({ theme }) => ({
  borderRadius: '10px',
  boxShadow: '0 8px 16px rgba(0, 0, 0, 0.2)',
  padding: theme.spacing(4),
  textAlign: 'center',
  backgroundColor: 'rgba(255, 255, 255, 0.7)', // Transparent background
  transition: 'transform 0.3s ease, box-shadow 0.3s ease',
  '&:hover': {
    transform: 'translateY(-10px)',
    boxShadow: '0 12px 24px rgba(0, 0, 0, 0.3)',
  },
}))

// Footer Section Styling
const Footer = styled(Box)(({ theme }) => ({
  backgroundColor: '#121212', // Deep black background for footer
  color: 'white',
  padding: theme.spacing(4, 2), // Added horizontal padding
  marginTop: theme.spacing(6),
  borderRadius: '10px',
  boxShadow: '0 8px 16px rgba(0, 0, 0, 0.3)',
  textAlign: 'center',
  fontFamily: '"Roboto", sans-serif',
  display: 'flex',
  justifyContent: 'center', // Centers content horizontally
  flexDirection: 'row', // Layout for equal split of columns
  alignItems: 'flex-start',
}))

// Footer Column Styling
const FooterColumn = styled(Grid)(({ theme }) => ({
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'flex-start',
  justifyContent: 'center',
  textAlign: 'left',
  flex: 1, // Ensures both columns have equal width
  paddingLeft: theme.spacing(3),
  paddingRight: theme.spacing(3),
}))

// Link Styling in Footer for interaction
const FooterLink = styled(Link)(({ theme }) => ({
  color: 'white',
  textDecoration: 'none',
  '&:hover': {
    color: '#f4a261', // Light color on hover
    textDecoration: 'underline',
  },
}))

export default function Home() {
  return (
    <>
      {/* Toolbar */}
      <Box 
        sx={{
          display: 'flex', 
          justifyContent: 'center', 
          alignItems: 'center', 
          height: 'auto', // Full viewport height
          textAlign: 'center', // Center the text
          backgroundColor: '#f4f4f4', // Optional background color
          paddingTop: 2,
        }}
      >
        <Typography 
          variant='h4' 
          sx={{
            fontWeight: 'bold',
            color: '#000',
            textTransform: 'uppercase',
            letterSpacing: 2,
          }}
        >
          Features of MEEWOO BANK
        </Typography>
      </Box>
      <Divider />

      {/* Centered Container for Features */}
      <Box 
        sx={{
          padding: 4, 
          display: 'flex', 
          justifyContent: 'center',
          marginTop: 4, 
          boxShadow: '0 8px 16px rgba(0, 0, 0, 0.3)', 
          borderRadius: '10px', 
          backgroundColor: '#fff',
        }}
      >
        <Grid container spacing={3} justifyContent="center">
          <Grid item xs={12} sm={4}>
            <FeatureBox>
              <Typography variant="h6">Easy Transactions</Typography>
              <Typography variant="body2">Make seamless transfers and manage your bank accounts with ease.</Typography>
            </FeatureBox>
          </Grid>
          <Grid item xs={12} sm={4}>
            <FeatureBox>
              <Typography variant="h6">24/7 Support</Typography>
              <Typography variant="body2">Our customer support team is available around the clock to assist you.</Typography>
            </FeatureBox>
          </Grid>
          <Grid item xs={12} sm={4}>
            <FeatureBox>
              <Typography variant="h6">Secure Banking</Typography>
              <Typography variant="body2">Your account security is our priority, with top-notch encryption.</Typography>
            </FeatureBox>
          </Grid>
        </Grid>
      </Box>

      {/* Footer Section */}
      <Footer>
        <Grid container spacing={4} justifyContent="center">
          {/* About Section */}
          <FooterColumn item xs={12} sm={6}>
            <Typography variant="h6" style={{ fontWeight: 'bold', marginBottom: 16 }}>
              About
            </Typography>
            <Typography variant="body2" style={{ marginBottom: 8 }}>
              We are a customer-centric bank focused on providing innovative financial solutions. 
              Our mission is to deliver exceptional service and help our customers reach their financial goals.
            </Typography>
            <FooterLink href="https://www.mybank.com/about">Learn More</FooterLink>
          </FooterColumn>

          {/* Contact Section */}
          <FooterColumn item xs={12} sm={6}>
            <Typography variant="h6" style={{ fontWeight: 'bold', marginBottom: 16 }}>
              Contact
            </Typography>
            <Typography variant="body2" style={{ marginBottom: 8 }}>
              <strong>Email:</strong> <FooterLink href="mailto:support@mybank.com">support@mybank.com</FooterLink>
            </Typography>
            <Typography variant="body2" style={{ marginBottom: 8 }}>
              <strong>Phone:</strong> <FooterLink href="tel:+123456789">+123 456 789</FooterLink>
            </Typography>
          </FooterColumn>
        </Grid>
      </Footer>

      {/* Divider and All Rights Reserved */}
      <Divider sx={{ margin: '20px 0', backgroundColor: '#000' }} /> {/* Darker divider */}
      <Box sx={{ textAlign: 'center',fontWeight:'bold', color: 'black', paddingBottom: 2 }}>
        <Typography variant="body2" sx={{ fontSize: '0.875rem' }}>
          &copy; 2025 My Bank. All Rights Reserved.
        </Typography>
      </Box>
    </>
  )
}


--- component\pages\NotFoundPage.js ---
import React from 'react';
import { Container, Typography, Paper, Button } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import ErrorOutlineIcon from '@mui/icons-material/ErrorOutline'; // Import an icon

const NotFoundPage = () => {
    const navigate = useNavigate();

    return (
        <Container component="main" maxWidth="sm" sx={{ mt: 8, mb: 4 }}>
            <Paper elevation={3} sx={{ p: 4, display: 'flex', flexDirection: 'column', alignItems: 'center', textAlign: 'center' }}>
                <ErrorOutlineIcon color="warning" sx={{ fontSize: 60, mb: 2 }} />
                <Typography component="h1" variant="h4" gutterBottom>
                    404 - Page Not Found
                </Typography>
                <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
                    Oops! The page you are looking for does not exist or may have been moved.
                </Typography>
                <Button variant="contained" onClick={() => navigate('/')}>
                    Go to Home
                </Button>
            </Paper>
        </Container>
    );
};

export default NotFoundPage;

--- component\pages\UnauthorizedPage.js ---
import React from 'react';
import { Container, Typography, Paper, Button } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import BlockIcon from '@mui/icons-material/Block'; // Import an icon

const UnauthorizedPage = () => {
    const navigate = useNavigate();

    return (
        <Container component="main" maxWidth="sm" sx={{ mt: 8, mb: 4 }}>
            <Paper elevation={3} sx={{ p: 4, display: 'flex', flexDirection: 'column', alignItems: 'center', textAlign: 'center' }}>
                <BlockIcon color="error" sx={{ fontSize: 60, mb: 2 }} />
                <Typography component="h1" variant="h4" gutterBottom color="error">
                    403 - Access Denied
                </Typography>
                <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
                    Sorry, you do not have the necessary permissions to view this page.
                </Typography>
                <Button variant="contained" onClick={() => navigate('/')}>
                    Go to Home
                </Button>
            </Paper>
        </Container>
    );
};

export default UnauthorizedPage;

--- context\AuthContext.js ---
// --- src/context/AuthContext.js ---
import React, { createContext, useState, useContext, useEffect } from 'react';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
    const [authState, setAuthState] = useState({
        isLoggedIn: !!localStorage.getItem('isLoggedIn'),
        userRole: localStorage.getItem('userRole') || null,
        customerId: localStorage.getItem('customerId') || null,
    });

    const login = (role, customerId) => {
        localStorage.setItem('isLoggedIn', 'true');
        localStorage.setItem('userRole', role);
        localStorage.setItem('customerId', customerId);

        setAuthState({
            isLoggedIn: true,
            userRole: role,
            customerId: customerId,
        });
    };

    const logout = () => {
        localStorage.removeItem('isLoggedIn');
        localStorage.removeItem('userRole');
        localStorage.removeItem('customerId');

        setAuthState({
            isLoggedIn: false,
            userRole: null,
            customerId: null,
        });
    };

    useEffect(() => {
        const handleStorageChange = () => {
            setAuthState({
                isLoggedIn: !!localStorage.getItem('isLoggedIn'),
                userRole: localStorage.getItem('userRole') || null,
                customerId: localStorage.getItem('customerId') || null,
            });
        };
        window.addEventListener('storage', handleStorageChange);
        return () => {
            window.removeEventListener('storage', handleStorageChange);
        };
    }, []);

    return (
        <AuthContext.Provider value={{ authState, login, logout }}>
            {children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    return useContext(AuthContext);
};


--- styles\global.css ---
/* src/styles/global.css */

/* Import Google Font (Roboto is standard for MUI) */
@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap');

body {
  margin: 0;
  padding: 0;
  font-family: 'Roboto', sans-serif;
  /* background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab); */
  /* More subtle gradient */
   background: linear-gradient(backgroundColor'#ffffff');
  background-size: 400% 400%;
  animation: gradientShift 18s ease infinite;
  color: #333;
  /* Ensure content scrolls correctly */
  height: 100%;
  overflow-x: hidden; /* Prevent horizontal scroll */
}

@keyframes gradientShift {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

/* Basic reset */
*, *::before, *::after {
  box-sizing: border-box;
}

/* Ensure the root element takes full height */
#root {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* Style the main application container (adjust if your App structure differs) */
/* This selector might need adjustment based on how App.js renders */
/* With CRA, #root directly contains the App component usually */
/* #root > div { ... } might not be needed or should target differently */
/* We'll rely on the structure in App.js using Box for layout */


/* Link styling */
a {
  text-decoration: none;
  color: inherit; /* Inherit color from parent */
}

/* Add any other global base styles here */

--- styles\theme.js ---
// src/styles/theme.js
import { createTheme } from '@mui/material/styles';
import { deepPurple, amber } from '@mui/material/colors'; // Example colors

const theme = createTheme({
  palette: {
    mode: 'light', // Start with light mode, can be toggled later
    primary: {
      main: deepPurple[500], // Example primary color
      contrastText: '#ffffff',
    },
    secondary: {
      main: amber[700], // Example secondary color
      contrastText: '#000000',
    },
   // In theme.js
background: {
  default: '#ffffff', // Solid white
  paper: '#ffffff',   // Solid white
},
    // Add other color customizations if needed
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h1: { fontWeight: 700 },
    h2: { fontWeight: 700 },
    h3: { fontWeight: 600 },
    h4: { fontWeight: 600 },
    // Add other typography customizations
  },
  spacing: 8, // Default spacing unit (factor)
  shape: {
    borderRadius: 8, // Slightly rounded corners for components
  },
  breakpoints: {
    values: {
      xs: 0,
      sm: 600,
      md: 960,
      lg: 1280,
      xl: 1536, // MUI v5 default xl breakpoint
    },
  },
  components: {
    // Example: Global style overrides for specific components
    MuiAppBar: {
      styleOverrides: {
        root: {
          // Semi-transparent AppBar
          backgroundColor: 'rgba(81, 45, 168, 0.8)', // Adjust primary color with alpha
          backdropFilter: 'blur(5px)', // Optional blur effect
          boxShadow: 'none', // Cleaner look, adjust as needed
        }
      }
    },
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none', // Keep button text case as defined
          fontWeight: 600,
        },
      },
      defaultProps: {
         disableElevation: true, // Flat buttons by default
      }
    },
    MuiCard: {
      styleOverrides: {
        root: {
          // Slightly transparent cards
          backgroundColor: 'rgba(255, 255, 255, 0.9)',
          backdropFilter: 'blur(3px)', // Optional subtle blur
        },
      },
    },
    MuiPaper: {
       styleOverrides: {
        root: {
           // Already defined in palette.background.paper, ensure consistency
           backgroundColor: 'rgba(255, 255, 255, 0.95)',
        }
       }
    }
    // Add more component overrides as needed
  },
});

export default theme;

--- utils\formatters.js ---
// --- src/utils/formatters.js ---
import React from 'react';
import Chip from '@mui/material/Chip';

/**
 * Formats a date string (or Date object) into a more readable date format.
 * Example: "Jan 1, 2023"
 * @param {string | Date} dateString - The date string or Date object to format.
 * @returns {string} Formatted date string or 'N/A' if invalid.
 */
export const formatDate = (dateString) => {
    if (!dateString) return 'N/A';
    try {
        const date = new Date(dateString);
        // Check if the date is valid after parsing
        if (isNaN(date.getTime())) {
            throw new Error('Invalid date value');
        }
        return date.toLocaleDateString('en-IN', { // Use Indian English locale for DD/MM/YYYY or similar
            year: 'numeric',
            month: 'short', // 'Jan', 'Feb', etc.
            day: 'numeric'
        });
    } catch (e) {
        console.error("Error formatting date:", dateString, e);
        return 'Invalid Date';
    }
};

/**
 * Formats a date-time string (or Date object) into a more readable date and time format.
 * Example: "Jan 1, 2023, 10:30 AM"
 * @param {string | Date} dateTimeString - The date-time string or Date object to format.
 * @returns {string} Formatted date-time string or 'N/A' if invalid.
 */
export const formatDateTime = (dateTimeString) => {
    if (!dateTimeString) return 'N/A';
    try {
        const date = new Date(dateTimeString);
        if (isNaN(date.getTime())) {
            throw new Error('Invalid date-time value');
        }
        return date.toLocaleString('en-IN', { // Indian English locale
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            hour12: true // Use AM/PM
        });
    } catch (e) {
        console.error("Error formatting datetime:", dateTimeString, e);
        return 'Invalid DateTime';
    }
};

/**
 * Formats a number into a currency string (Indian Rupees).
 * Example: ₹ 1,000.00
 * @param {number | string} amount - The amount to format.
 * @returns {string} Formatted currency string or 'N/A' if invalid.
 */
export const formatCurrency = (amount) => {
    const numAmount = Number(amount);
    if (amount === null || amount === undefined || isNaN(numAmount)) return 'N/A';
    try {
        return `₹ ${numAmount.toLocaleString('en-IN', {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        })}`;
    } catch (e) {
        console.error("Error formatting currency:", amount, e);
        return 'Invalid Amount';
    }
};

/**
 * Generates an MUI Chip component styled based on Fixed Deposit status.
 * @param {string} status - The status string (e.g., "PENDING", "ACTIVE").
 * @returns {JSX.Element} An MUI Chip component.
 */
export const getFdStatusChip = (status) => {
    let color = 'default';
    let label = status ? status.toUpperCase() : 'UNKNOWN'; // Ensure consistent casing for matching

    switch (label) {
        case 'PENDING': color = 'warning'; break;
        case 'ACTIVE': color = 'success'; break;
        case 'REJECTED': color = 'error'; break;
        case 'MATURED': color = 'info'; break;
        case 'CLOSED': color = 'default'; break; // You can use 'secondary' or 'grey' from MUI theme
        default: color = 'default';
    }
    return <Chip label={label} color={color} size="small" variant="outlined" sx={{ textTransform: 'capitalize', fontWeight: 500 }} />;
};

/**
 * Generates an MUI Chip component styled based on Loan Application status.
 * @param {string} status - The status string (e.g., "PENDING", "APPROVED").
 * @returns {JSX.Element} An MUI Chip component.
 */
export const getLoanStatusChip = (status) => {
    let color = 'default';
    let label = status ? status.toUpperCase().replace('_', ' ') : 'UNKNOWN'; // Handle potential underscores

    switch (status ? status.toUpperCase() : '') { // Match against uppercase status
        case 'PENDING': color = 'warning'; break;
        case 'UNDER_REVIEW': color = 'info'; break;
        case 'APPROVED': color = 'success'; break;
        case 'REJECTED': color = 'error'; break;
        case 'DISBURSED': color = 'primary'; break; // Or another distinct color
        case 'CLOSED': color = 'default'; break; // Or 'secondary'
        default: color = 'default';
    }
    return <Chip label={label} color={color} size="small" variant="outlined" sx={{ textTransform: 'capitalize', fontWeight: 500 }} />;
};
=======
--- main\java\com\Banking_Somnath\banking_systemn\BankingSystemnApplication.java ---
package com.Banking_Somnath.banking_systemn;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BankingSystemnApplication {

	public static void main(String[] args) {
		SpringApplication.run(BankingSystemnApplication.class, args);
	}

}


--- main\java\com\Banking_Somnath\banking_systemn\config\AdminInitializer.java ---
// --- main\java\com\Banking_Somnath\banking_systemn\config\AdminInitializer.java ---
package com.Banking_Somnath.banking_systemn.config; // Ensure package is correct


import com.Banking_Somnath.banking_systemn.model.Customer; // Ensure this import is correct
import com.Banking_Somnath.banking_systemn.repository.CustomerRepository; // Ensure this import is correct
import org.springframework.boot.CommandLineRunner; // Ensure this import is correct
import org.springframework.context.annotation.Bean; // Ensure this import is correct
import org.springframework.context.annotation.Configuration; // Ensure this import is correct
import org.springframework.security.crypto.password.PasswordEncoder; // Ensure this import is correct

@Configuration // Marks this class as a Spring configuration source
public class AdminInitializer {

    // Define a CommandLineRunner bean that will execute after the application context loads
    @Bean
    public CommandLineRunner createAdmin(CustomerRepository customerRepository, PasswordEncoder encoder) {
        return args -> {
            if (customerRepository.findByEmail("admin@example.com").isEmpty()) {
                System.out.println("Creating initial admin user..."); // Log before creation

                // Create a new Customer object for the admin
                Customer admin = new Customer();

                // Set essential details for the admin user
                // Ensure these are unique in your database if running multiple times or with existing data
                admin.setCustomerId("ADMIN-001"); // Unique identifier for login
                admin.setEmail("admin@example.com"); // Unique email
                admin.setMobileNumber("9999999999"); // Unique mobile number

                // Set name and other personal details (can be placeholders for an admin)
                admin.setFname("Admin-Somnath");
                admin.setLname("Admin-Pandit");
                admin.setFathername("System"); // Example placeholder
                admin.setAddress("Head Office"); // Example placeholder
                admin.setPincode("000000"); // Example placeholder
                admin.setDob(java.time.LocalDate.of(2000, 1, 1)); // Example DOB

                // Securely hash the admin's password using the injected PasswordEncoder
                admin.setPassword(encoder.encode("admin123")); // HASH the password

                // Set banking details (placeholders for admin - might not need full details)
                admin.setAccountNumber("000000000001"); // Unique account number
                admin.setIfsCode("ADMINIFSC"); // Example IFSC
                admin.setBranchCode("ADMINBR"); // Example Branch Code
                admin.setBalance(0.0); // Admin might start with zero balance

                // *** FIX ***: Use the correct setter names from your Customer model (setIsApproved, setIsAdmin)
                admin.setApproved(true); // <<< Set this to true so the admin user is 'enabled' for login
                admin.setAdmin(true);   // <<< Set this to true to grant the ROLE_ADMIN authority
                // *** END FIX ***

                // Save the fully configured admin user to the database
                customerRepository.save(admin);
                System.out.println("✅ Admin user 'admin@example.com' (ID: ADMIN-001) inserted successfully.");
            }
            else {
                System.out.println("Admin user 'admin@example.com' already exists. Skipping initialization."); // Log if admin already exists
            }
        };
    }
}

--- main\java\com\Banking_Somnath\banking_systemn\config\SecurityConfig.java ---
// --- main\java\com\Banking_Somnath\banking_systemn\config\SecurityConfig.java ---
package com.Banking_Somnath.banking_systemn.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.CsrfConfigurer;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity // Keep for potential future @PreAuthorize use
public class SecurityConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(CsrfConfigurer::disable)
                .authorizeHttpRequests(auth -> auth
                        // Public endpoints
                        .requestMatchers("/register", "/login").permitAll()
                        .requestMatchers(HttpMethod.POST, "/apply-for-job").permitAll() // Public job application

                        // Admin endpoints (Customer Management & Job Applications)
                        .requestMatchers("/admin/pending", "/admin/approve/**", "/admin/reject/**").hasRole("ADMIN")
                        .requestMatchers("/admin/applications/**").hasRole("ADMIN") // Covers list, detail, schedule, reject, hire
                        .requestMatchers("/admin/**").hasRole("ADMIN") // Catch-all for any other /admin paths
                        .requestMatchers("/admin/fd/**").hasRole("ADMIN")
                        .requestMatchers("/admin/loan/**").hasRole("ADMIN")
                        // Employee endpoints (Customer Financial Actions)
                        // *** MODIFIED: Allow both EMPLOYEE and ADMIN ***
                        .requestMatchers("/employee/**").hasAnyRole("EMPLOYEE", "ADMIN")

                        // Authenticated Customer endpoints
                        .requestMatchers(HttpMethod.GET, "/check-balance").authenticated() // Customer checking own balance
                        .requestMatchers(HttpMethod.POST, "/transfer").authenticated()     // Customer transferring own money
                        .requestMatchers(HttpMethod.GET, "/transactions/download").hasAnyRole("USER", "EMPLOYEE", "ADMIN")// Customer downloading own history
                        .requestMatchers("/fd/apply", "/fd/my-fds").authenticated()
                        .requestMatchers("/loan/apply").authenticated()
                        .requestMatchers("/loan/my-loans").authenticated()
                        .anyRequest().authenticated()
                )
                .httpBasic(withDefaults()); // Use HTTP Basic for simplicity here

        return http.build();
    }

    @Bean
    CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of("http://localhost:3000"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("Authorization", "Cache-Control", "Content-Type"));
        configuration.setAllowCredentials(true);
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}

--- main\java\com\Banking_Somnath\banking_systemn\controller\AdminController.java ---
package com.Banking_Somnath.banking_systemn.controller;

import com.Banking_Somnath.banking_systemn.dto.FixedDepositAdminViewDto;
import com.Banking_Somnath.banking_systemn.model.*;
import com.Banking_Somnath.banking_systemn.request.ApproveLoanRequest;
import com.Banking_Somnath.banking_systemn.request.RejectApplicationRequest;
import com.Banking_Somnath.banking_systemn.request.RejectRequest;
import com.Banking_Somnath.banking_systemn.request.ScheduleInterviewRequest;
import com.Banking_Somnath.banking_systemn.service.AdminService;
import com.Banking_Somnath.banking_systemn.service.FixedDepositService;
import com.Banking_Somnath.banking_systemn.service.LoanService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.security.Principal;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/admin")
public class AdminController {


    @Autowired
    private FixedDepositService fixedDepositService;


    private static final Logger log = LoggerFactory.getLogger(JobApplicationController.class);


    @Autowired
    private LoanService loanService;

    @Autowired
    private AdminService adminService;

    @GetMapping("/pending")
    public ResponseEntity<List<Customer>> viewPendingRegistrations() {
        List<Customer> pendingCustomers = adminService.findPendingRegistrations();
        return ResponseEntity.ok(pendingCustomers);
    }

    @PostMapping("/approve/{customerId}")
    public ResponseEntity<String> approveRegistration(@PathVariable String customerId) {
        String result = adminService.approveRegistration(customerId);
        if (result.contains("Customer not found")) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
        } else if (result.contains("already approved")) {
            return ResponseEntity.status(HttpStatus.CONFLICT).body(result);
        }
        return ResponseEntity.ok(result);
    }

    @PostMapping("/reject/{customerId}")
    public ResponseEntity<String> rejectRegistration(@PathVariable String customerId) {
        String result = adminService.rejectRegistration(customerId);
        if (result.contains("Customer not found")) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
        }
        return ResponseEntity.ok(result);
    }

    // new section for employee

    @GetMapping("/applications")
    public ResponseEntity<List<JobApplication>> getAllApplications() {
        List<JobApplication> applications = adminService.getAllJobApplications();
        return ResponseEntity.ok(applications);
    }

    @GetMapping("/applications/{appId}")
    public ResponseEntity<JobApplication> getApplicationDetails(@PathVariable Long appId) {
        return adminService.getJobApplicationDetails(appId)
                .map(ResponseEntity::ok) // If found, wrap in 200 OK
                .orElse(ResponseEntity.notFound().build()); // If not found, return 404
    }

    @PostMapping("/applications/{appId}/schedule-interview")
    public ResponseEntity<?> scheduleInterview(
            @PathVariable Long appId,
            @RequestBody ScheduleInterviewRequest request, // Use the DTO
            Principal principal) { // Get the logged-in admin
        if (principal == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Admin user not authenticated.");
        }
        try {
            JobApplication updatedApp = adminService.scheduleJobInterview(appId, request.getInterviewDate(), principal.getName());
            return ResponseEntity.ok(updatedApp);
        } catch (RuntimeException e) {
            // Catch exceptions from service (e.g., app not found)
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());
        } catch (Exception e){
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("An unexpected error occurred.");
        }
    }

    @PostMapping("/applications/{appId}/reject")
    public ResponseEntity<?> rejectApplication(
            @PathVariable Long appId,
            @RequestBody RejectApplicationRequest request, // Use the DTO
            Principal principal) {
        if (principal == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Admin user not authenticated.");
        }
        try {
            JobApplication updatedApp = adminService.rejectJobApplication(appId, request.getReason(), principal.getName());
            return ResponseEntity.ok(updatedApp);
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());
        } catch (Exception e){
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("An unexpected error occurred.");
        }
    }

    @PostMapping("/applications/{appId}/hire")
    public ResponseEntity<?> hireApplicant(
            @PathVariable Long appId,
            Principal principal) {
        if (principal == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Admin user not authenticated.");
        }
        try {
            JobApplication updatedApp = adminService.hireApplicant(appId, principal.getName());
            // Maybe return the updated application OR just a success message
            return ResponseEntity.ok(updatedApp); // Returning updated app might be useful
        } catch (RuntimeException e) {
            // Catch specific errors like "already hired" or "email exists"
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());
        } catch (Exception e){
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("An unexpected error occurred during hiring process.");
        }
    }

    @GetMapping("/loan/pending")
    public ResponseEntity<List<LoanApplication>> viewPendingLoans() {
        // Consider adding try-catch for robustness, although service might handle
        try {
            List<LoanApplication> pendingLoans = loanService.getPendingLoanApplications();
            return ResponseEntity.ok(pendingLoans);
        } catch (Exception e) {
            log.error("Admin failed to fetch pending loans: {}", e.getMessage(), e);
            // Return an empty list or an error response
            // return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Collections.emptyList());
            // For simplicity, rethrowing might be caught by a global handler if configured
            throw new RuntimeException("Failed to fetch pending loans", e);
        }
    }

    /**
     * Endpoint for Admin to approve a specific loan application.
     * Requires loan ID in path and approval details (amount, rate) in body.
     */
    @PostMapping("/loan/approve/{loanId}")
    public ResponseEntity<?> approveLoanApplication(
            @PathVariable Long loanId,
            @RequestBody ApproveLoanRequest approveDetails, // Request body with approved amount/rate
            Principal principal)
    {
        if (principal == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("success", false, "message", "Admin not authenticated."));
        }
        String adminId = principal.getName(); // Get adminId from authenticated principal
        try {
            LoanApplication approvedLoan = loanService.approveLoan(loanId, adminId, approveDetails);
            // Return success response with the updated loan application details
            return ResponseEntity.ok(Map.of("success", true, "message", "Loan application " + loanId + " approved successfully.", "loanApplication", approvedLoan));
        } catch (IllegalStateException | IllegalArgumentException e) {
            // Handle cases like wrong status or invalid approval data
            log.warn("Loan approval failed for ID {}: {}", loanId, e.getMessage());
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("success", false, "message", e.getMessage()));
        } catch (RuntimeException e) {
            // Handle other errors like loan not found or DB issues
            log.error("Error approving loan ID {}: {}", loanId, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("success", false, "message", "Error approving loan: " + e.getMessage()));
        }
    }

    /**
     * Endpoint for Admin to reject a specific loan application.
     * Requires loan ID in path and rejection reason in body.
     */
    @PostMapping("/loan/reject/{loanId}")
    public ResponseEntity<?> rejectLoanApplication(
            @PathVariable Long loanId,
            @RequestBody RejectRequest rejectRequest, // Request body with reason
            Principal principal)
    {
        if (principal == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("success", false, "message", "Admin not authenticated."));
        }
        String adminId = principal.getName();
        try {
            LoanApplication rejectedLoan = loanService.rejectLoan(loanId, adminId, rejectRequest.getReason());
            // Return success response with the updated loan application details
            return ResponseEntity.ok(Map.of("success", true, "message", "Loan application " + loanId + " rejected successfully.", "loanApplication", rejectedLoan));
        } catch (IllegalStateException | IllegalArgumentException e) {
            // Handle cases like wrong status or missing reason
            log.warn("Loan rejection failed for ID {}: {}", loanId, e.getMessage());
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("success", false, "message", e.getMessage()));
        } catch (RuntimeException e) {
            // Handle other errors like loan not found or DB issues
            log.error("Error rejecting loan ID {}: {}", loanId, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("success", false, "message", "Error rejecting loan: " + e.getMessage()));
        }
    }

    @GetMapping("/fd/pending")
    public ResponseEntity<?> viewPendingFixedDeposits() {
        log.info("ADMIN API CALL: Fetching all pending FD applications.");
        try {
            // <<< CORRECTED: Call service method that returns DTOs >>>
            List<FixedDepositAdminViewDto> pendingFdDtos = fixedDepositService.getPendingFdApplicationsForAdmin();
            return ResponseEntity.ok(pendingFdDtos); // Return list of DTOs
        } catch (Exception e) {
            log.error("Admin error fetching pending FDs: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("success", false, "message", "Failed to fetch pending Fixed Deposit applications."));
        }
    }

    /**
     * Endpoint for Admin to approve a specific PENDING Fixed Deposit application.
     * Requires FD ID in the path.
     */
    @PostMapping("/fd/approve/{fdId}")
    public ResponseEntity<?> approveFixedDeposit(@PathVariable Long fdId, Principal principal) {
        if (principal == null || principal.getName() == null) {
            log.warn("FD Approve attempt by unauthenticated admin.");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("success", false, "message", "Admin not authenticated."));
        }
        String adminId = principal.getName();
        log.info("ADMIN API CALL: Admin '{}' attempting to approve FD application ID: {}", adminId, fdId);
        try {
            // <<< CORRECTED: Call service method that returns DTO >>>
            FixedDepositAdminViewDto approvedFdDto = fixedDepositService.approveFd(fdId, adminId);
            return ResponseEntity.ok(Map.of(
                    "success", true,
                    "message", "Fixed Deposit application (ID: " + fdId + ") approved successfully and is now active.",
                    "fixedDeposit", approvedFdDto // Send back the DTO
            ));
        } catch (IllegalStateException | IllegalArgumentException e) {
            log.warn("Admin FD approval validation failed for FD ID {}: {}", fdId, e.getMessage());
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("success", false, "message", e.getMessage()));
        } catch (RuntimeException e) {
            log.error("Error during admin approval of FD ID {}: {}", fdId, e.getMessage(), e);
            if (e.getMessage() != null && e.getMessage().toLowerCase().contains("insufficient balance")) {
                return ResponseEntity.status(HttpStatus.CONFLICT)
                        .body(Map.of("success", false, "message", e.getMessage()));
            }
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("success", false, "message", "An unexpected error occurred while approving the FD: " + e.getMessage()));
        }
    }

    /**
     * Endpoint for Admin to reject a specific PENDING FixedDeposit application.
     * Requires FD ID in path and a rejection reason in the request body.
     */
    @PostMapping("/fd/reject/{fdId}")
    public ResponseEntity<?> rejectFixedDeposit(@PathVariable Long fdId, @RequestBody RejectRequest rejectRequest, Principal principal) {
        if (principal == null || principal.getName() == null) {
            log.warn("FD Reject attempt by unauthenticated admin.");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("success", false, "message", "Admin not authenticated."));
        }
        String adminId = principal.getName();
        log.info("ADMIN API CALL: Admin '{}' attempting to reject FD application ID: {} with reason: {}",
                adminId, fdId, rejectRequest.getReason());
        try {
            // <<< CORRECTED: Call service method that returns DTO >>>
            FixedDepositAdminViewDto rejectedFdDto = fixedDepositService.rejectFd(fdId, adminId, rejectRequest.getReason());
            return ResponseEntity.ok(Map.of(
                    "success", true,
                    "message", "Fixed Deposit application (ID: " + fdId + ") rejected successfully.",
                    "fixedDeposit", rejectedFdDto // Send back the DTO
            ));
        } catch (IllegalStateException | IllegalArgumentException e) {
            log.warn("Admin FD rejection validation failed for FD ID {}: {}", fdId, e.getMessage());
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("success", false, "message", e.getMessage()));
        } catch (RuntimeException e) {
            log.error("Error during admin rejection of FD ID {}: {}", fdId, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("success", false, "message", "An unexpected error occurred while rejecting the FD: " + e.getMessage()));
        }
    }


}


--- main\java\com\Banking_Somnath\banking_systemn\controller\CustomerController.java ---
package com.Banking_Somnath.banking_systemn.controller;

import com.Banking_Somnath.banking_systemn.dto.FixedDepositCustomerViewDto;
import com.Banking_Somnath.banking_systemn.model.Customer;
import com.Banking_Somnath.banking_systemn.model.FixedDeposit;
import com.Banking_Somnath.banking_systemn.model.LoanApplication;
import com.Banking_Somnath.banking_systemn.repository.CustomerRepository;
import com.Banking_Somnath.banking_systemn.request.*;
import com.Banking_Somnath.banking_systemn.response.BalanceResponse;
import com.Banking_Somnath.banking_systemn.security.CustomUserDetailsService;
import com.Banking_Somnath.banking_systemn.service.CustomerService;
//import com.Banking_Somnath.banking_systemn.service.TransactionService;
import com.Banking_Somnath.banking_systemn.service.FixedDepositService;
import com.Banking_Somnath.banking_systemn.service.LoanService;
import com.Banking_Somnath.banking_systemn.service.TransactionService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.DisabledException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import java.security.Principal;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@RestController
//@CrossOrigin("http://localhost:3000")
// somnath@2004 ->password
public class CustomerController {

    private static final Logger log = LoggerFactory.getLogger(JobApplicationController.class);

    @Autowired
    private FixedDepositService fixedDepositService;

    @Autowired
    CustomerService customerService;

    @Autowired
    TransactionService transactionService;

    @Autowired
    private CustomUserDetailsService userDetailsService; // For loading user data

    @Autowired
    CustomerRepository customerRepository;

    @Autowired
    private LoanService loanService;


    @Autowired
    private PasswordEncoder passwordEncoder; // For checking password hash


    @PostMapping("/register")
    public ResponseEntity<Customer> register(@RequestBody Customer customer) {
        Customer registeredCustomer = customerService.register(customer);
        return ResponseEntity.status(HttpStatus.CREATED).body(registeredCustomer);
    }

    // --- Part of CustomerController.java ---

    // --- Login endpoint using Manual Authentication Checks ---
    // --- CORRECTED /login endpoint using Manual Authentication Checks & Returning Role/ID ---
    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequest loginRequest) {
        // --- Basic Request Body Validation ---
        if (loginRequest.getPassword() == null || loginRequest.getPassword().isEmpty()) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("success", false, "message", "Password is required."));
        }
        String identifier = loginRequest.getCustomerId(); // Prioritize customerId
        if ((identifier == null || identifier.isEmpty()) && (loginRequest.getMobileNumber() == null || loginRequest.getMobileNumber().isEmpty())) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("success", false, "message", "Either Customer ID or Mobile Number is required."));
        }
        if (identifier == null || identifier.isEmpty()) {
            identifier = loginRequest.getMobileNumber(); // Fallback to mobile
        }
        if (identifier == null || identifier.isEmpty()) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("success", false, "message", "Login identifier is required."));
        }

        try {
            // --- Manual Authentication Steps ---

            // 1. Load User by identifier
            UserDetails userDetails = userDetailsService.loadUserByUsername(identifier);

            // 2. Check if account is enabled (isApproved || isAdmin)
            if (!userDetails.isEnabled()) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("success", false, "message", "Account is pending admin approval or disabled."));
            }

            // 3. Check if password matches the stored hash
            if (!passwordEncoder.matches(loginRequest.getPassword(), userDetails.getPassword())) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("success", false, "message", "Invalid Credentials.")); // Generic message
            }

            // --- Authentication Successful ---

            // *** FIX: Extract role and customerId for the success response ***
            String role = userDetails.getAuthorities().stream()
                    .findFirst() // Get the first role (e.g., ROLE_ADMIN or ROLE_USER)
                    .map(GrantedAuthority::getAuthority)
                    .orElse("UNKNOWN_ROLE"); // Provide a default if somehow no role is assigned
            // getUsername() from UserDetails is configured to return customerId in Customer.java
            String authenticatedCustomerId = userDetails.getUsername();

            // Return 200 OK success response WITH role and customerId
            return ResponseEntity.ok(Map.of(
                    "success", true,
                    "message", "Login successful!",
                    "role", role,
                    "customerId", authenticatedCustomerId
            ));
            // *** END FIX ***

        } catch (UsernameNotFoundException e) {
            // User identifier not found
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("success", false, "message", "Invalid Credentials.")); // Generic message
        } catch (Exception e) {
            // Catch any other unexpected errors
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("success", false, "message", "An unexpected error occurred during login: " + e.getMessage()));
        }
    }


    @GetMapping("/check-balance")
    public ResponseEntity<?> checkBalance() {
//         Get the logged-in user's customerId from the SecurityContext
        String customerId = getLoggedInCustomerId();
        System.out.println("Checking balance for: " + customerId);
//        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
//        String customerId = authentication.getName();
//        System.out.println("Customer ID from security context: " + customerId);


        if (customerId == null) {
            return ResponseEntity.status(401).body("ERROR: User not logged in.");
        }

        // Call service to check balance
        String balance = transactionService.getBalance(customerId);

        if (balance.startsWith("ERROR")) {
            return ResponseEntity.status(404).body(balance);
        }

        return ResponseEntity.ok(new BalanceResponse(true, balance));
    }

    private String getLoggedInCustomerId() {
        // Get the logged-in user (assuming customerId is the username in Spring Security)
        Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        if (principal instanceof UserDetails) {
            return ((UserDetails) principal).getUsername();
        }
        return null;
    }

    @PostMapping("/transfer") // This matches the endpoint your frontend calls
    public ResponseEntity<?> performTransfer(@RequestBody TransferMoney transferRequest) {
        String customerId = getLoggedInCustomerId(); // Get the ID of the logged-in sender

        if (customerId == null) {
            // For an actual application, consider how to provide feedback without server-side logs
            // if direct client feedback is not enough.
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                    .body(new SimpleMessageResponse(false, "User not logged in or session expired. Please login again."));
        }

        // Password field is assumed to be removed from TransferMoney DTO and service logic.
        // No logging of the request body here.

        Optional<Customer> senderOpt = customerRepository.findByCustomerId(customerId);
        if (senderOpt.isEmpty()) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(new SimpleMessageResponse(false, "Authenticated user account not found. Please contact support."));
        }

        // Call the transaction service to perform the transfer
        // The transactionService.Transfer method and TransferMoney DTO
        // should also be updated to not expect/use senderPassword.
        String result = transactionService.Transfer(senderOpt.get(), transferRequest);

        // Process the result from the service
        if (result.startsWith("ERROR:")) {
            String errorMessage = result.substring("ERROR:".length()).trim();
            return ResponseEntity.badRequest().body(new SimpleMessageResponse(false, errorMessage));
        }

        return ResponseEntity.ok(new SimpleMessageResponse(true, result));
    }

    // Assuming SimpleMessageResponse class is defined like this, possibly in another file
    // or as a static nested class if only used here.
    public static class SimpleMessageResponse {
        private boolean success;
        private String message;

        public SimpleMessageResponse(boolean success, String message) {
            this.success = success;
            this.message = message;
        }

        public boolean isSuccess() {
            return success;
        }

        public String getMessage() {
            return message;
        }
    }

    @GetMapping("/transactions/download")
    public ResponseEntity<?> downloadTransactionHistory(
            @RequestParam("startDate") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam("endDate") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate,
            Principal principal) {
        if (principal == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("User not authenticated.");
        }
        String customerId = principal.getName();
        if (startDate == null || endDate == null) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Both start date and end date are required.");
        }
        if (startDate.isAfter(endDate)) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Start date cannot be after end date.");
        }

        try {
            // Call the service method with customerId and the date range
            byte[] pdfBytes = transactionService.generateTransactionHistoryPdf(customerId, startDate, endDate);

            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_PDF);
            String filename = String.format("transaction_history_%s_%s_to_%s.pdf",
                    customerId,
                    startDate.toString(),
                    endDate.toString());
            headers.setContentDispositionFormData("attachment", filename);
            headers.setCacheControl("must-revalidate, post-check=0, pre-check=0");

            return new ResponseEntity<>(pdfBytes, headers, HttpStatus.OK);

        } catch (RuntimeException e) {
            // Catch specific exceptions like customer not found during generation if needed
            e.printStackTrace();
            // Provide a user-friendly error in the body
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error generating PDF: " + e.getMessage());
        } catch (Exception e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Failed to generate PDF due to an unexpected error.");
        }
    }

    // Simple response class for Transfer endpoint
    public static class SimpleMessage {
        private boolean success;
        private String message;

        public SimpleMessage(boolean success, String message) {
            this.success = success;
            this.message = message;
        }

        public boolean isSuccess() {
            return success;
        }

        public String getMessage() {
            return message;
        }
    }

    @PostMapping("/loan/apply")
    public ResponseEntity<?> applyForLoan(@RequestBody CreateLoanRequest loanRequest, Principal principal) {
        if (principal == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("success", false, "message", "User not authenticated."));
        }
        String customerId = principal.getName(); // Get customerId from authenticated principal
        try {
            LoanApplication createdLoanApp = loanService.applyForLoan(customerId, loanRequest);
            // Return success response with basic details
            return ResponseEntity.status(HttpStatus.CREATED).body(Map.of(
                    "success", true,
                    "message", "Loan application submitted successfully. Awaiting review.",
                    "applicationId", createdLoanApp.getId(),
                    "status", createdLoanApp.getStatus()
            ));
        } catch (IllegalArgumentException e) {
            // Handle validation errors from the service
            log.warn("Loan application validation failed for customer {}: {}", customerId, e.getMessage());
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("success", false, "message", e.getMessage()));
        } catch (RuntimeException e) {
            // Handle other errors like customer not found or database issues
            log.error("Error submitting loan application for customer {}: {}", customerId, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("success", false, "message", "Error submitting loan application: " + e.getMessage()));
        }
    }

    /**
     * Endpoint for a logged-in customer to view their own loan applications.
     */
    @GetMapping("/loan/my-loans")
    public ResponseEntity<?> getMyLoanApplications(Principal principal) {
        if (principal == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("success", false, "message", "User not authenticated."));
        }
        String customerId = principal.getName();
        try {
            List<LoanApplication> loanApps = loanService.getLoansByCustomer(customerId);
            return ResponseEntity.ok(Map.of("success", true, "loanApplications", loanApps));
        } catch (RuntimeException e) {
            // Handle errors like customer not found during fetch
            log.error("Error fetching loan applications for customer {}: {}", customerId, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("success", false, "message", "Error fetching loan applications: " + e.getMessage()));
        }
    }

    @PostMapping("/fd/apply")
    public ResponseEntity<?> applyForFixedDeposit(@RequestBody CreateFdRequest fdRequest, Principal principal) {
        if (principal == null || principal.getName() == null) {
            log.warn("FD Apply attempt by unauthenticated user.");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("success", false, "message", "User not authenticated. Please log in."));
        }
        String customerId = principal.getName();
        log.info("API CALL: Customer '{}' applying for FD. Amount: ₹{}, Term: {} months",
                customerId, fdRequest.getPrincipalAmount(), fdRequest.getTermInMonths());
        try {
            // <<< CORRECTED: Call service method that returns DTO >>>
            FixedDepositCustomerViewDto createdFdDto = fixedDepositService.applyForFd(customerId, fdRequest);
            // The applyForFd service method was already updated to return FixedDepositCustomerViewDto

            return ResponseEntity.status(HttpStatus.CREATED).body(Map.of(
                    "success", true,
                    "message", "Fixed Deposit application submitted successfully. It is now pending admin approval.",
                    "applicationId", createdFdDto.getId(),
                    "principalAmount", createdFdDto.getPrincipalAmount(),
                    "termInMonths", createdFdDto.getTermInMonths(),
                    "interestRate", createdFdDto.getInterestRate(), // Make sure DTO has this if needed here
                    "status", createdFdDto.getStatus()
            ));
        } catch (IllegalArgumentException e) {
            log.warn("FD application validation failed for customer '{}': {}", customerId, e.getMessage());
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("success", false, "message", e.getMessage()));
        } catch (RuntimeException e) {
            log.error("Error during FD application for customer '{}': {}", customerId, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("success", false, "message", "An unexpected error occurred while processing your FD application. Please try again later."));
        }
    }

    // In CustomerController.java
    @GetMapping("/fd/my-fds")
    public ResponseEntity<?> getMyFixedDeposits(Principal principal) {
        // 1. Authentication Check
        if (principal == null || principal.getName() == null) {
            log.warn("API CALL to /fd/my-fds by unauthenticated user.");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                    .body(Map.of("success", false, "message", "User not authenticated. Please log in to view your Fixed Deposits."));
        }

        String customerId = principal.getName();
        log.info("API CALL: Customer '{}' fetching their Fixed Deposits via /fd/my-fds.", customerId);

        try {
            // 2. Call Service Method that returns a List of DTOs
            // This assumes fixedDepositService.getFdsByCustomerIdDto(customerId) correctly
            // fetches entities and converts them to FixedDepositCustomerViewDto without lazy loading issues.
            List<FixedDepositCustomerViewDto> fdsDtoList = fixedDepositService.getFdsByCustomerIdDto(customerId);

            if (fdsDtoList == null) { // Should not happen if service returns empty list instead of null
                log.error("Service returned null list of FDs for customer '{}'. This is unexpected.", customerId);
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                        .body(Map.of("success", false, "message", "An internal error occurred while fetching your Fixed Deposits."));
            }

            log.info("Successfully fetched {} Fixed Deposit DTOs for customer '{}'.", fdsDtoList.size(), customerId);
            // 3. Successful Response with DTO list
            return ResponseEntity.ok(Map.of("success", true, "fixedDeposits", fdsDtoList));

        } catch (RuntimeException e) {
            // This catches exceptions thrown from the service layer,
            // e.g., "Customer not found" or database access issues.
            log.error("Error fetching FDs for customer '{}': {}", customerId, e.getMessage(), e); // Log the full exception for debugging

            String userMessage = "An error occurred while fetching your Fixed Deposits. Please try again later.";
            if (e.getMessage() != null && e.getMessage().toLowerCase().contains("customer not found")) {
                // More specific message if customer was not found (should ideally not happen for an authenticated user's own data)
                userMessage = "Could not retrieve your Fixed Deposit details. User profile not found.";
                return ResponseEntity.status(HttpStatus.NOT_FOUND) // Or INTERNAL_SERVER_ERROR
                        .body(Map.of("success", false, "message", userMessage));
            }

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("success", false, "message", userMessage));
        }

    }
}

--- main\java\com\Banking_Somnath\banking_systemn\controller\EmployeeController.java ---
package com.Banking_Somnath.banking_systemn.controller;

import com.Banking_Somnath.banking_systemn.request.EmployeeActionRequest; // Assuming a combined request DTO
import com.Banking_Somnath.banking_systemn.response.BalanceResponse; // Can reuse this
import com.Banking_Somnath.banking_systemn.service.EmployeeService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

        import java.security.Principal; // To get the logged-in employee/admin ID
import java.util.Map;

@RestController
@RequestMapping("/employee") // Base path for all employee actions
public class EmployeeController {

    @Autowired
    private EmployeeService employeeService;

    // Helper to get the logged-in username (employee/admin customerId)
    private String getPerformingUsername(Principal principal) {
        if (principal == null || principal.getName() == null) {
            throw new SecurityException("User not authenticated."); // Should be caught by Spring Security ideally
        }
        return principal.getName();
    }

    @PostMapping("/deposit")
    public ResponseEntity<?> performDeposit(@RequestBody EmployeeActionRequest request, Principal principal) {
        try {
            String performingUsername = getPerformingUsername(principal);
            String result = employeeService.deposit(request.getTargetCustomerId(), request.getAmount(), performingUsername);

            if (result.startsWith("ERROR:")) {
                return ResponseEntity.badRequest().body(Map.of("success", false, "message", result.replace("ERROR: ", "")));
            }
            return ResponseEntity.ok(Map.of("success", true, "message", result));
        } catch (SecurityException e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("success", false, "message", e.getMessage()));
        } catch (Exception e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("success", false, "message", "An unexpected error occurred during deposit."));
        }
    }

    @PostMapping("/withdraw")
    public ResponseEntity<?> performWithdrawal(@RequestBody EmployeeActionRequest request, Principal principal) {
        try {
            String performingUsername = getPerformingUsername(principal);
            String result = employeeService.withdraw(request.getTargetCustomerId(), request.getAmount(), performingUsername);

            if (result.startsWith("ERROR:")) {
                return ResponseEntity.badRequest().body(Map.of("success", false, "message", result.replace("ERROR: ", "")));
            }
            return ResponseEntity.ok(Map.of("success", true, "message", result));
        } catch (SecurityException e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("success", false, "message", e.getMessage()));
        } catch (Exception e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("success", false, "message", "An unexpected error occurred during withdrawal."));
        }
    }

    @GetMapping("/check-balance/{targetCustomerId}")
    public ResponseEntity<?> checkCustomerBalance(@PathVariable String targetCustomerId, Principal principal) {
        try {
            String performingUsername = getPerformingUsername(principal);
            String balance = employeeService.checkBalance(targetCustomerId, performingUsername);

            if (balance.startsWith("ERROR:")) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("success", false, "message", balance.replace("ERROR: ", "")));
            }
            // Reuse BalanceResponse or return a map
            return ResponseEntity.ok(new BalanceResponse(true, balance));
            // return ResponseEntity.ok(Map.of("success", true, "customerId", targetCustomerId, "balance", balance));

        } catch (SecurityException e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("success", false, "message", e.getMessage()));
        } catch (Exception e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("success", false, "message", "An unexpected error occurred checking balance."));
        }
    }

}

--- main\java\com\Banking_Somnath\banking_systemn\controller\JobApplicationController.java ---
package com.Banking_Somnath.banking_systemn.controller;

import com.Banking_Somnath.banking_systemn.model.JobApplication;
import com.Banking_Somnath.banking_systemn.request.JobApplicationRequest;
import com.Banking_Somnath.banking_systemn.service.JobApplicationService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping; // Add RequestMapping if needed for base path
import org.springframework.web.bind.annotation.RestController;

import java.util.Map; // For simple message responses

@RestController
public class JobApplicationController {

    private static final Logger log = LoggerFactory.getLogger(JobApplicationController.class);

    @Autowired
    private JobApplicationService jobApplicationService;

    // Endpoint for public job application submissions
    @PostMapping("/apply-for-job") // Path matches SecurityConfig permitAll rule
    public ResponseEntity<?> submitJobApplication(
            // Add @Valid here if using validation annotations in the Request DTO
            @RequestBody JobApplicationRequest request
    ) {
        log.info("Received job application submission from email: {}", request.getApplicantEmail());
        try {
            // Basic validation (enhance with @Valid if needed)
            if (request.getApplicantFirstName() == null || request.getApplicantFirstName().isBlank() ||
                    request.getApplicantLastName() == null || request.getApplicantLastName().isBlank() ||
                    request.getApplicantEmail() == null || request.getApplicantEmail().isBlank() ||
                    request.getApplicantPhone() == null || request.getApplicantPhone().isBlank() ||
                    request.getQualifications() == null || request.getQualifications().isBlank() ||
                    request.getDesiredRole() == null || request.getDesiredRole().isBlank()) {
                log.warn("Job application validation failed: Missing required fields.");
                return ResponseEntity.badRequest().body(Map.of("success", false, "message", "Please fill in all required fields."));
            }

            JobApplication submittedApplication = jobApplicationService.submitApplication(request);
            log.info("Job application submitted successfully with ID: {}", submittedApplication.getId());

            // Return a simple success message
            return ResponseEntity.status(HttpStatus.CREATED).body(Map.of(
                    "success", true,
                    "message", "Application submitted successfully!"
                    // "applicationId": submittedApplication.getId() // Optional: return ID
            ));

        } catch (Exception e) {
            log.error("Error submitting job application for email {}: {}", request.getApplicantEmail(), e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("success", false, "message", "An error occurred while submitting your application."));
        }
    }
}

--- main\java\com\Banking_Somnath\banking_systemn\dto\CustomerBasicInfoDto.java ---
package com.Banking_Somnath.banking_systemn.dto;

public class CustomerBasicInfoDto {
    private String customerId;
    private String fullName;
    private String mobileNumber;
    private String email;

    // Default constructor for Jackson
    public CustomerBasicInfoDto() {
    }

    public CustomerBasicInfoDto(String customerId, String fullName, String mobileNumber, String email) {
        this.customerId = customerId;
        this.fullName = fullName;
        this.mobileNumber = mobileNumber;
        this.email = email;
    }

    // Getters and Setters
    public String getCustomerId() { return customerId; }
    public void setCustomerId(String customerId) { this.customerId = customerId; }
    public String getFullName() { return fullName; }
    public void setFullName(String fullName) { this.fullName = fullName; }
    public String getMobileNumber() { return mobileNumber; }
    public void setMobileNumber(String mobileNumber) { this.mobileNumber = mobileNumber; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}

--- main\java\com\Banking_Somnath\banking_systemn\dto\FixedDepositAdminViewDto.java ---
package com.Banking_Somnath.banking_systemn.dto;
import com.Banking_Somnath.banking_systemn.model.FixedDepositStatus;
import java.time.LocalDateTime;

public class FixedDepositAdminViewDto {
    private Long id;
    private CustomerBasicInfoDto customerInfo; // Contains customerId, fullName, etc.
    private Double principalAmount;
    private Integer termInMonths;
    private Double interestRate;
    private LocalDateTime applicationDate;
    private FixedDepositStatus status;
    private String sourceAccountNumber;

    // Constructor
    public FixedDepositAdminViewDto(Long id, CustomerBasicInfoDto customerInfo,
                                    Double principalAmount, Integer termInMonths, Double interestRate,
                                    LocalDateTime applicationDate, FixedDepositStatus status, String sourceAccountNumber) {
        this.id = id;
        this.customerInfo = customerInfo;
        this.principalAmount = principalAmount;
        this.termInMonths = termInMonths;
        this.interestRate = interestRate;
        this.applicationDate = applicationDate;
        this.status = status;
        this.sourceAccountNumber = sourceAccountNumber;
    }
    // Getters and Setters...
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public CustomerBasicInfoDto getCustomerInfo() { return customerInfo; }
    public void setCustomerInfo(CustomerBasicInfoDto customerInfo) { this.customerInfo = customerInfo; }
    public Double getPrincipalAmount() { return principalAmount; }
    public void setPrincipalAmount(Double principalAmount) { this.principalAmount = principalAmount; }
    public Integer getTermInMonths() { return termInMonths; }
    public void setTermInMonths(Integer termInMonths) { this.termInMonths = termInMonths; }
    public Double getInterestRate() { return interestRate; }
    public void setInterestRate(Double interestRate) { this.interestRate = interestRate; }
    public LocalDateTime getApplicationDate() { return applicationDate; }
    public void setApplicationDate(LocalDateTime applicationDate) { this.applicationDate = applicationDate; }
    public FixedDepositStatus getStatus() { return status; }
    public void setStatus(FixedDepositStatus status) { this.status = status; }
    public String getSourceAccountNumber() { return sourceAccountNumber; }
    public void setSourceAccountNumber(String sourceAccountNumber) { this.sourceAccountNumber = sourceAccountNumber; }
}

--- main\java\com\Banking_Somnath\banking_systemn\dto\FixedDepositCustomerViewDto.java ---
package com.Banking_Somnath.banking_systemn.dto; // Or your DTO package

import com.Banking_Somnath.banking_systemn.model.FixedDepositStatus;

import java.time.LocalDate;
import java.time.LocalDateTime;

public class FixedDepositCustomerViewDto {
    private Long id;
    private Double principalAmount;
    private Double interestRate;
    private Integer termInMonths;
    private LocalDate startDate;
    private LocalDate maturityDate;
    private Double maturityAmount;
    private FixedDepositStatus status;
    private LocalDateTime applicationDate;
    private String sourceAccountNumber;
    private String rejectionReason; // Only relevant if rejected

    // Constructors, Getters, and Setters

    public FixedDepositCustomerViewDto() {
    }

    public FixedDepositCustomerViewDto(Long id, Double principalAmount, Double interestRate, Integer termInMonths,
                                       LocalDate startDate, LocalDate maturityDate, Double maturityAmount,
                                       FixedDepositStatus status, LocalDateTime applicationDate, String sourceAccountNumber,
                                       String rejectionReason) {
        this.id = id;
        this.principalAmount = principalAmount;
        this.interestRate = interestRate;
        this.termInMonths = termInMonths;
        this.startDate = startDate;
        this.maturityDate = maturityDate;
        this.maturityAmount = maturityAmount;
        this.status = status;
        this.applicationDate = applicationDate;
        this.sourceAccountNumber = sourceAccountNumber;
        this.rejectionReason = rejectionReason;
    }

    // --- Getters ---
    public Long getId() { return id; }
    public Double getPrincipalAmount() { return principalAmount; }
    public Double getInterestRate() { return interestRate; }
    public Integer getTermInMonths() { return termInMonths; }
    public LocalDate getStartDate() { return startDate; }
    public LocalDate getMaturityDate() { return maturityDate; }
    public Double getMaturityAmount() { return maturityAmount; }
    public FixedDepositStatus getStatus() { return status; }
    public LocalDateTime getApplicationDate() { return applicationDate; }
    public String getSourceAccountNumber() { return sourceAccountNumber; }
    public String getRejectionReason() { return rejectionReason; }

    // --- Setters ---
    public void setId(Long id) { this.id = id; }
    public void setPrincipalAmount(Double principalAmount) { this.principalAmount = principalAmount; }
    public void setInterestRate(Double interestRate) { this.interestRate = interestRate; }
    public void setTermInMonths(Integer termInMonths) { this.termInMonths = termInMonths; }
    public void setStartDate(LocalDate startDate) { this.startDate = startDate; }
    public void setMaturityDate(LocalDate maturityDate) { this.maturityDate = maturityDate; }
    public void setMaturityAmount(Double maturityAmount) { this.maturityAmount = maturityAmount; }
    public void setStatus(FixedDepositStatus status) { this.status = status; }
    public void setApplicationDate(LocalDateTime applicationDate) { this.applicationDate = applicationDate; }
    public void setSourceAccountNumber(String sourceAccountNumber) { this.sourceAccountNumber = sourceAccountNumber; }
    public void setRejectionReason(String rejectionReason) { this.rejectionReason = rejectionReason; }
}

--- main\java\com\Banking_Somnath\banking_systemn\model\ApplicationStatus.java ---
package com.Banking_Somnath.banking_systemn.model;

public enum ApplicationStatus {
    PENDING,
    UNDER_REVIEW,
    INTERVIEW_SCHEDULED,
    REJECTED,
    HIRED
}


--- main\java\com\Banking_Somnath\banking_systemn\model\Customer.java ---
package com.Banking_Somnath.banking_systemn.model;

import jakarta.persistence.*;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;


import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

@Entity
public class Customer implements UserDetails {
    @Id
    private String  mobileNumber;

    @Column(nullable = false , unique = true) // this means customer can not enter one mail many times this must be unique every time when open new account one email fo rone account
    private String email;

    private String fname;
    private String lname;
    private String fathername;
    private String address;
    private String pincode;
    private LocalDate dob;
    private String password;
    private String accountNumber;
    private String ifsCode;
    private String branchCode;
    private double balance;
    @Column(nullable = false,unique = true)
    private String customerId;

    // this new two field for admin roel
    @Column(nullable = false, columnDefinition = "BOOLEAN DEFAULT false")
    private boolean isAdmin = false;

    @Column(nullable = false, columnDefinition = "BOOLEAN DEFAULT false")
    private boolean isApproved = false;

//    @Column(nullable = false , columnDefinition = "BOOLEAN DEFAULT false")
//    private boolean isEmployee = false;

    public Customer(){

    }

    public Customer(String fathername,
                    String customerId,
                    LocalDate dob, String pincode,
                    boolean isAdmin, boolean isApproved,
                    boolean isEmployee,

                    String address, String lname, String fname, String email, String mobileNumber , String password , String accountNumber , String ifsCode, String branchCode , double balance) {
        this.fathername = fathername;
        this.dob = dob;
        this.pincode = pincode;
        this.address = address;
        this.lname = lname;
        this.fname = fname;
        this.email = email;
        this.mobileNumber = mobileNumber;
        this.password=password;
        this.accountNumber=accountNumber;
        this.ifsCode=ifsCode;
        this.branchCode=branchCode;
        this.balance=balance;
        this.customerId=customerId;
        this.isAdmin=isAdmin;
        this.isApproved=isApproved;
//        this.isEmployee = isEmployee;
    }

    public Customer(Customer customer) {

    }
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        List<GrantedAuthority> authorities = new ArrayList<>();
        if (this.isAdmin) {
            authorities.add(new SimpleGrantedAuthority("ROLE_ADMIN"));
        } else if (this.isApproved) { // Must NOT be employee AND approved/active
            authorities.add(new SimpleGrantedAuthority("ROLE_USER"));
        }
        // If not approved, they have no role effectively preventing login via isEnabled()
        return authorities;
    }


    public String getMobileNumber() {
        return mobileNumber;
    }

    public void setMobileNumber(String mobileNumber) {
        this.mobileNumber = mobileNumber;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getFname() {
        return fname;
    }

    public void setFname(String fname) {
        this.fname = fname;
    }

    public String getFathername() {
        return fathername;
    }

    public void setFathername(String fathername) {
        this.fathername = fathername;
    }

    public String getLname() {
        return lname;
    }

    public void setLname(String lname) {
        this.lname = lname;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public String getPincode() {
        return pincode;
    }

    public void setPincode(String pincode) {
        this.pincode = pincode;
    }

    public LocalDate getDob() {
        return dob;
    }

    public void setDob(LocalDate dob) {
        this.dob = dob;
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return this.customerId;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return this.isApproved || this.isAdmin;
    }


    public void setPassword(String password) {
        this.password = password;
    }

    public String getAccountNumber() {
        return accountNumber;
    }

    public void setAccountNumber(String accountNumber) {
        this.accountNumber = accountNumber;
    }

    public String getIfsCode() {
        return ifsCode;
    }

    public void setIfsCode(String ifsCode) {
        this.ifsCode = ifsCode;
    }

    public String getBranchCode() {
        return branchCode;
    }

    public void setBranchCode(String branchCode) {
        this.branchCode = branchCode;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public String getCustomerId() {
        return customerId;
    }

    public void setCustomerId(String customerId) {
        this.customerId = customerId;
    }

    public boolean isAdmin() {
        return isAdmin;
    }

    public void setAdmin(boolean admin) {
        isAdmin = admin;
    }

    public boolean isApproved() {
        return isApproved;
    }

    public void setApproved(boolean approved) {
        isApproved = approved;
    }
}


--- main\java\com\Banking_Somnath\banking_systemn\model\Employee.java ---
package com.Banking_Somnath.banking_systemn.model;

// --- File: main/java/com/Banking_Somnath/banking_systemn/model/Employee.java --

import jakarta.persistence.*;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.time.LocalDate;
import java.util.Collection;
import java.util.Collections;

@Entity
@Table(name = "employee") // Map to the 'employee' database table
public class Employee implements UserDetails {

    @Id
    @Column(nullable = false, unique = true, length = 50) // Primary Key
    private String employeeId; // This will be the username (e.g., EMP-XXXXXX)

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password; // Hashed password

    @Column(length = 50)
    private String fname;

    @Column(length = 50)
    private String lname;

    @Column(length = 20, unique = true)
    private String mobileNumber;

    @Column(length = 100)
    private String jobTitle;

    private LocalDate hireDate;

    // Flags relevant for UserDetails interface
    @Column(nullable = false, columnDefinition = "BOOLEAN DEFAULT true")
    private boolean accountEnabled = true; // Employees are active once created

    @Column(nullable = false, columnDefinition = "BOOLEAN DEFAULT false")
    private boolean accountLocked = false;

    // --- Default Constructor (Required by JPA) ---
    public Employee() {
    }

    // --- Getters and Setters ---
    // (Generate for all fields: employeeId, email, password, fname, lname, mobileNumber,
    // jobTitle, hireDate, accountEnabled, accountLocked)

    public String getEmployeeId() { return employeeId; }
    public void setEmployeeId(String employeeId) { this.employeeId = employeeId; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getPassword() { return password; } // Getter needed by UserDetails
    public void setPassword(String password) { this.password = password; }
    public String getFname() { return fname; }
    public void setFname(String fname) { this.fname = fname; }
    public String getLname() { return lname; }
    public void setLname(String lname) { this.lname = lname; }
    public String getMobileNumber() { return mobileNumber; }
    public void setMobileNumber(String mobileNumber) { this.mobileNumber = mobileNumber; }
    public String getJobTitle() { return jobTitle; }
    public void setJobTitle(String jobTitle) { this.jobTitle = jobTitle; }
    public LocalDate getHireDate() { return hireDate; }
    public void setHireDate(LocalDate hireDate) { this.hireDate = hireDate; }
    public boolean isAccountEnabled() { return accountEnabled; }
    public void setAccountEnabled(boolean accountEnabled) { this.accountEnabled = accountEnabled; }
    public boolean isAccountLocked() { return accountLocked; }
    public void setAccountLocked(boolean accountLocked) { this.accountLocked = accountLocked; }


    // --- UserDetails Implementation ---

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        // All users in this table are employees
        return Collections.singletonList(new SimpleGrantedAuthority("ROLE_EMPLOYEE"));
    }

    @Override
    public String getUsername() {
        // Spring Security uses this as the unique identifier for login
        return this.employeeId;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true; // Or implement logic if accounts expire
    }

    @Override
    public boolean isAccountNonLocked() {
        return !this.accountLocked; // Use the flag
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true; // Or implement logic if passwords expire
    }

    @Override
    public boolean isEnabled() {
        return this.accountEnabled; // Use the flag
    }
}


--- main\java\com\Banking_Somnath\banking_systemn\model\FixedDeposit.java ---
package com.Banking_Somnath.banking_systemn.model;

import jakarta.persistence.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
public class FixedDeposit {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY) // Link to the customer
    @JoinColumn(name = "customer_obj_mobile_number", referencedColumnName = "mobileNumber", nullable = false)
    private Customer customer; // Store the Customer object directly for easy access to customer details

    @Column(nullable = false)
    private String customerId; // Keep customerId as a direct string reference for simpler querying if needed

    @Column(nullable = false)
    private Double principalAmount;

    @Column(nullable = false)
    private Double interestRate; // Annual interest rate (percentage, e.g., 6.5 for 6.5%)

    @Column(nullable = false)
    private Integer termInMonths;

    private LocalDate startDate; // Date when the FD becomes active (set upon approval)

    private LocalDate maturityDate; // Calculated upon approval based on startDate and term

    private Double maturityAmount; // Calculated total amount customer will receive at maturity

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private FixedDepositStatus status;

    @Column(nullable = false)
    private LocalDateTime applicationDate; // When the customer submitted the request

    private LocalDateTime actionDate; // When admin approved/rejected it

    private String actionByAdminId; // Customer ID of the admin who took action

    @Column(length = 500) // Allow for a decent length rejection reason
    private String rejectionReason; // Reason if status is REJECTED

    @Column(nullable = false, length = 20) // Assuming account numbers are around this length
    private String sourceAccountNumber; // Customer's account from which principal was (or will be) debited

    // --- Constructors ---
    public FixedDeposit() {
        this.applicationDate = LocalDateTime.now();
        this.status = FixedDepositStatus.PENDING; // Default status on creation
    }

    // --- Getters and Setters ---
    // (Generated by IDE for all fields)

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Customer getCustomer() {
        return customer;
    }

    public void setCustomer(Customer customer) {
        this.customer = customer;
    }

    public String getCustomerId() {
        return customerId;
    }

    public void setCustomerId(String customerId) {
        this.customerId = customerId;
    }

    public Double getPrincipalAmount() {
        return principalAmount;
    }

    public void setPrincipalAmount(Double principalAmount) {
        this.principalAmount = principalAmount;
    }

    public Double getInterestRate() {
        return interestRate;
    }

    public void setInterestRate(Double interestRate) {
        this.interestRate = interestRate;
    }

    public Integer getTermInMonths() {
        return termInMonths;
    }

    public void setTermInMonths(Integer termInMonths) {
        this.termInMonths = termInMonths;
    }

    public LocalDate getStartDate() {
        return startDate;
    }

    public void setStartDate(LocalDate startDate) {
        this.startDate = startDate;
    }

    public LocalDate getMaturityDate() {
        return maturityDate;
    }

    public void setMaturityDate(LocalDate maturityDate) {
        this.maturityDate = maturityDate;
    }

    public Double getMaturityAmount() {
        return maturityAmount;
    }

    public void setMaturityAmount(Double maturityAmount) {
        this.maturityAmount = maturityAmount;
    }

    public FixedDepositStatus getStatus() {
        return status;
    }

    public void setStatus(FixedDepositStatus status) {
        this.status = status;
    }

    public LocalDateTime getApplicationDate() {
        return applicationDate;
    }

    public void setApplicationDate(LocalDateTime applicationDate) {
        this.applicationDate = applicationDate;
    }

    public LocalDateTime getActionDate() {
        return actionDate;
    }

    public void setActionDate(LocalDateTime actionDate) {
        this.actionDate = actionDate;
    }

    public String getActionByAdminId() {
        return actionByAdminId;
    }

    public void setActionByAdminId(String actionByAdminId) {
        this.actionByAdminId = actionByAdminId;
    }

    public String getRejectionReason() {
        return rejectionReason;
    }

    public void setRejectionReason(String rejectionReason) {
        this.rejectionReason = rejectionReason;
    }

    public String getSourceAccountNumber() {
        return sourceAccountNumber;
    }

    public void setSourceAccountNumber(String sourceAccountNumber) {
        this.sourceAccountNumber = sourceAccountNumber;
    }
}

--- main\java\com\Banking_Somnath\banking_systemn\model\FixedDepositStatus.java ---
package com.Banking_Somnath.banking_systemn.model;

public enum FixedDepositStatus {
    PENDING,    // Application submitted by customer, awaiting admin approval
    ACTIVE,     // Approved by admin, FD is running, principal debited
    REJECTED,   // Application rejected by admin
    MATURED,    // Term completed, awaiting payout (or auto-payout)
    CLOSED      // Prematurely closed by customer (optional, involves penalty logic)
}

--- main\java\com\Banking_Somnath\banking_systemn\model\JobApplication.java ---
package com.Banking_Somnath.banking_systemn.model;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
public class JobApplication {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String applicantFirstName;

    @Column(nullable = false)
    private String applicantLastName;

    @Column(nullable = false, unique = true) // Ensure email is unique for applications? Maybe not.
    private String applicantEmail;

    @Column(nullable = false)
    private String applicantPhone;

    @Lob // For potentially long text
    @Column(columnDefinition = "TEXT")
    private String qualifications;

    @Lob
    @Column(columnDefinition = "TEXT")
    private String experience;

    private String desiredRole;
    private String resumeLink; // Optional link to external resume

    @Column(nullable = false)
    private LocalDateTime applicationDate;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private ApplicationStatus status;

    private String reviewerAdminId; // Customer ID of the admin who reviewed/actioned
    private LocalDateTime interviewDate;

    @Lob
    @Column(columnDefinition = "TEXT")
    private String adminNotes;

    // --- Constructors ---
    public JobApplication() {
        this.applicationDate = LocalDateTime.now();
        this.status = ApplicationStatus.PENDING;
    }

    // --- Getters and Setters ---
    // (Generate using IDE)

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getApplicantFirstName() { return applicantFirstName; }
    public void setApplicantFirstName(String applicantFirstName) { this.applicantFirstName = applicantFirstName; }
    public String getApplicantLastName() { return applicantLastName; }
    public void setApplicantLastName(String applicantLastName) { this.applicantLastName = applicantLastName; }
    public String getApplicantEmail() { return applicantEmail; }
    public void setApplicantEmail(String applicantEmail) { this.applicantEmail = applicantEmail; }
    public String getApplicantPhone() { return applicantPhone; }
    public void setApplicantPhone(String applicantPhone) { this.applicantPhone = applicantPhone; }
    public String getQualifications() { return qualifications; }
    public void setQualifications(String qualifications) { this.qualifications = qualifications; }
    public String getExperience() { return experience; }
    public void setExperience(String experience) { this.experience = experience; }
    public String getDesiredRole() { return desiredRole; }
    public void setDesiredRole(String desiredRole) { this.desiredRole = desiredRole; }
    public String getResumeLink() { return resumeLink; }
    public void setResumeLink(String resumeLink) { this.resumeLink = resumeLink; }
    public LocalDateTime getApplicationDate() { return applicationDate; }
    public void setApplicationDate(LocalDateTime applicationDate) { this.applicationDate = applicationDate; }
    public ApplicationStatus getStatus() { return status; }
    public void setStatus(ApplicationStatus status) { this.status = status; }
    public String getReviewerAdminId() { return reviewerAdminId; }
    public void setReviewerAdminId(String reviewerAdminId) { this.reviewerAdminId = reviewerAdminId; }
    public LocalDateTime getInterviewDate() { return interviewDate; }
    public void setInterviewDate(LocalDateTime interviewDate) { this.interviewDate = interviewDate; }
    public String getAdminNotes() { return adminNotes; }
    public void setAdminNotes(String adminNotes) { this.adminNotes = adminNotes; }
}


--- main\java\com\Banking_Somnath\banking_systemn\model\LoanApplication.java ---
package com.Banking_Somnath.banking_systemn.model;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
public class LoanApplication {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String customerId; // Links to Customer

    @Column(nullable = false, length = 50) // Limit length
    private String loanType; // E.g., "PERSONAL", "HOME", "CAR"

    @Column(nullable = false)
    private Double requestedAmount;

    @Column(nullable = false)
    private Integer termInMonths;

    @Lob // For potentially long text like purpose description
    @Column(columnDefinition = "TEXT", nullable = false)
    private String purpose;

    @Column(nullable = false)
    private LocalDateTime applicationDate;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private LoanApplicationStatus status;

    // --- Fields populated by Admin ---
    private Double approvedAmount;      // Set on approval
    private Double interestRate;        // Set on approval (annual rate %)
    private LocalDateTime approvalDate; // Set on approval
    private String approvedByAdminId;   // Admin who took action (approve/reject)
    private String rejectionReason;     // Set on rejection

    // --- Optional fields provided by customer ---
    private Double monthlyIncome;
    @Column(length = 50)
    private String employmentStatus; // E.g., "Salaried", "Self-Employed"

    // --- Constructors ---
    public LoanApplication() {
        this.applicationDate = LocalDateTime.now();
        this.status = LoanApplicationStatus.PENDING; // Default status
    }

    // --- Getters and Setters (Generated by IDE) ---

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getCustomerId() {
        return customerId;
    }

    public void setCustomerId(String customerId) {
        this.customerId = customerId;
    }

    public String getLoanType() {
        return loanType;
    }

    public void setLoanType(String loanType) {
        this.loanType = loanType;
    }

    public Double getRequestedAmount() {
        return requestedAmount;
    }

    public void setRequestedAmount(Double requestedAmount) {
        this.requestedAmount = requestedAmount;
    }

    public Integer getTermInMonths() {
        return termInMonths;
    }

    public void setTermInMonths(Integer termInMonths) {
        this.termInMonths = termInMonths;
    }

    public String getPurpose() {
        return purpose;
    }

    public void setPurpose(String purpose) {
        this.purpose = purpose;
    }

    public LocalDateTime getApplicationDate() {
        return applicationDate;
    }

    public void setApplicationDate(LocalDateTime applicationDate) {
        this.applicationDate = applicationDate;
    }

    public LoanApplicationStatus getStatus() {
        return status;
    }

    public void setStatus(LoanApplicationStatus status) {
        this.status = status;
    }

    public Double getApprovedAmount() {
        return approvedAmount;
    }

    public void setApprovedAmount(Double approvedAmount) {
        this.approvedAmount = approvedAmount;
    }

    public Double getInterestRate() {
        return interestRate;
    }

    public void setInterestRate(Double interestRate) {
        this.interestRate = interestRate;
    }

    public LocalDateTime getApprovalDate() {
        return approvalDate;
    }

    public void setApprovalDate(LocalDateTime approvalDate) {
        this.approvalDate = approvalDate;
    }

    public String getApprovedByAdminId() {
        return approvedByAdminId;
    }

    public void setApprovedByAdminId(String approvedByAdminId) {
        this.approvedByAdminId = approvedByAdminId;
    }

    public String getRejectionReason() {
        return rejectionReason;
    }

    public void setRejectionReason(String rejectionReason) {
        this.rejectionReason = rejectionReason;
    }

    public Double getMonthlyIncome() {
        return monthlyIncome;
    }

    public void setMonthlyIncome(Double monthlyIncome) {
        this.monthlyIncome = monthlyIncome;
    }

    public String getEmploymentStatus() {
        return employmentStatus;
    }

    public void setEmploymentStatus(String employmentStatus) {
        this.employmentStatus = employmentStatus;
    }
}

--- main\java\com\Banking_Somnath\banking_systemn\model\LoanApplicationStatus.java ---
package com.Banking_Somnath.banking_systemn.model;

// Statuses for the loan application lifecycle
public enum LoanApplicationStatus {
    PENDING,        // Submitted, needs admin action
    UNDER_REVIEW,   // Optional: Admin is actively reviewing
    APPROVED,       // Approved, pending disbursement (disbursement is a separate future step)
    REJECTED,       // Application denied
    DISBURSED,      // Funds given to customer (Future State)
    CLOSED          // Loan fully repaid (Future State)
}

--- main\java\com\Banking_Somnath\banking_systemn\model\Transaction.java ---
package com.Banking_Somnath.banking_systemn.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
public class Transaction {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(nullable = false,unique = true)
    private String customerId;
    @Column(nullable = true)
    private String mobileNo;
    private double balance;
    private String description;
    private LocalDateTime localDateTime;
    private String senderAccountNumber;  // Account Number for the sender
    private String recipientAccountNumber;  // Account Number for the recipient
    private String branchCode;  // Branch Code relevant to the transaction (could be sender's or receiver's bank/branch)
    private String ifscCode;    // IFSC Code relevant to the transaction
    private String senderMobileNo;
    private String recipientMobileNo;
    private String type;
    public Transaction() {
    }

    public Transaction(Long id, String mobileNo,
                       String customerId,
                       double balance, String description, LocalDateTime localDateTime, String senderAccountNumber, String recipientAccountNumber, String branchCode, String ifscCode, String senderMobileNo, String recipientMobileNo, String type) {
        this.id = id;
        this.mobileNo = mobileNo;
        this.balance = balance;
        this.description = description;
        this.localDateTime = localDateTime;
        this.senderAccountNumber = senderAccountNumber;
        this.recipientAccountNumber = recipientAccountNumber;
        this.branchCode = branchCode;
        this.ifscCode = ifscCode;
        this.senderMobileNo = senderMobileNo;
        this.recipientMobileNo = recipientMobileNo;
        this.type = type;
        this.customerId=customerId;
    }

    public String getCustomerId(){
        return customerId;
    }

    public void setCustomerId(String customerId) {
        this.customerId = customerId;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getMobileNo() {
        return mobileNo;
    }

    public void setMobileNo(String mobileNo) {
        this.mobileNo = mobileNo;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public LocalDateTime getLocalDateTime() {
        return localDateTime;
    }

    public void setLocalDateTime(LocalDateTime localDateTime) {
        this.localDateTime = localDateTime;
    }

    public String getSenderAccountNumber() {
        return senderAccountNumber;
    }

    public void setSenderAccountNumber(String senderAccountNumber) {
        this.senderAccountNumber = senderAccountNumber;
    }

    public String getRecipientAccountNumber() {
        return recipientAccountNumber;
    }

    public void setRecipientAccountNumber(String recipientAccountNumber) {
        this.recipientAccountNumber = recipientAccountNumber;
    }

    public String getBranchCode() {
        return branchCode;
    }

    public void setBranchCode(String branchCode) {
        this.branchCode = branchCode;
    }

    public String getIfscCode() {
        return ifscCode;
    }

    public void setIfscCode(String ifscCode) {
        this.ifscCode = ifscCode;
    }

    public String getSenderMobileNo() {
        return senderMobileNo;
    }

    public void setSenderMobileNo(String senderMobileNo) {
        this.senderMobileNo = senderMobileNo;
    }

    public String getRecipientMobileNo() {
        return recipientMobileNo;
    }

    public void setRecipientMobileNo(String recipientMobileNo) {
        this.recipientMobileNo = recipientMobileNo;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }
}


--- main\java\com\Banking_Somnath\banking_systemn\repository\CustomerRepository.java ---
package com.Banking_Somnath.banking_systemn.repository;

import com.Banking_Somnath.banking_systemn.model.Customer;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface CustomerRepository extends JpaRepository<Customer, String> {
    Optional<Customer> findByEmail(String email);
    Optional<Customer> findByMobileNumber(String mobileNumber);
    Optional<Customer> findByCustomerId(String customerId);
    List<Customer> findByIsApproved(boolean isApproved); // Find by customer by their approval status
    Optional<Customer> findByCustomerIdAndMobileNumber(String customerId, String mobileNumber);

}


--- main\java\com\Banking_Somnath\banking_systemn\repository\EmployeeRepository.java ---

// --- File: main/java/com/Banking_Somnath/banking_systemn/repository/EmployeeRepository.java ---
package com.Banking_Somnath.banking_systemn.repository;

import com.Banking_Somnath.banking_systemn.model.Employee;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, String> { // Primary Key is String

    // Find by the primary key / username
    Optional<Employee> findByEmployeeId(String employeeId);

    // Find by email (for checks)
    Optional<Employee> findByEmail(String email);

    // Find by mobile (for checks)
    Optional<Employee> findByMobileNumber(String mobileNumber);

}

--- main\java\com\Banking_Somnath\banking_systemn\repository\FixedDepositRepository.java ---
package com.Banking_Somnath.banking_systemn.repository;// In main\java\com\Banking_Somnath\banking_systemn\repository\FixedDepositRepository.java
// Add these imports if not already present:
import com.Banking_Somnath.banking_systemn.model.FixedDeposit;
import com.Banking_Somnath.banking_systemn.model.FixedDepositStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
// ... other imports ...

@Repository
public interface FixedDepositRepository extends JpaRepository<FixedDeposit, Long> {
    // ... your existing methods ...

    // Replace or add this method for fetching pending FDs with their customers
    @Query("SELECT fd FROM FixedDeposit fd JOIN FETCH fd.customer c WHERE fd.status = :status ORDER BY fd.applicationDate ASC")
    List<FixedDeposit> findByStatusWithCustomerOrderByApplicationDateAsc(@Param("status") FixedDepositStatus status);
}






--- main\java\com\Banking_Somnath\banking_systemn\repository\JobApplicationRepository.java ---
package com.Banking_Somnath.banking_systemn.repository;

import com.Banking_Somnath.banking_systemn.model.ApplicationStatus;
import com.Banking_Somnath.banking_systemn.model.JobApplication;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface JobApplicationRepository  extends JpaRepository<JobApplication , Long> {
    List<JobApplication> findByStatusOrderByApplicationDateDesc(ApplicationStatus status);
    List<JobApplication> findAllByOrderByApplicationDateDesc();
}


--- main\java\com\Banking_Somnath\banking_systemn\repository\LoanApplicationRepository.java ---
package com.Banking_Somnath.banking_systemn.repository;

import com.Banking_Somnath.banking_systemn.model.LoanApplication;
import com.Banking_Somnath.banking_systemn.model.LoanApplicationStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface LoanApplicationRepository extends JpaRepository<LoanApplication, Long> {

    // Find all loan applications for a specific customer, ordered by application date descending
    List<LoanApplication> findByCustomerIdOrderByApplicationDateDesc(String customerId);

    // Find all loan applications with a specific status (or multiple statuses)
    // Order by application date ascending so oldest pending are seen first by admin
    List<LoanApplication> findByStatusInOrderByApplicationDateAsc(List<LoanApplicationStatus> statuses);

    // Specific finder if only pending needed often
    List<LoanApplication> findByStatusOrderByApplicationDateAsc(LoanApplicationStatus status);
}

--- main\java\com\Banking_Somnath\banking_systemn\repository\TransactionRepository.java ---
package com.Banking_Somnath.banking_systemn.repository;

import com.Banking_Somnath.banking_systemn.model.Transaction;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface TransactionRepository extends JpaRepository<Transaction, Long> {
    List<Transaction> findByCustomerIdAndLocalDateTimeBetweenOrderByLocalDateTimeDesc(
            String customerId,
            LocalDateTime startDateTime,
            LocalDateTime endDateTime
    );
}


--- main\java\com\Banking_Somnath\banking_systemn\request\ApproveLoanRequest.java ---
package com.Banking_Somnath.banking_systemn.request;

// Add validation later: @NotNull, @DecimalMin
// import jakarta.validation.constraints.*;

public class ApproveLoanRequest {

    // @NotNull(message = "Approved amount is required")
    // @DecimalMin(value = "1.00", message = "Approved amount must be positive")
    private Double approvedAmount;

    // @NotNull(message = "Interest rate is required")
    // @DecimalMin(value = "0.1", message = "Interest rate must be positive") // e.g., 0.1% minimum
    // @DecimalMax(value = "30.0", message = "Interest rate seems too high (max 30%)") // Example limit
    private Double interestRate;

    // Getters and Setters (Generated by IDE)

    public Double getApprovedAmount() {
        return approvedAmount;
    }

    public void setApprovedAmount(Double approvedAmount) {
        this.approvedAmount = approvedAmount;
    }

    public Double getInterestRate() {
        return interestRate;
    }

    public void setInterestRate(Double interestRate) {
        this.interestRate = interestRate;
    }
}

--- main\java\com\Banking_Somnath\banking_systemn\request\CheckBalanceRequest.java ---
package com.Banking_Somnath.banking_systemn.request;

import jakarta.persistence.Id;

public class CheckBalanceRequest {
    @Id
    private String customerId;
    private String email;
    private double balance;

    public CheckBalanceRequest(String customerId, String email, double balance) {
        this.customerId = customerId;
        this.email = email;
        this.balance = balance;
    }

    public String getCustomerId() {
        return customerId;
    }

    public void setCustomerId(String customerId) {
        this.customerId = customerId;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }
}


--- main\java\com\Banking_Somnath\banking_systemn\request\CreateFdRequest.java ---
package com.Banking_Somnath.banking_systemn.request;

// You can add JSR 303 validation annotations here later if needed
// import jakarta.validation.constraints.*;

public class CreateFdRequest {

    // @NotNull(message = "Principal amount is required.")
    // @DecimalMin(value = "1000.00", inclusive = true, message = "Minimum FD amount must be ₹1,000.00 or more.")
    private Double principalAmount;

    // @NotNull(message = "Term in months is required.")
    // @Min(value = 1, message = "Minimum term for an FD is 1 month.")
    // @Max(value = 120, message = "Maximum term for an FD is 120 months (10 years).") // Example maximum
    private Integer termInMonths;

    // Getters and Setters
    public Double getPrincipalAmount() {
        return principalAmount;
    }

    public void setPrincipalAmount(Double principalAmount) {
        this.principalAmount = principalAmount;
    }

    public Integer getTermInMonths() {
        return termInMonths;
    }

    public void setTermInMonths(Integer termInMonths) {
        this.termInMonths = termInMonths;
    }
}

--- main\java\com\Banking_Somnath\banking_systemn\request\CreateLoanRequest.java ---
package com.Banking_Somnath.banking_systemn.request;

// Add validation later: @NotBlank, @NotNull, @Min, @Max etc.
// import jakarta.validation.constraints.*;

public class CreateLoanRequest {

    // @NotBlank(message = "Loan type is required")
    private String loanType;

    // @NotNull(message = "Requested amount is required")
    // @DecimalMin(value = "1000.00", message = "Minimum loan amount is ₹1000")
    private Double requestedAmount;

    // @NotNull(message = "Term in months is required")
    // @Min(value = 6, message = "Minimum term is 6 months")
    // @Max(value = 120, message = "Maximum term is 120 months") // Example limits
    private Integer termInMonths;

    // @NotBlank(message = "Purpose of the loan is required")
    // @Size(max = 1000, message = "Purpose description is too long (max 1000 chars)")
    private String purpose;

    // Optional fields
    private Double monthlyIncome;
    private String employmentStatus;

    // Getters and Setters (Generated by IDE)

    public String getLoanType() {
        return loanType;
    }

    public void setLoanType(String loanType) {
        this.loanType = loanType;
    }

    public Double getRequestedAmount() {
        return requestedAmount;
    }

    public void setRequestedAmount(Double requestedAmount) {
        this.requestedAmount = requestedAmount;
    }

    public Integer getTermInMonths() {
        return termInMonths;
    }

    public void setTermInMonths(Integer termInMonths) {
        this.termInMonths = termInMonths;
    }

    public String getPurpose() {
        return purpose;
    }

    public void setPurpose(String purpose) {
        this.purpose = purpose;
    }

    public Double getMonthlyIncome() {
        return monthlyIncome;
    }

    public void setMonthlyIncome(Double monthlyIncome) {
        this.monthlyIncome = monthlyIncome;
    }

    public String getEmploymentStatus() {
        return employmentStatus;
    }

    public void setEmploymentStatus(String employmentStatus) {
        this.employmentStatus = employmentStatus;
    }
}

--- main\java\com\Banking_Somnath\banking_systemn\request\DepositRequest.java ---
package com.Banking_Somnath.banking_systemn.request;

public class DepositRequest {
    private String mobileNo;
    private String accountNo;
    private double amount;

    public String getMobileNo() {
        return mobileNo;
    }

    public void setMobileNo(String mobileNo) {
        this.mobileNo = mobileNo;
    }

    public double getAmount() {
        return amount;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }

    public String getAccountNo() {
        return accountNo;
    }

    public void setAccountNo(String accountNo) {
        this.accountNo = accountNo;
    }
}


--- main\java\com\Banking_Somnath\banking_systemn\request\EmployeeActionRequest.java ---
package com.Banking_Somnath.banking_systemn.request;

// Base class or just use specific DTOs if fields differ significantly
public class EmployeeActionRequest {
    // Fields needed by specific actions (e.g., target customer identifier, amount)
    // Example:
    private String targetCustomerId; // Can be Customer ID or Account Number
    private double amount;

    // Getters and Setters
    public String getTargetCustomerId() {
        return targetCustomerId;
    }

    public void setTargetCustomerId(String targetCustomerId) {
        this.targetCustomerId = targetCustomerId;
    }

    public double getAmount() {
        return amount;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }
}

--- main\java\com\Banking_Somnath\banking_systemn\request\JobApplicationRequest.java ---
package com.Banking_Somnath.banking_systemn.request;

public class JobApplicationRequest {

    // Use validation annotations if you add the dependency: spring-boot-starter-validation
    // @NotBlank(message = "First name is required")
    private String applicantFirstName;

    // @NotBlank(message = "Last name is required")
    private String applicantLastName;

    // @NotBlank(message = "Email is required")
    // @Email(message = "Invalid email format")
    private String applicantEmail;

    // @NotBlank(message = "Phone number is required")
    // @Size(min = 10, max = 15, message = "Phone number must be between 10 and 15 digits") // Adjust size as needed
    private String applicantPhone;

    // @NotBlank(message = "Qualifications are required")
    private String qualifications; // Can be a longer text description

    private String experience; // Optional field, can be longer text

    // @NotBlank(message = "Desired role is required")
    private String desiredRole;

    private String resumeLink; // Optional link to an online resume (e.g., LinkedIn, Google Drive)

    // --- Default Constructor (Needed for frameworks like Jackson) ---
    public JobApplicationRequest() {
    }

    // --- Getters ---
    public String getApplicantFirstName() {
        return applicantFirstName;
    }

    public String getApplicantLastName() {
        return applicantLastName;
    }

    public String getApplicantEmail() {
        return applicantEmail;
    }

    public String getApplicantPhone() {
        return applicantPhone;
    }

    public String getQualifications() {
        return qualifications;
    }

    public String getExperience() {
        return experience;
    }

    public String getDesiredRole() {
        return desiredRole;
    }

    public String getResumeLink() {
        return resumeLink;
    }

    // --- Setters ---
    public void setApplicantFirstName(String applicantFirstName) {
        this.applicantFirstName = applicantFirstName;
    }

    public void setApplicantLastName(String applicantLastName) {
        this.applicantLastName = applicantLastName;
    }

    public void setApplicantEmail(String applicantEmail) {
        this.applicantEmail = applicantEmail;
    }

    public void setApplicantPhone(String applicantPhone) {
        this.applicantPhone = applicantPhone;
    }

    public void setQualifications(String qualifications) {
        this.qualifications = qualifications;
    }

    public void setExperience(String experience) {
        this.experience = experience;
    }

    public void setDesiredRole(String desiredRole) {
        this.desiredRole = desiredRole;
    }

    public void setResumeLink(String resumeLink) {
        this.resumeLink = resumeLink;
    }
}

--- main\java\com\Banking_Somnath\banking_systemn\request\LoginRequest.java ---
package com.Banking_Somnath.banking_systemn.request;

public class LoginRequest {
    private String mobileNumber;
    private String customerId;
    private String password;

    public LoginRequest(){

    }

    public LoginRequest(String mobileNumber, String password, String customerID) {
        this.mobileNumber = mobileNumber;
        this.password = password;
        this.customerId = customerID;
    }

    public String getMobileNumber() {
        return mobileNumber;
    }

    public void setMobileNumber(String mobileNumber) {
        this.mobileNumber = mobileNumber;
    }

    public String getCustomerId() {
        return customerId;
    }

    public void setCustomerId(String customerId) {
        this.customerId = customerId;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}


--- main\java\com\Banking_Somnath\banking_systemn\request\RejectApplicationRequest.java ---
package com.Banking_Somnath.banking_systemn.request;
// Possibly add @NotBlank
// import jakarta.validation.constraints.NotBlank;

public class RejectApplicationRequest {

    // @NotBlank(message = "Rejection reason cannot be blank")
    private String reason;

    // Getters and Setters
    public String getReason() {
        return reason;
    }

    public void setReason(String reason) {
        this.reason = reason;
    }
}


--- main\java\com\Banking_Somnath\banking_systemn\request\RejectRequest.java ---
package com.Banking_Somnath.banking_systemn.request;

// Assuming this is generic enough for Loans, FDs, Job Apps etc.
// Add validation later: @NotBlank
// import jakarta.validation.constraints.*;

public class RejectRequest {

    // @NotBlank(message = "Rejection reason cannot be blank")
    private String reason;

    // Getters and Setters (Generated by IDE)
    public String getReason() {
        return reason;
    }

    public void setReason(String reason) {
        this.reason = reason;
    }
}

--- main\java\com\Banking_Somnath\banking_systemn\request\RejectRequestForFd.java ---
package com.Banking_Somnath.banking_systemn.request;

// This DTO can be used for rejecting various types of applications (FD, Loan, Job etc.)
// if the only required field is a reason.
// import jakarta.validation.constraints.*;

public class RejectRequestForFd {

    // @NotBlank(message = "Rejection reason cannot be blank.")
    // @Size(min = 5, max = 500, message = "Rejection reason must be between 5 and 500 characters.")
    private String reason;

    // Getters and Setters
    public String getReason() {
        return reason;
    }

    public void setReason(String reason) {
        this.reason = reason;
    }
}

--- main\java\com\Banking_Somnath\banking_systemn\request\ScheduleInterviewRequest.java ---
package com.Banking_Somnath.banking_systemn.request;

import java.time.LocalDateTime;
public class ScheduleInterviewRequest {


    private LocalDateTime interviewDate;

    // Getters and Setters
    public LocalDateTime getInterviewDate() {
        return interviewDate;
    }

    public void setInterviewDate(LocalDateTime interviewDate) {
        this.interviewDate = interviewDate;
    }
}


--- main\java\com\Banking_Somnath\banking_systemn\request\TransactionHistoryRequest.java ---
package com.Banking_Somnath.banking_systemn.request;

public class TransactionHistoryRequest {
}


--- main\java\com\Banking_Somnath\banking_systemn\request\TransferMoney.java ---
package com.Banking_Somnath.banking_systemn.request;


public class TransferMoney {
    private double amount;
//    private String senderPassword; // Name it clearly to avoid confusion
    private String receiverCustomerId;
    private String receiverMobileNo;

    // Getters and Setters (Generate these using your IDE or manually)

    public double getAmount() {
        return amount;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }

//    public String getSenderPassword() {
//        return senderPassword;
//    }

//    public void setSenderPassword(String senderPassword) {
//        this.senderPassword = senderPassword;
//    }

    public String getReceiverCustomerId() {
        return receiverCustomerId;
    }

    public void setReceiverCustomerId(String receiverCustomerId) {
        this.receiverCustomerId = receiverCustomerId;
    }

    public String getReceiverMobileNo() {
        return receiverMobileNo;
    }

    public void setReceiverMobileNo(String receiverMobileNo) {
        this.receiverMobileNo = receiverMobileNo;
    }
}



--- main\java\com\Banking_Somnath\banking_systemn\request\WithdrawRequest.java ---
package com.Banking_Somnath.banking_systemn.request;

public class WithdrawRequest {
    private String mobileNo;
    private String accountNo;
    private double amount;
    private String password;

    public String getMobileNo() {
        return mobileNo;
    }

    public void setMobileNo(String mobileNo) {
        this.mobileNo = mobileNo;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public double getAmount() {
        return amount;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }

    public String getAccountNo() {
        return accountNo;
    }

    public void setAccountNo(String accountNo) {
        this.accountNo = accountNo;
    }
}


--- main\java\com\Banking_Somnath\banking_systemn\response\BalanceResponse.java ---
package com.Banking_Somnath.banking_systemn.response;

import org.springframework.web.bind.annotation.ResponseStatus;

public class BalanceResponse {
    private boolean success;
    private String balance;

    public BalanceResponse(boolean success, String balance) {
        this.success = success;
        this.balance = balance;
    }

    // Getters and setters
    public boolean isSuccess() {
        return success;
    }

    public void setSuccess(boolean success) {
        this.success = success;
    }

    public String getBalance() {
        return balance;
    }

    public void setBalance(String balance) {
        this.balance = balance;
    }
}


--- main\java\com\Banking_Somnath\banking_systemn\security\CustomUserDetailsService.java ---
package com.Banking_Somnath.banking_systemn.security;

import com.Banking_Somnath.banking_systemn.model.Customer; // Keep Customer
import com.Banking_Somnath.banking_systemn.model.Employee; // *** ADD Import for Employee ***
import com.Banking_Somnath.banking_systemn.repository.CustomerRepository; // Keep CustomerRepository
import com.Banking_Somnath.banking_systemn.repository.EmployeeRepository; // *** ADD Import for EmployeeRepository ***

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails; // Spring Security interface
import org.springframework.security.core.userdetails.UserDetailsService; // Spring Security interface
import org.springframework.security.core.userdetails.UsernameNotFoundException; // Standard exception
import org.springframework.stereotype.Service; // Mark this as a Spring service bean

import java.util.Optional; // Keep Optional

@Service // This annotation makes the class a Spring-managed bean
public class CustomUserDetailsService implements UserDetailsService {

    @Autowired // Inject the Customer repository
    private CustomerRepository customerRepository;

    // *** ADD Autowire for EmployeeRepository ***
    @Autowired
    private EmployeeRepository employeeRepository;

    @Override // Marks this method as implementing the one from UserDetailsService interface
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {

        System.out.println("Attempting to load user by username/ID: " + username); // Original log

        if (username == null || username.isBlank()) {
            System.out.println("Error: Username cannot be empty."); // Log similar to original
            throw new UsernameNotFoundException("Username cannot be empty.");
        }

        // --- START: Updated Logic to Check Both Repositories ---
        if (username.startsWith("EMP-")) {
            // Try loading as an Employee
            System.out.println("Username starts with EMP-, attempting to load as Employee.");
            // Find by employeeId and cast Optional<Employee> to Optional<UserDetails> before returning or throwing
            return employeeRepository.findByEmployeeId(username)
                    .map(employee -> {
                        System.out.println("Employee found: " + employee.getUsername() + ", Enabled: " + employee.isEnabled()); // Log similar to original
                        return (UserDetails) employee; // Return Employee as UserDetails
                    })
                    .orElseThrow(() -> {
                        System.out.println("Employee not found with ID: " + username); // Log similar to original
                        return new UsernameNotFoundException("Employee not found with ID: " + username);
                    });

        } else if (username.startsWith("CUST-") || username.startsWith("ADMIN-")) {
            // Try loading as a Customer (or Admin stored in Customer table)
            System.out.println("Username starts with CUST- or ADMIN-, attempting to load as Customer.");
            // Find by customerId and cast Optional<Customer> to Optional<UserDetails>
            return customerRepository.findByCustomerId(username)
                    .map(customer -> {
                        System.out.println("Customer/Admin found: " + customer.getUsername() + ", Enabled: " + customer.isEnabled()); // Log similar to original
                        return (UserDetails) customer; // Return Customer as UserDetails
                    })
                    .orElseThrow(() -> {
                        System.out.println("Customer/Admin not found with ID: " + username); // Log similar to original
                        return new UsernameNotFoundException("Customer/Admin not found with ID: " + username);
                    });
        } else {
            // If prefix doesn't match expected formats
            System.out.println("Username '" + username + "' does not match expected prefixes (CUST-/EMP-/ADMIN-)"); // Log similar to original
            throw new UsernameNotFoundException("User not found or invalid ID format: " + username);
        }
        // --- END: Updated Logic ---
    }
}

--- main\java\com\Banking_Somnath\banking_systemn\service\AdminService.java ---
package com.Banking_Somnath.banking_systemn.service;

import com.Banking_Somnath.banking_systemn.model.Customer;
import com.Banking_Somnath.banking_systemn.model.JobApplication;
import com.Banking_Somnath.banking_systemn.repository.CustomerRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
public class AdminService {
    private static final Logger log = LoggerFactory.getLogger(CustomerService.class);

    @Autowired
    JobApplicationService jobApplicationService;
    @Autowired
    private CustomerRepository customerRepository;

    @Transactional(readOnly = true)
    public List<Customer> findPendingRegistrations() {
        return customerRepository.findByIsApproved(false);
    }

    @Transactional
    public String approveRegistration(String customerId) {
        Optional<Customer> optionalCustomer = customerRepository.findByCustomerId(customerId);

        if (optionalCustomer.isEmpty()) {
            return "Customer not found with ID: " + customerId;
        }

        Customer customer = optionalCustomer.get();

        if (customer.isApproved()) {
            return "Customer with ID: " + customerId + " is already approved.";
        }

        customer.setApproved(true);
        customerRepository.save(customer);

        return "Customer with ID: " + customerId + " successfully approved.";
    }

    @Transactional
    public String rejectRegistration(String customerId) {
        Optional<Customer> optionalCustomer = customerRepository.findByCustomerId(customerId);

        if (optionalCustomer.isEmpty()) {
            return "Customer not found with ID: " + customerId;
        }

        Customer customer = optionalCustomer.get();
        customerRepository.delete(customer);

        return "Customer with ID: " + customerId + " successfully rejected and removed.";
    }

    @Transactional(readOnly = true)
    public List<JobApplication> getAllJobApplications() {
        log.info("Admin fetching all job applications");
        return jobApplicationService.getAllApplications();
    }

    @Transactional(readOnly = true)
    public Optional<JobApplication> getJobApplicationDetails(Long appId) {
        log.info("Admin fetching details for job application ID: {}", appId);
        return jobApplicationService.getApplicationById(appId);
    }

    @Transactional
    public JobApplication scheduleJobInterview(Long appId, LocalDateTime interviewDate, String adminId) {
        log.info("Admin {} scheduling interview for application ID: {} on {}", adminId, appId, interviewDate);
        return jobApplicationService.scheduleInterview(appId, interviewDate, adminId);
    }

    @Transactional
    public JobApplication rejectJobApplication(Long appId, String reason, String adminId) {
        log.info("Admin {} rejecting application ID: {} with reason: {}", adminId, appId, reason);
        return jobApplicationService.rejectApplication(appId, reason, adminId);
    }

    @Transactional
    public JobApplication hireApplicant(Long appId, String adminId) {
        // Note: Initial password handling strategy is within JobApplicationService -> CustomerService
        log.info("Admin {} initiating hire process for application ID: {}", adminId, appId);
        return jobApplicationService.approveHire(appId, adminId);
    }
}


--- main\java\com\Banking_Somnath\banking_systemn\service\CustomerService.java ---
package com.Banking_Somnath.banking_systemn.service;

import com.Banking_Somnath.banking_systemn.model.Employee;
import com.Banking_Somnath.banking_systemn.model.JobApplication;
import com.Banking_Somnath.banking_systemn.repository.CustomerRepository;
import com.Banking_Somnath.banking_systemn.repository.EmployeeRepository;
import com.Banking_Somnath.banking_systemn.request.LoginRequest;
import com.Banking_Somnath.banking_systemn.model.Customer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.Optional;
import java.util.UUID;

@Service
public class CustomerService {


    private static final Logger log = LoggerFactory.getLogger(CustomerService.class);
    @Autowired
    CustomerRepository customerRepository;

    @Autowired
    EmployeeRepository employeeRepository;

    @Autowired
    PasswordEncoder passwordEncoder; // <<< Autowire the PasswordEncoder bean from SecurityConfig


    public Customer generateBankDetails(Customer customer) {

        String customerId;
        do {
            customerId = "CUST-" + UUID.randomUUID().toString().substring(0, 8).toUpperCase();
        } while (customerRepository.findByCustomerId(customerId).isPresent());
        customer.setCustomerId(customerId);

        // Example Bank Prefix and Branch Code
        String bankCode = "333";              // MEEWOO internal code
        String branchCode = "3355";           // Example Kalyani Branch
        String accountSerial = String.valueOf((long)(Math.random() * 1000000L));  // 6-digit serial

        // Format: bankCode + branchCode + serial (total 12 digits)
        String accountNumber = bankCode + branchCode + String.format("%06d", Long.parseLong(accountSerial));

        // Format: MEWO + 0 + BranchCode
        String ifscCode = "MEWO" + branchCode;


        // Set generated values
        customer.setAccountNumber(accountNumber);
        customer.setIfsCode(ifscCode);
        customer.setBranchCode(branchCode);

        customer.setPassword(passwordEncoder.encode(customer.getPassword()));
        customer.setApproved(false); // this for account are pending for approval
        customer.setAdmin(false); // this is for this user not admin

        return customer;  // Return the updated customer object
    }



    @Transactional
    public Customer register(Customer customer) {
        // Check for duplicates
        if (customerRepository.findByMobileNumber(customer.getMobileNumber()).isPresent()) {
            throw new RuntimeException("Mobile number already registered.");
        }
        if (customerRepository.findByEmail(customer.getEmail()).isPresent()) {
            throw new RuntimeException("Email already registered.");
        }

        // Store raw password temporarily
        String rawPassword = customer.getPassword();
        if (rawPassword == null || rawPassword.isEmpty()) {
            throw new RuntimeException("Password cannot be empty.");
        }

        // Generate IDs, Bank Details, Set initial status flags
        customer = generateBankDetails(customer);

        // HASH the raw password and set it on the customer object
        customer.setPassword(passwordEncoder.encode(rawPassword));

        // Set initial balance
        customer.setBalance(500.0);

        // Save the complete customer object
        Customer savedCustomer = customerRepository.save(customer);
        return savedCustomer;
    }


    @Transactional // Ensures the whole operation is atomic
    public Employee createEmployeeFromApplication(JobApplication application, String initialPassword) {
        // Keep the log message style
        log.info("Attempting to create EMPLOYEE record from application ID: {}", application.getId());

        // 1. Pre-checks for existing conflicts in BOTH tables
        // Check Customer Table
        if (customerRepository.findByEmail(application.getApplicantEmail()).isPresent()) {
            log.error("Employee creation failed: Email {} already exists in CUSTOMER table.", application.getApplicantEmail());
            throw new RuntimeException("Email already exists as a customer."); // Keep existing exception type
        }
        if (customerRepository.findByMobileNumber(application.getApplicantPhone()).isPresent()) {
            log.error("Employee creation failed: Mobile number {} already exists in CUSTOMER table.", application.getApplicantPhone());
            throw new RuntimeException("Mobile number already exists as a customer."); // Keep existing exception type
        }
        // Check Employee Table
        if (employeeRepository.findByEmail(application.getApplicantEmail()).isPresent()) {
            log.error("Employee creation failed: Email {} already exists in EMPLOYEE table.", application.getApplicantEmail());
            throw new RuntimeException("Email already exists as an employee."); // Keep existing exception type
        }
        if (employeeRepository.findByMobileNumber(application.getApplicantPhone()).isPresent()) {
            log.error("Employee creation failed: Mobile number {} already exists in EMPLOYEE table.", application.getApplicantPhone());
            throw new RuntimeException("Mobile number already exists as an employee."); // Keep existing exception type
        }

        // Check the *provided* initial password (Keep existing logic)
        if (initialPassword == null || initialPassword.isBlank()) {
            log.error("Employee creation failed: Initial password cannot be empty for applicant {}", application.getApplicantEmail());
            throw new IllegalArgumentException("Initial password cannot be empty for new employee.");
        }

        // 2. Create and populate the NEW Employee object (NOT Customer)
        Employee employee = new Employee();
        employee.setFname(application.getApplicantFirstName());
        employee.setLname(application.getApplicantLastName());
        employee.setEmail(application.getApplicantEmail());
        employee.setMobileNumber(application.getApplicantPhone());
        // Map relevant fields from JobApplication to Employee
        employee.setJobTitle(application.getDesiredRole()); // Example mapping
        employee.setHireDate(LocalDate.now()); // Set hire date

        // *** --- START: Employee ID Generation --- ***
        // 3. Generate a unique Employee ID (Login ID) - Keep existing logic
        String employeeId; // Changed variable name for clarity
        do {
            employeeId = "EMP-" + UUID.randomUUID().toString().substring(0, 6).toUpperCase();
            // *** Check uniqueness in the EMPLOYEE table ***
        } while (employeeRepository.findByEmployeeId(employeeId).isPresent());
        employee.setEmployeeId(employeeId); // Set the generated ID on the Employee object
        log.debug("Generated unique Employee ID: {}", employeeId);
        // *** --- END: Employee ID Generation --- ***

        // 4. Remove setting of bank details not present in Employee entity
        // employee.setAccountNumber(...) // REMOVE
        // employee.setIfsCode(...)       // REMOVE
        // employee.setBranchCode(...)    // REMOVE
        // employee.setBalance(...)       // REMOVE

        // 5. Remove setting of Customer-specific flags
        // employee.setAdmin(false);      // REMOVE (No isAdmin in Employee entity)
        // employee.setEmployee(true);    // REMOVE (Implicitly true by being in Employee table)
        // employee.setApproved(true);    // REMOVE (Handled by accountEnabled in Employee entity)

        // 6. Hash and set the *provided* initial password securely on the Employee object
        employee.setPassword(passwordEncoder.encode(initialPassword));
        log.debug("Provided initial password hashed for employee {}", employeeId);

        // 7. Save the new EMPLOYEE record using EmployeeRepository
        Employee savedEmployee = employeeRepository.save(employee); // Use employeeRepository
        log.info("Successfully created EMPLOYEE record {} with Employee ID: {}", savedEmployee.getEmail(), savedEmployee.getEmployeeId());

        // 8. Return the newly created EMPLOYEE object
        return savedEmployee;
    }


}


--- main\java\com\Banking_Somnath\banking_systemn\service\EmployeeService.java ---
package com.Banking_Somnath.banking_systemn.service;
import com.Banking_Somnath.banking_systemn.controller.EmployeeController;
import com.Banking_Somnath.banking_systemn.model.Customer;
import com.Banking_Somnath.banking_systemn.model.Transaction;
import com.Banking_Somnath.banking_systemn.repository.CustomerRepository;
import com.Banking_Somnath.banking_systemn.repository.TransactionRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;

import java.security.Principal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.Optional;
@Service
public class EmployeeService {
    @Autowired
    private TransactionService transactionService;
    private static final Logger log = LoggerFactory.getLogger(EmployeeController.class);

    @Autowired
    private CustomerRepository customerRepository;

    @Autowired
    private TransactionRepository transactionRepository;

    // Helper to find customer (handles finding by ID or potentially Account Number)
    private Optional<Customer> findCustomer(String identifier) {
        // Try finding by Customer ID first
        Optional<Customer> customerOpt = customerRepository.findByCustomerId(identifier);
        if (customerOpt.isEmpty()) {
            // Optional: Add logic to find by Account Number if needed
            // customerOpt = customerRepository.findByAccountNumber(identifier);
        }
        return customerOpt;
    }

    @Transactional
    public String deposit(String targetCustomerId, double amount, String performingEmployeeId) {
        log.info("Employee {} attempting deposit of {} into account for customer ID {}",
                performingEmployeeId, amount, targetCustomerId);

        if (amount <= 0) {
            log.warn("Deposit failed: Amount must be positive. Amount: {}", amount);
            return "ERROR: Amount must be positive.";
        }

        Optional<Customer> targetCustomerOpt = findCustomer(targetCustomerId);
        if (targetCustomerOpt.isEmpty()) {
            log.warn("Deposit failed: Target customer not found with identifier: {}", targetCustomerId);
            return "ERROR: Target customer account not found.";
        }

        Customer targetCustomer = targetCustomerOpt.get();

        // Optional: Check if the target customer account is active/approved
        if (!targetCustomer.isEnabled()) {
            log.warn("Deposit failed: Target customer account {} is not active.", targetCustomerId);
            return "ERROR: Target customer account is not active.";
        }

        // Perform deposit
        targetCustomer.setBalance(targetCustomer.getBalance() + amount);
        customerRepository.save(targetCustomer);
        log.info("Deposit successful. New balance for customer {}: {}", targetCustomerId, targetCustomer.getBalance());

        // Log transaction
        Transaction depositTx = new Transaction();
        depositTx.setCustomerId(targetCustomer.getCustomerId()); // Log against the target customer
        depositTx.setMobileNo(targetCustomer.getMobileNumber());
        depositTx.setType("DEPOSIT_BY_EMP");
        depositTx.setBalance(amount); // Amount deposited
        depositTx.setDescription("Deposit of ₹" + String.format("%.2f", amount) + " performed by Employee " + performingEmployeeId);
        depositTx.setLocalDateTime(LocalDateTime.now());
        depositTx.setSenderAccountNumber(null); // N/A for deposit
        depositTx.setRecipientAccountNumber(targetCustomer.getAccountNumber());
        depositTx.setBranchCode(targetCustomer.getBranchCode());
        depositTx.setIfscCode(targetCustomer.getIfsCode());
        depositTx.setSenderMobileNo(null);
        depositTx.setRecipientMobileNo(targetCustomer.getMobileNumber());
        transactionRepository.save(depositTx);
        log.info("Deposit transaction logged for customer {}", targetCustomerId);

        return "Deposit successful. ₹" + String.format("%.2f", amount) + " added to account " + targetCustomer.getAccountNumber() + ". New balance: ₹" + String.format("%.2f", targetCustomer.getBalance());
    }

    @Transactional
    public String withdraw(String targetCustomerId, double amount, String performingEmployeeId) {
        log.info("Employee {} attempting withdrawal of {} from account for customer ID {}",
                performingEmployeeId, amount, targetCustomerId);

        if (amount <= 0) {
            log.warn("Withdrawal failed: Amount must be positive. Amount: {}", amount);
            return "ERROR: Amount must be positive.";
        }

        Optional<Customer> targetCustomerOpt = findCustomer(targetCustomerId);
        if (targetCustomerOpt.isEmpty()) {
            log.warn("Withdrawal failed: Target customer not found with identifier: {}", targetCustomerId);
            return "ERROR: Target customer account not found.";
        }

        Customer targetCustomer = targetCustomerOpt.get();

        if (!targetCustomer.isEnabled()) {
            log.warn("Withdrawal failed: Target customer account {} is not active.", targetCustomerId);
            return "ERROR: Target customer account is not active.";
        }

        if (targetCustomer.getBalance() < amount) {
            log.warn("Withdrawal failed: Insufficient balance for customer {}. Required: {}, Available: {}",
                    targetCustomerId, amount, targetCustomer.getBalance());
            return "ERROR: Insufficient balance.";
        }

        // Perform withdrawal
        targetCustomer.setBalance(targetCustomer.getBalance() - amount);
        customerRepository.save(targetCustomer);
        log.info("Withdrawal successful. New balance for customer {}: {}", targetCustomerId, targetCustomer.getBalance());

        // Log transaction
        Transaction withdrawalTx = new Transaction();
        withdrawalTx.setCustomerId(targetCustomer.getCustomerId()); // Log against the target customer
        withdrawalTx.setMobileNo(targetCustomer.getMobileNumber());
        withdrawalTx.setType("WITHDRAWAL_BY_EMP");
        withdrawalTx.setBalance(amount); // Amount withdrawn
        withdrawalTx.setDescription("Withdrawal of ₹" + String.format("%.2f", amount) + " performed by Employee " + performingEmployeeId);
        withdrawalTx.setLocalDateTime(LocalDateTime.now());
        withdrawalTx.setSenderAccountNumber(targetCustomer.getAccountNumber());
        withdrawalTx.setRecipientAccountNumber(null); // N/A for withdrawal
        withdrawalTx.setBranchCode(targetCustomer.getBranchCode());
        withdrawalTx.setIfscCode(targetCustomer.getIfsCode());
        withdrawalTx.setSenderMobileNo(targetCustomer.getMobileNumber());
        withdrawalTx.setRecipientMobileNo(null);
        transactionRepository.save(withdrawalTx);
        log.info("Withdrawal transaction logged for customer {}", targetCustomerId);

        return "Withdrawal successful. ₹" + String.format("%.2f", amount) + " deducted from account " + targetCustomer.getAccountNumber() + ". New balance: ₹" + String.format("%.2f", targetCustomer.getBalance());
    }

    @Transactional(readOnly = true) // Read-only is sufficient for checking balance
    public String checkBalance(String targetCustomerId, String performingEmployeeId) {
        log.info("Employee {} checking balance for customer ID {}", performingEmployeeId, targetCustomerId);

        Optional<Customer> targetCustomerOpt = findCustomer(targetCustomerId);
        if (targetCustomerOpt.isEmpty()) {
            log.warn("Check balance failed: Target customer not found with identifier: {}", targetCustomerId);
            return "ERROR: Target customer account not found.";
        }

        Customer targetCustomer = targetCustomerOpt.get();

        // Optionally check if active, though viewing might be allowed even if inactive
        // if (!targetCustomer.isEnabled()) {
        //     log.warn("Check balance: Target customer account {} is not active.", targetCustomerId);
        //     return "ERROR: Target customer account is not active.";
        // }

        log.info("Balance check successful for customer {}. Balance: {}", targetCustomerId, targetCustomer.getBalance());
        return String.format("%.2f", targetCustomer.getBalance());
    }

}

--- main\java\com\Banking_Somnath\banking_systemn\service\FixedDepositService.java ---
package com.Banking_Somnath.banking_systemn.service;

import com.Banking_Somnath.banking_systemn.dto.CustomerBasicInfoDto;
import com.Banking_Somnath.banking_systemn.dto.FixedDepositAdminViewDto;
import com.Banking_Somnath.banking_systemn.dto.FixedDepositCustomerViewDto;
import com.Banking_Somnath.banking_systemn.model.Customer;
import com.Banking_Somnath.banking_systemn.model.FixedDeposit;
import com.Banking_Somnath.banking_systemn.model.FixedDepositStatus;
import com.Banking_Somnath.banking_systemn.model.Transaction;
import com.Banking_Somnath.banking_systemn.repository.CustomerRepository;
import com.Banking_Somnath.banking_systemn.repository.FixedDepositRepository;
import com.Banking_Somnath.banking_systemn.repository.TransactionRepository;
import com.Banking_Somnath.banking_systemn.request.CreateFdRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
// import org.hibernate.Hibernate; // Only if explicitly using Hibernate.initialize and not JOIN FETCH

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class FixedDepositService {

    private static final Logger log = LoggerFactory.getLogger(FixedDepositService.class);

    @Autowired
    private FixedDepositRepository fixedDepositRepository;

    @Autowired
    private CustomerRepository customerRepository;

    @Autowired
    private TransactionRepository transactionRepository;

    // --- Interest Rates ---
    private static final double RATE_FOR_TERM_1_TO_6_MONTHS = 5.0;
    private static final double RATE_FOR_TERM_7_TO_12_MONTHS = 5.75;
    private static final double RATE_FOR_TERM_13_TO_24_MONTHS = 6.25;
    private static final double RATE_FOR_TERM_25_TO_60_MONTHS = 6.75;
    private static final double RATE_FOR_TERM_ABOVE_60_MONTHS = 7.0;

    /**
     * Customer applies for a new Fixed Deposit.
     * Returns a DTO representing the created (pending) FD application.
     */
    @Transactional
    public FixedDepositCustomerViewDto applyForFd(String customerId, CreateFdRequest request) {
        log.info("Customer {} initiating FD application. Amount: ₹{}, Term: {} months",
                customerId, request.getPrincipalAmount(), request.getTermInMonths());

        Customer customer = customerRepository.findByCustomerId(customerId)
                .orElseThrow(() -> {
                    log.error("FD Application failed: Customer with ID {} not found.", customerId);
                    return new RuntimeException("Customer not found. Unable to process FD application.");
                });

        // --- Input Validation ---
        if (request.getPrincipalAmount() == null || request.getPrincipalAmount() <= 0) {
            throw new IllegalArgumentException("Principal amount for FD must be a positive value.");
        }
        if (request.getPrincipalAmount() < 500.00) {
            throw new IllegalArgumentException("Minimum Fixed Deposit amount is ₹500.00.");
        }
        if (request.getTermInMonths() == null || request.getTermInMonths() <= 0) {
            throw new IllegalArgumentException("Term in months for FD must be a positive value.");
        }
        if (request.getTermInMonths() < 1 || request.getTermInMonths() > 120) {
            throw new IllegalArgumentException("Fixed Deposit term must be between 1 and 120 months.");
        }

        double interestRate = determineInterestRateForTerm(request.getTermInMonths());

        FixedDeposit fd = new FixedDeposit();
        fd.setCustomer(customer);
        fd.setCustomerId(customerId);
        fd.setPrincipalAmount(roundToTwoDecimals(request.getPrincipalAmount()));
        fd.setTermInMonths(request.getTermInMonths());
        fd.setInterestRate(interestRate);
        fd.setSourceAccountNumber(customer.getAccountNumber());
        fd.setStatus(FixedDepositStatus.PENDING);
        fd.setApplicationDate(LocalDateTime.now());
        // Maturity date & amount for PENDING can be indicative if needed by DTO,
        // but official calculation happens on approval based on actual start date.
        // For PENDING, startDate, maturityDate, maturityAmount are often null in the DTO.
        // fd.setMaturityDate(LocalDate.now().plusMonths(fd.getTermInMonths())); // Tentative
        // fd.setMaturityAmount(calculateMaturityAmount(fd.getPrincipalAmount(), fd.getInterestRate(), fd.getTermInMonths())); // Tentative


        FixedDeposit savedFd = fixedDepositRepository.save(fd);
        log.info("FD Application (ID: {}) created successfully for customer {} with PENDING status. Proposed rate: {}% p.a.",
                savedFd.getId(), customerId, interestRate);
        return convertToCustomerViewDto(savedFd); // Return DTO for consistency
    }

    /**
     * Admin approves a pending Fixed Deposit application.
     * Returns an AdminViewDTO of the approved FD.
     */
    @Transactional
    public FixedDepositAdminViewDto approveFd(Long fdId, String adminId) {
        log.info("Admin {} attempting to approve FD application ID: {}", adminId, fdId);

        // Use a repository method that ensures customer is fetched if LAZY for balance check.
        // findById should work if Customer association in FixedDeposit is EAGER.
        // If LAZY, prefer custom findByIdWithCustomer(fdId) from repository with JOIN FETCH.
        FixedDeposit fd = fixedDepositRepository.findById(fdId)
                .orElseThrow(() -> new RuntimeException("Fixed Deposit application not found with ID: " + fdId));

        if (fd.getStatus() != FixedDepositStatus.PENDING) {
            log.warn("FD Approval failed for ID {}: Application is not in PENDING status (current: {}).", fdId, fd.getStatus());
            throw new IllegalStateException("Only Fixed Deposits with PENDING status can be approved.");
        }

        Customer customer = fd.getCustomer();
        if (customer == null) { // Should be loaded if association is EAGER or JOIN FETCHED
            customer = customerRepository.findByCustomerId(fd.getCustomerId())
                    .orElseThrow(() -> new RuntimeException("Critical Error: Customer (ID: " + fd.getCustomerId() + ") for FD ID " + fdId + " not found."));
            fd.setCustomer(customer); // Associate if fetched separately
        }
        // If Customer is LAZY and not JOIN FETCHED, ensure it's initialized before accessing balance
        // if (!org.hibernate.Hibernate.isInitialized(customer)) {
        //     org.hibernate.Hibernate.initialize(customer);
        // }

        if (customer.getBalance() < fd.getPrincipalAmount()) {
            throw new RuntimeException("Insufficient balance in customer's account (ID: "
                    + customer.getCustomerId() + ") to fund the Fixed Deposit of ₹" + fd.getPrincipalAmount() + ".");
        }

        customer.setBalance(roundToTwoDecimals(customer.getBalance() - fd.getPrincipalAmount()));
        customerRepository.save(customer);
        log.info("Successfully debited ₹{} from customer {} (Account: {}) for FD ID {}. New balance: ₹{}",
                fd.getPrincipalAmount(), customer.getCustomerId(), customer.getAccountNumber(), fdId, customer.getBalance());

        Transaction debitTransaction = new Transaction();
        debitTransaction.setCustomerId(customer.getCustomerId());
        debitTransaction.setMobileNo(customer.getMobileNumber());
        debitTransaction.setType("FD_ACCOUNT_DEBIT");
        debitTransaction.setBalance(fd.getPrincipalAmount());
        debitTransaction.setDescription("Debit for activation of Fixed Deposit (ID: " + fd.getId() + ")");
        debitTransaction.setLocalDateTime(LocalDateTime.now());
        debitTransaction.setSenderAccountNumber(customer.getAccountNumber());
        debitTransaction.setBranchCode(customer.getBranchCode());
        debitTransaction.setIfscCode(customer.getIfsCode());
        transactionRepository.save(debitTransaction);
        log.info("FD debit transaction logged successfully for FD ID: {}", fd.getId());

        LocalDate actualStartDate = LocalDate.now();
        fd.setStartDate(actualStartDate);
        fd.setMaturityDate(actualStartDate.plusMonths(fd.getTermInMonths()));
        fd.setMaturityAmount(calculateMaturityAmount(fd.getPrincipalAmount(), fd.getInterestRate(), fd.getTermInMonths()));
        fd.setStatus(FixedDepositStatus.ACTIVE);
        fd.setActionDate(LocalDateTime.now());
        fd.setActionByAdminId(adminId);
        fd.setRejectionReason(null);

        FixedDeposit approvedFd = fixedDepositRepository.save(fd);
        return convertToAdminViewDto(approvedFd);
    }

    /**
     * Admin rejects a pending Fixed Deposit application.
     * Returns an AdminViewDTO of the rejected FD.
     */
    @Transactional
    public FixedDepositAdminViewDto rejectFd(Long fdId, String adminId, String reason) {
        log.info("Admin {} attempting to reject FD application ID: {} with reason: {}", adminId, fdId, reason);
        FixedDeposit fd = fixedDepositRepository.findById(fdId)
                .orElseThrow(() -> new RuntimeException("Fixed Deposit application not found with ID: " + fdId));

        if (fd.getStatus() != FixedDepositStatus.PENDING) {
            log.warn("FD Rejection failed for ID {}: Application is not in PENDING status (current: {}).", fdId, fd.getStatus());
            throw new IllegalStateException("Only Fixed Deposits with PENDING status can be rejected.");
        }
        if (reason == null || reason.isBlank()) {
            throw new IllegalArgumentException("Rejection reason cannot be empty.");
        }
        if (reason.length() > 500) {
            throw new IllegalArgumentException("Rejection reason is too long (max 500 characters).");
        }

        fd.setStatus(FixedDepositStatus.REJECTED);
        fd.setActionDate(LocalDateTime.now());
        fd.setActionByAdminId(adminId);
        fd.setRejectionReason(reason.trim());
        // Ensure customer is loaded for DTO conversion, if not already by findById
        if (fd.getCustomer() == null) {
            customerRepository.findByCustomerId(fd.getCustomerId()).ifPresent(fd::setCustomer);
        }


        FixedDeposit rejectedFd = fixedDepositRepository.save(fd);
        return convertToAdminViewDto(rejectedFd);
    }

    /**
     * Retrieves all Fixed Deposits for a specific customer as DTOs.
     */
    @Transactional(readOnly = true)
    public List<FixedDepositCustomerViewDto> getFdsByCustomerIdDto(String customerId) {
        log.debug("Fetching all FDs for customer ID {} as DTOs", customerId);
        customerRepository.findByCustomerId(customerId)
                .orElseThrow(() -> new RuntimeException("Customer not found. Cannot fetch FDs."));

        // Use the repository method with JOIN FETCH for customer if you created one
        // List<FixedDeposit> fds = fixedDepositRepository.findByCustomerIdWithCustomerOrderByApplicationDateDesc(customerId);
        // Otherwise, if FixedDeposit.customer is EAGER or handled by default fetch plan:
        List<FixedDeposit> fds = fixedDepositRepository.findByStatusWithCustomerOrderByApplicationDateAsc(FixedDepositStatus.valueOf(customerId));
        return fds.stream().map(this::convertToCustomerViewDto).collect(Collectors.toList());
    }

    /**
     * Retrieves PENDING Fixed Deposit applications as DTOs for admin view.
     * This method now uses the repository method with JOIN FETCH to ensure customer details are loaded.
     */
    @Transactional(readOnly = true)
    public List<FixedDepositAdminViewDto> getPendingFdApplicationsForAdmin() {
        log.debug("Fetching PENDING FD applications for Admin View DTOs");
        List<FixedDeposit> pendingFds = fixedDepositRepository.findByStatusWithCustomerOrderByApplicationDateAsc(FixedDepositStatus.PENDING);
        return pendingFds.stream()
                .map(this::convertToAdminViewDto)
                .collect(Collectors.toList());
    }

    // --- DTO Conversion Helpers ---
    private FixedDepositAdminViewDto convertToAdminViewDto(FixedDeposit fd) {
        if (fd == null) return null;
        Customer customer = fd.getCustomer(); // Expected to be initialized due to JOIN FETCH or EAGER loading
        CustomerBasicInfoDto customerInfoDto;

        if (customer != null) {
            customerInfoDto = new CustomerBasicInfoDto(
                    customer.getCustomerId(),
                    customer.getFname() + " " + customer.getLname(),
                    customer.getMobileNumber(),
                    customer.getEmail()
            );
        } else {
            log.warn("Customer object was null for FD ID: {}. Using customerId from FD for DTO.", fd.getId());
            // Attempt a fallback, though this indicates a potential issue in data loading strategy
            Customer fallbackCustomer = customerRepository.findByCustomerId(fd.getCustomerId()).orElse(null);
            if (fallbackCustomer != null) {
                customerInfoDto = new CustomerBasicInfoDto(
                        fallbackCustomer.getCustomerId(),
                        fallbackCustomer.getFname() + " " + fallbackCustomer.getLname(),
                        fallbackCustomer.getMobileNumber(),
                        fallbackCustomer.getEmail()
                );
            } else {
                customerInfoDto = new CustomerBasicInfoDto(fd.getCustomerId(), "Customer Data Unavailable", "N/A", "N/A");
            }
        }

        return new FixedDepositAdminViewDto(
                fd.getId(),
                customerInfoDto,
                fd.getPrincipalAmount(),
                fd.getTermInMonths(),
                fd.getInterestRate(),
                fd.getApplicationDate(),
                fd.getStatus(),
                fd.getSourceAccountNumber()
        );
    }

    private FixedDepositCustomerViewDto convertToCustomerViewDto(FixedDeposit fd) {
        if (fd == null) return null;
        return new FixedDepositCustomerViewDto(
                fd.getId(),
                fd.getPrincipalAmount(),
                fd.getInterestRate(),
                fd.getTermInMonths(),
                fd.getStartDate(), // Will be null for PENDING/REJECTED
                fd.getMaturityDate(), // Will be null for PENDING/REJECTED, or based on app date if PENDING
                fd.getMaturityAmount(), // Will be null for PENDING/REJECTED
                fd.getStatus(),
                fd.getApplicationDate(),
                fd.getRejectionReason(),
                fd.getSourceAccountNumber()
        );
    }

    // --- Private Helper Methods for Calculations ---
    private double determineInterestRateForTerm(int termInMonths) {
        if (termInMonths > 60) return RATE_FOR_TERM_ABOVE_60_MONTHS;
        if (termInMonths >= 25) return RATE_FOR_TERM_25_TO_60_MONTHS;
        if (termInMonths >= 13) return RATE_FOR_TERM_13_TO_24_MONTHS;
        if (termInMonths >= 7) return RATE_FOR_TERM_7_TO_12_MONTHS;
        if (termInMonths >= 1) return RATE_FOR_TERM_1_TO_6_MONTHS;
        log.warn("Unsupported FD term for rate calculation: {} months. Returning lowest tier rate.", termInMonths);
        return RATE_FOR_TERM_1_TO_6_MONTHS;
    }

    private double calculateMaturityAmount(double principal, double annualRatePercent, int termInMonths) {
        double rateDecimal = annualRatePercent / 100.0;
        double termInYears = (double) termInMonths / 12.0;
        // Simple Interest: Interest = P * R * T; Maturity = P + Interest
        double interestEarned = principal * rateDecimal * termInYears;
        double maturityAmount = principal + interestEarned;
        return roundToTwoDecimals(maturityAmount);
    }

    private double roundToTwoDecimals(double value) {
        return BigDecimal.valueOf(value).setScale(2, RoundingMode.HALF_UP).doubleValue();
    }
}

--- main\java\com\Banking_Somnath\banking_systemn\service\JobApplicationService.java ---
package com.Banking_Somnath.banking_systemn.service;

import com.Banking_Somnath.banking_systemn.model.ApplicationStatus;
import com.Banking_Somnath.banking_systemn.model.Employee;
import com.Banking_Somnath.banking_systemn.model.JobApplication;
import com.Banking_Somnath.banking_systemn.repository.JobApplicationRepository;
import com.Banking_Somnath.banking_systemn.request.JobApplicationRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
public class JobApplicationService {
    @Autowired
    JobApplicationRepository jobApplicationRepository;
    @Autowired
    CustomerService customerService;

    @Transactional
    public JobApplication submitApplication(JobApplicationRequest request) {
        JobApplication application = new JobApplication();
        application.setApplicantFirstName(request.getApplicantFirstName());
        application.setApplicantLastName(request.getApplicantLastName());
        application.setApplicantEmail(request.getApplicantEmail());
        application.setApplicantPhone(request.getApplicantPhone());
        application.setQualifications(request.getQualifications());
        application.setExperience(request.getExperience());
        application.setDesiredRole(request.getDesiredRole());
        application.setResumeLink(request.getResumeLink());
        // applicationDate and status are set in constructor

        return jobApplicationRepository.save(application);
    }

    @Transactional(readOnly = true)
    public List<JobApplication> getAllApplications() {
        return jobApplicationRepository.findAllByOrderByApplicationDateDesc();
    }

    @Transactional(readOnly = true)
    public Optional<JobApplication> getApplicationById(Long id) {
        return jobApplicationRepository.findById(id);
    }


    @Transactional
    public JobApplication scheduleInterview(Long appId, LocalDateTime interviewDate, String adminId) {
        JobApplication app = jobApplicationRepository.findById(appId)
                .orElseThrow(() -> new RuntimeException("Application not found: " + appId));

        app.setStatus(ApplicationStatus.INTERVIEW_SCHEDULED);
        app.setInterviewDate(interviewDate);
        app.setReviewerAdminId(adminId); // Track who scheduled it
        app.setAdminNotes("Interview scheduled by " + adminId + " for " + interviewDate.toString()); // Example note
        return jobApplicationRepository.save(app);
    }

    @Transactional
    public JobApplication rejectApplication(Long appId, String reason, String adminId) {
        JobApplication app = jobApplicationRepository.findById(appId)
                .orElseThrow(() -> new RuntimeException("Application not found: " + appId));

        app.setStatus(ApplicationStatus.REJECTED);
        app.setReviewerAdminId(adminId);
        app.setAdminNotes("Application rejected by " + adminId + ". Reason: " + reason);
        return jobApplicationRepository.save(app);
    }

    // --- Keep previous methods (submitApplication, etc.) AS IS ---

    @Transactional
    public JobApplication approveHire(Long appId, String adminId) {
        JobApplication app = jobApplicationRepository.findById(appId)
                .orElseThrow(() -> new RuntimeException("Application not found: " + appId));

        if(app.getStatus() == ApplicationStatus.HIRED) {
            throw new RuntimeException("Application already marked as hired.");
        }

        String initialPassword = "DefaultPassword123!"; // Keep using the provided password

        // --- START: Minimal Change Area ---
        Employee createdEmployee; // Variable to hold the returned Employee object
        try {
            // Call the CustomerService method which now CREATES and RETURNS an Employee
            // This implicitly uses EmployeeRepository inside CustomerService
            createdEmployee = customerService.createEmployeeFromApplication(app, initialPassword);

        } catch(Exception e) {
            // Keep existing exception handling
            throw new RuntimeException("Failed to create employee user account: " + e.getMessage(), e);
        }
        // --- END: Minimal Change Area ---


        // Update application status only after successful user creation
        app.setStatus(ApplicationStatus.HIRED);
        app.setReviewerAdminId(adminId); // Keep tracking admin

        // *** Update Admin Notes to use the Employee ID from the createdEmployee object ***
        app.setAdminNotes("Hired by " + adminId + ". Employee record created. Employee ID: " + createdEmployee.getEmployeeId()); // Use getEmployeeId()

        // *** This line uses JobApplicationRepository and remains UNCHANGED ***
        // It saves the updated JobApplication entity (app)
        return jobApplicationRepository.save(app);
    }

    // --- Keep other methods AS IS ---
}


--- main\java\com\Banking_Somnath\banking_systemn\service\LoanService.java ---
package com.Banking_Somnath.banking_systemn.service;

import com.Banking_Somnath.banking_systemn.model.Customer;
import com.Banking_Somnath.banking_systemn.model.LoanApplication;
import com.Banking_Somnath.banking_systemn.model.LoanApplicationStatus;
import com.Banking_Somnath.banking_systemn.repository.CustomerRepository;
import com.Banking_Somnath.banking_systemn.repository.LoanApplicationRepository;
import com.Banking_Somnath.banking_systemn.request.ApproveLoanRequest;
import com.Banking_Somnath.banking_systemn.request.CreateLoanRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;

@Service
public class LoanService {

    private static final Logger log = LoggerFactory.getLogger(LoanService.class);

    @Autowired
    private LoanApplicationRepository loanApplicationRepository;

    @Autowired
    private CustomerRepository customerRepository; // Needed to check if customer exists

    // Constants for allowed statuses for admin actions
    private static final List<LoanApplicationStatus> ACTIONABLE_STATUSES = Arrays.asList(
            LoanApplicationStatus.PENDING,
            LoanApplicationStatus.UNDER_REVIEW
    );

    /**
     * Customer applies for a new Loan.
     * Creates a LoanApplication record with PENDING status.
     */
    @Transactional
    public LoanApplication applyForLoan(String customerId, CreateLoanRequest request) {
        log.info("Customer {} applying for {} loan. Amount: {}, Term: {} months",
                customerId, request.getLoanType(), request.getRequestedAmount(), request.getTermInMonths());

        // 1. Ensure customer exists
        customerRepository.findByCustomerId(customerId)
                .orElseThrow(() -> {
                    log.error("Loan Application failed: Customer {} not found.", customerId);
                    return new RuntimeException("Customer not found. Cannot apply for loan.");
                });

        // 2. Input Validation (Basic - add more specific checks as needed)
        if (request.getLoanType() == null || request.getLoanType().isBlank()) {
            throw new IllegalArgumentException("Loan type is required.");
        }
        if (request.getRequestedAmount() == null || request.getRequestedAmount() <= 0) {
            throw new IllegalArgumentException("Requested loan amount must be positive.");
        }
        // Example: Check against a minimum loan amount
        if (request.getRequestedAmount() < 1000) {
            throw new IllegalArgumentException("Minimum loan amount is ₹1000.");
        }
        if (request.getTermInMonths() == null || request.getTermInMonths() <= 0) {
            throw new IllegalArgumentException("Loan term must be positive (in months).");
        }
        // Example: Check against allowed terms
        if (request.getTermInMonths() < 6 || request.getTermInMonths() > 120) {
            throw new IllegalArgumentException("Loan term must be between 6 and 120 months.");
        }
        if (request.getPurpose() == null || request.getPurpose().isBlank()) {
            throw new IllegalArgumentException("Loan purpose is required.");
        }
        // Validate optional fields if needed (e.g., income must be non-negative if provided)
        if (request.getMonthlyIncome() != null && request.getMonthlyIncome() < 0) {
            throw new IllegalArgumentException("Monthly income cannot be negative.");
        }


        // 3. Create Loan Application Entity
        LoanApplication loanApp = new LoanApplication();
        loanApp.setCustomerId(customerId);
        loanApp.setLoanType(request.getLoanType().trim().toUpperCase()); // Standardize type
        loanApp.setRequestedAmount(request.getRequestedAmount());
        loanApp.setTermInMonths(request.getTermInMonths());
        loanApp.setPurpose(request.getPurpose().trim());
        loanApp.setMonthlyIncome(request.getMonthlyIncome()); // Optional
        loanApp.setEmploymentStatus(request.getEmploymentStatus()); // Optional
        loanApp.setStatus(LoanApplicationStatus.PENDING); // Initial status
        loanApp.setApplicationDate(LocalDateTime.now());

        // 4. Save and Return
        LoanApplication savedLoanApp = loanApplicationRepository.save(loanApp);
        log.info("Loan Application {} created successfully for customer {} with PENDING status.", savedLoanApp.getId(), customerId);
        return savedLoanApp;
    }

    /**
     * Admin approves a pending Loan application.
     * Updates status to APPROVED, sets approval details.
     * Note: Disbursement is a separate step NOT handled here.
     */
    @Transactional
    public LoanApplication approveLoan(Long loanId, String adminId, ApproveLoanRequest approveDetails) {
        log.info("Admin {} attempting to approve Loan application {}", adminId, loanId);

        // 1. Find the loan application
        LoanApplication loanApp = loanApplicationRepository.findById(loanId)
                .orElseThrow(() -> new RuntimeException("Loan application not found with ID: " + loanId));

        // 2. Validate current status
        if (!ACTIONABLE_STATUSES.contains(loanApp.getStatus())) {
            log.warn("Approval failed: Loan App {} is not in an actionable status (current: {}).", loanId, loanApp.getStatus());
            throw new IllegalStateException("Loan Application cannot be approved from its current status: " + loanApp.getStatus());
        }

        // 3. Validate Approval Details from Admin
        if (approveDetails.getApprovedAmount() == null || approveDetails.getApprovedAmount() <= 0) {
            throw new IllegalArgumentException("Approved amount must be positive.");
        }
        // Example: Minimum interest rate check
        if (approveDetails.getInterestRate() == null || approveDetails.getInterestRate() <= 0.1) {
            throw new IllegalArgumentException("Interest rate must be positive (e.g., greater than 0.1%).");
        }
        // Optional: Policy check - Approved amount shouldn't drastically exceed requested?
        if (approveDetails.getApprovedAmount() > loanApp.getRequestedAmount() * 1.1) { // e.g., max 10% over requested
            log.warn("Admin {} approved loan {} for significantly more (₹{}) than requested (₹{}).",
                    adminId, loanId, approveDetails.getApprovedAmount(), loanApp.getRequestedAmount());
            // Potentially throw error or just log based on bank policy
        }

        // 4. Update Loan Application Status and Details
        loanApp.setStatus(LoanApplicationStatus.APPROVED);
        loanApp.setApprovedAmount(approveDetails.getApprovedAmount());
        loanApp.setInterestRate(approveDetails.getInterestRate());
        loanApp.setApprovalDate(LocalDateTime.now());
        loanApp.setApprovedByAdminId(adminId); // Log the admin who approved
        loanApp.setRejectionReason(null); // Clear rejection reason if any

        // 5. Save and Return
        LoanApplication approvedLoanApp = loanApplicationRepository.save(loanApp);
        log.info("Loan Application {} approved successfully by admin {}. Approved Amount: ₹{}, Rate: {}%",
                loanId, adminId, approvedLoanApp.getApprovedAmount(), approvedLoanApp.getInterestRate());
        return approvedLoanApp;
    }

    /**
     * Admin rejects a pending Loan application.
     */
    @Transactional
    public LoanApplication rejectLoan(Long loanId, String adminId, String reason) {
        log.info("Admin {} attempting to reject Loan application {} with reason: {}", adminId, loanId, reason);

        // 1. Find the loan application
        LoanApplication loanApp = loanApplicationRepository.findById(loanId)
                .orElseThrow(() -> new RuntimeException("Loan application not found with ID: " + loanId));

        // 2. Validate current status
        if (!ACTIONABLE_STATUSES.contains(loanApp.getStatus())) {
            log.warn("Rejection failed: Loan App {} is not in an actionable status (current: {}).", loanId, loanApp.getStatus());
            throw new IllegalStateException("Loan Application cannot be rejected from its current status: " + loanApp.getStatus());
        }

        // 3. Validate Rejection Reason
        if (reason == null || reason.isBlank()) {
            throw new IllegalArgumentException("Rejection reason cannot be empty.");
        }

        // 4. Update Loan Application Status and Details
        loanApp.setStatus(LoanApplicationStatus.REJECTED);
        loanApp.setApprovedByAdminId(adminId); // Log who rejected it
        loanApp.setRejectionReason(reason.trim());
        // Clear approval details if somehow set previously
        loanApp.setApprovedAmount(null);
        loanApp.setInterestRate(null);
        loanApp.setApprovalDate(null);

        // 5. Save and Return
        LoanApplication rejectedLoanApp = loanApplicationRepository.save(loanApp);
        log.info("Loan Application {} rejected successfully by admin {}.", loanId, adminId);
        return rejectedLoanApp;
    }

    /**
     * Get all Loan Applications for a specific customer.
     */
    @Transactional(readOnly = true)
    public List<LoanApplication> getLoansByCustomer(String customerId) {
        log.debug("Fetching Loan Applications for customer {}", customerId);
        // Ensure customer exists before querying? Optional check.
        customerRepository.findByCustomerId(customerId)
                .orElseThrow(() -> new RuntimeException("Customer not found. Cannot fetch loans."));
        return loanApplicationRepository.findByCustomerIdOrderByApplicationDateDesc(customerId);
    }

    /**
     * Get all Loan Applications with actionable statuses (PENDING, UNDER_REVIEW) for admin view.
     */
    @Transactional(readOnly = true)
    public List<LoanApplication> getPendingLoanApplications() {
        log.debug("Fetching Loan Applications with actionable statuses: {}", ACTIONABLE_STATUSES);
        return loanApplicationRepository.findByStatusInOrderByApplicationDateAsc(ACTIONABLE_STATUSES);
        // Or if only PENDING:
        // return loanApplicationRepository.findByStatusOrderByApplicationDateAsc(LoanApplicationStatus.PENDING);
    }

    // Optional: Method to get loan by ID if needed elsewhere
    @Transactional(readOnly = true)
    public LoanApplication getLoanApplicationById(Long loanId) {
        log.debug("Fetching loan application by ID: {}", loanId);
        return loanApplicationRepository.findById(loanId)
                .orElseThrow(() -> new RuntimeException("Loan application not found with ID: " + loanId));
    }
}

--- main\java\com\Banking_Somnath\banking_systemn\service\TransactionService.java ---
package com.Banking_Somnath.banking_systemn.service;

import com.Banking_Somnath.banking_systemn.model.Customer;
import com.Banking_Somnath.banking_systemn.model.Transaction;
import com.Banking_Somnath.banking_systemn.repository.CustomerRepository;
import com.Banking_Somnath.banking_systemn.repository.TransactionRepository;
import com.Banking_Somnath.banking_systemn.request.TransferMoney;
import com.itextpdf.text.*;
import com.itextpdf.text.pdf.PdfPCell;
import com.itextpdf.text.pdf.PdfPTable;
import com.itextpdf.text.pdf.PdfWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.ByteArrayOutputStream;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Optional;
@Service
public class TransactionService {

    @Autowired
    CustomerRepository customerRepository;

    @Autowired
    PasswordEncoder passwordEncoder;

    @Autowired
    TransactionRepository transactionRepository;

    private static final Logger log = LoggerFactory.getLogger(TransactionService.class);


    public String getBalance(String customerId) {


        Optional<Customer> customerList = customerRepository.findByCustomerId(customerId);
        System.out.println("✅ Looking for customer ID: " + customerId);

        if (!customerList.isEmpty()) {
            Customer c = customerList.get();
            System.out.println("✅ Found customer: " + c.getCustomerId() + ", Balance: " + c.getBalance());
            return String.format("%.2f", c.getBalance());
        } else {
            System.out.println("❌ Customer not found.");
            return "ERROR:Customer_Not_Found";
        }
    }

    @Transactional
    public String Transfer(Customer sender, TransferMoney transferMoney){

        double amount = transferMoney.getAmount();
//        String senderPassword = transferMoney.getSenderPassword(); // <--- UNCOMMENTED
        String receiverCustomerId= transferMoney.getReceiverCustomerId();
        String receiverMobileNo= transferMoney.getReceiverMobileNo();

        log.info("Attempting transfer from {} to {} (Mobile: {}) amount: {}", sender.getCustomerId(), receiverCustomerId, receiverMobileNo, amount);
        if (amount <= 0) { // Use <= 0 for validation
            log.warn("Transfer failed: Amount must be positive. Amount: {}", amount);
            return "ERROR:Amount must be positive";
        }

        // Re-enabled password check
//        if (senderPassword == null || senderPassword.trim().isEmpty()) { // Good practice to check if password was provided
//            log.warn("Transfer failed: Sender password not provided by {}", sender.getCustomerId());
//            return "ERROR:Password is required for transfer.";
//        }
//        if (!passwordEncoder.matches(senderPassword, sender.getPassword())) { // <--- UNCOMMENTED
//            log.warn("Transfer failed: Incorrect password for sender {}", sender.getCustomerId());
//            return "ERROR:Incorrect password!";
//        }

        if (sender.getBalance() < amount) {
            log.warn("Transfer failed: Insufficient balance for sender {}. Required: {}, Available: {}", sender.getCustomerId(), amount, sender.getBalance());
            return "ERROR:Insufficient balance!";
        }

        if (sender.getCustomerId().equals(receiverCustomerId)) {
            log.warn("Transfer failed: Sender {} attempting to transfer to self.", sender.getCustomerId());
            return "ERROR:Cannot transfer to yourself.";
        }

        Optional<Customer> receiverOpt = customerRepository.findByCustomerId(receiverCustomerId);
        if (receiverOpt.isEmpty()) {
            log.warn("Transfer failed: Receiver account not found with Customer ID: {}", receiverCustomerId);
            return "ERROR:Receiver account not found.";
        }

        Customer receiver = receiverOpt.get();
        // Add mobile number validation as an extra check
        if (!receiver.getMobileNumber().equals(receiverMobileNo)) {
            log.warn("Transfer failed: Receiver details mismatch for Customer ID: {}. Expected Mobile: {}, Provided: {}", receiverCustomerId, receiver.getMobileNumber(), receiverMobileNo);
            return "ERROR:Receiver details mismatch.";
        }

        sender.setBalance(sender.getBalance() - amount);
        receiver.setBalance(receiver.getBalance() + amount);
        customerRepository.save(sender);
        customerRepository.save(receiver);
        log.info("Balances updated successfully for sender {} and receiver {}.", sender.getCustomerId(), receiver.getCustomerId());


        Transaction senderTx = new Transaction();
        senderTx.setCustomerId(sender.getCustomerId()); // Sender's Customer ID
        senderTx.setMobileNo(sender.getMobileNumber()); // Use relevant mobile number
        senderTx.setType("TRANSFER_OUT"); // Use clearer type
        senderTx.setBalance(amount); // Record the transaction amount
        senderTx.setDescription("Transferred ₹" + String.format("%.2f", amount) + " to " + receiver.getCustomerId() + " (Acc: " + receiver.getAccountNumber() + ")");
        senderTx.setLocalDateTime(LocalDateTime.now());
        senderTx.setSenderAccountNumber(sender.getAccountNumber());
        senderTx.setRecipientAccountNumber(receiver.getAccountNumber());
        senderTx.setBranchCode(sender.getBranchCode()); // Sender's branch context might be relevant
        senderTx.setIfscCode(sender.getIfsCode());     // Sender's IFSC context
        senderTx.setSenderMobileNo(sender.getMobileNumber());
        senderTx.setRecipientMobileNo(receiver.getMobileNumber());
        transactionRepository.save(senderTx);
        log.info("Saved sender transaction record for {}.", sender.getCustomerId());

        // Receiver Transaction Record
        Transaction receiverTx = new Transaction();
        receiverTx.setCustomerId(receiver.getCustomerId());
        receiverTx.setMobileNo(receiver.getMobileNumber());
        receiverTx.setType("TRANSFER_IN");
        receiverTx.setBalance(amount);
        receiverTx.setDescription("Received ₹" + String.format("%.2f", amount) + " from " + sender.getCustomerId() + " (Acc: " + sender.getAccountNumber() + ")");
        receiverTx.setLocalDateTime(LocalDateTime.now());
        receiverTx.setSenderAccountNumber(sender.getAccountNumber());
        receiverTx.setRecipientAccountNumber(receiver.getAccountNumber());
        receiverTx.setBranchCode(receiver.getBranchCode()); // Receiver's branch context (should be receiver.getBranchCode())
        receiverTx.setIfscCode(receiver.getIfsCode());     // Receiver's IFSC context (should be receiver.getIfsCode())
        receiverTx.setSenderMobileNo(sender.getMobileNumber());
        receiverTx.setRecipientMobileNo(receiver.getMobileNumber());
        transactionRepository.save(receiverTx);
        log.info("Saved receiver transaction record for {}.", receiver.getCustomerId());

        return "Money transfer successful. ₹" + String.format("%.2f", amount) + " has been transferred to " + receiver.getCustomerId();
    }

    @Transactional(readOnly = true)
    public byte[] generateTransactionHistoryPdf(String customerId, LocalDate startDate, LocalDate endDate) throws Exception {
        log.info("Generating transaction history PDF for Customer ID: {} from {} to {}", customerId, startDate, endDate);

        Optional<Customer> customerOpt = customerRepository.findByCustomerId(customerId);
        if (customerOpt.isEmpty()) {
            log.error("Customer details not found for PDF generation: {}", customerId);
            throw new RuntimeException("Customer details not found for PDF generation: " + customerId);
        }
        Customer customer = customerOpt.get();

        LocalDateTime startDateTime = startDate.atStartOfDay();
        LocalDateTime endDateTime = endDate.atTime(LocalTime.MAX); // Ensure end date is inclusive

        log.debug("Querying transactions between {} and {}", startDateTime, endDateTime);

        // Fetch transactions for the customer within the date range
        List<Transaction> transactions = transactionRepository.findByCustomerIdAndLocalDateTimeBetweenOrderByLocalDateTimeDesc(
                customerId,
                startDateTime,
                endDateTime
        );

        log.info("Found {} transactions for Customer ID: {}", transactions.size(), customerId);

        // --- PDF Generation Logic ---
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        Document document = new Document(PageSize.A4, 36, 36, 54, 36); // Added margins (left, right, top, bottom)
        try {
            PdfWriter writer = PdfWriter.getInstance(document, baos);
            // Optional: Add Header/Footer Events for page numbers etc. (more advanced)
            document.open();

            // Fonts
            Font titleFont = FontFactory.getFont(FontFactory.HELVETICA_BOLD, 16, BaseColor.DARK_GRAY);
            Font headerFont = FontFactory.getFont(FontFactory.HELVETICA_BOLD, 10, BaseColor.WHITE);
            Font infoFont = FontFactory.getFont(FontFactory.HELVETICA, 10, BaseColor.BLACK);
            Font dataFont = FontFactory.getFont(FontFactory.HELVETICA, 9, BaseColor.BLACK);
            Font footerFont = FontFactory.getFont(FontFactory.HELVETICA, 8, Font.ITALIC, BaseColor.GRAY);

            // Title Section
            Paragraph title = new Paragraph("Transaction History", titleFont);
            title.setAlignment(Element.ALIGN_CENTER);
            document.add(title);

            DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("dd-MMM-yyyy");
            Paragraph dateRange = new Paragraph(
                    "For Period: " + startDate.format(dateFormatter) + " to " + endDate.format(dateFormatter),
                    infoFont);
            dateRange.setAlignment(Element.ALIGN_CENTER);
            dateRange.setSpacingAfter(10f);
            document.add(dateRange);


            // Customer Information Section
            PdfPTable infoTable = new PdfPTable(2);
            infoTable.setWidthPercentage(100);
            infoTable.setWidths(new float[]{1f, 3f});
            infoTable.setSpacingAfter(15f);
            infoTable.getDefaultCell().setBorder(Rectangle.NO_BORDER); // No borders for info table cells

            infoTable.addCell(new Phrase("Customer Name:", infoFont));
            infoTable.addCell(new Phrase(customer.getFname() + " " + customer.getLname(), infoFont));
            infoTable.addCell(new Phrase("Customer ID:", infoFont));
            infoTable.addCell(new Phrase(customer.getCustomerId(), infoFont));
            infoTable.addCell(new Phrase("Account Number:", infoFont));
            infoTable.addCell(new Phrase(customer.getAccountNumber(), infoFont));
            infoTable.addCell(new Phrase("Mobile Number:", infoFont));
            infoTable.addCell(new Phrase(customer.getMobileNumber(), infoFont));
            // Optional: Add current balance if needed, but statement usually shows transactions
            // infoTable.addCell(new Phrase("Balance as of " + LocalDate.now().format(dateFormatter) + ":", infoFont));
            // infoTable.addCell(new Phrase("₹" + String.format("%.2f", customer.getBalance()), infoFont));
            document.add(infoTable);


            // Transactions Table
            if (transactions.isEmpty()) {
                Paragraph noData = new Paragraph("No transactions found for the selected period.", infoFont);
                noData.setAlignment(Element.ALIGN_CENTER);
                document.add(noData);
            } else {
                PdfPTable table = new PdfPTable(5); // Date/Time, Description, Type, Amount, Counterparty/Details
                table.setWidthPercentage(100);
                table.setSpacingBefore(10f);
                table.setWidths(new float[]{2f, 3.5f, 1.5f, 1.5f, 2.5f}); // Adjusted widths

                // Table Header
                PdfPCell cell = new PdfPCell(new Phrase("Date & Time", headerFont));
                cell.setBackgroundColor(BaseColor.DARK_GRAY); cell.setHorizontalAlignment(Element.ALIGN_CENTER); cell.setPadding(5); table.addCell(cell);
                cell = new PdfPCell(new Phrase("Description", headerFont));
                cell.setBackgroundColor(BaseColor.DARK_GRAY); cell.setHorizontalAlignment(Element.ALIGN_CENTER); cell.setPadding(5); table.addCell(cell);
                cell = new PdfPCell(new Phrase("Type", headerFont));
                cell.setBackgroundColor(BaseColor.DARK_GRAY); cell.setHorizontalAlignment(Element.ALIGN_CENTER); cell.setPadding(5); table.addCell(cell);
                cell = new PdfPCell(new Phrase("Amount (₹)", headerFont));
                cell.setBackgroundColor(BaseColor.DARK_GRAY); cell.setHorizontalAlignment(Element.ALIGN_CENTER); cell.setPadding(5); table.addCell(cell);
                cell = new PdfPCell(new Phrase("Details", headerFont));
                cell.setBackgroundColor(BaseColor.DARK_GRAY); cell.setHorizontalAlignment(Element.ALIGN_CENTER); cell.setPadding(5); table.addCell(cell);
                table.setHeaderRows(1);

                // Table Data
                DateTimeFormatter tableDateFormatter = DateTimeFormatter.ofPattern("dd-MM-yy HH:mm:ss");
                BaseColor creditColor = new BaseColor(0, 128, 0); // Green
                BaseColor debitColor = BaseColor.RED;

                for (Transaction tx : transactions) {
                    // Date/Time
                    PdfPCell dataCell = new PdfPCell(new Phrase(tx.getLocalDateTime().format(tableDateFormatter), dataFont));
                    dataCell.setPadding(4); dataCell.setVerticalAlignment(Element.ALIGN_MIDDLE); table.addCell(dataCell);

                    // Description
                    dataCell = new PdfPCell(new Phrase(tx.getDescription() != null ? tx.getDescription() : "-", dataFont));
                    dataCell.setPadding(4); dataCell.setVerticalAlignment(Element.ALIGN_MIDDLE); table.addCell(dataCell);

                    // Type
                    dataCell = new PdfPCell(new Phrase(tx.getType() != null ? tx.getType().replace("_", " ") : "-", dataFont)); // Replace underscore for readability
                    dataCell.setPadding(4); dataCell.setHorizontalAlignment(Element.ALIGN_CENTER); dataCell.setVerticalAlignment(Element.ALIGN_MIDDLE); table.addCell(dataCell);

                    // Amount (with color coding)
                    Font amountFont = new Font(dataFont);
                    String amountStr = String.format("%.2f", tx.getBalance()); // Balance holds the transaction amount here
                    if (tx.getType() != null && (tx.getType().contains("IN") || tx.getType().contains("DEPOSIT"))) {
                        amountFont.setColor(creditColor);
                        amountStr = "+ " + amountStr;
                    } else if (tx.getType() != null && (tx.getType().contains("OUT") || tx.getType().contains("WITHDRAW"))) {
                        amountFont.setColor(debitColor);
                        amountStr = "- " + amountStr;
                    }
                    dataCell = new PdfPCell(new Phrase(amountStr, amountFont));
                    dataCell.setPadding(4); dataCell.setHorizontalAlignment(Element.ALIGN_RIGHT); dataCell.setVerticalAlignment(Element.ALIGN_MIDDLE); table.addCell(dataCell);


                    // Details / Counterparty
                    String details = "-";
                    if ("TRANSFER_OUT".equals(tx.getType())) {
                        details = "To: " + (tx.getRecipientAccountNumber() != null ? tx.getRecipientAccountNumber() : "N/A");
                    } else if ("TRANSFER_IN".equals(tx.getType())) {
                        details = "From: " + (tx.getSenderAccountNumber() != null ? tx.getSenderAccountNumber() : "N/A");
                    } else if ("DEPOSIT".equals(tx.getType())) {
                        details = "Self Deposit"; // Example
                    } else if ("WITHDRAWAL".equals(tx.getType())) {
                        details = "Self Withdrawal"; // Example
                    }
                    dataCell = new PdfPCell(new Phrase(details, dataFont));
                    dataCell.setPadding(4); dataCell.setVerticalAlignment(Element.ALIGN_MIDDLE); table.addCell(dataCell);
                }
                document.add(table);
            }

            // Footer
            Paragraph footer = new Paragraph(
                    "Report generated on: " + LocalDateTime.now().format(DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss")) +
                            " | This is a computer-generated statement and requires no signature.",
                    footerFont
            );
            footer.setAlignment(Element.ALIGN_CENTER);
            footer.setSpacingBefore(15f);
            document.add(footer);

        } catch (DocumentException e) {
            log.error("Error during PDF document generation for customer {}: {}", customerId, e.getMessage(), e);
            throw new Exception("Error generating PDF document.", e); // Re-throw as a checked exception or specific runtime exception
        } finally {
            if (document.isOpen()) {
                document.close(); // Essential to finalize the PDF
            }
        }
        log.info("Successfully generated PDF byte array for customer {}", customerId);
        return baos.toByteArray();
    }

    // Keep getBalance method as is
    // ...
}














--- main\resources\application.properties ---
spring.jpa.hibernate.ddl-auto=update 
spring.datasource.url=jdbc:mysql://localhost:3306/banking_somnath
spring.datasource.username=root
spring.datasource.password=$@Mewo@7718
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.jpa.show-sql=true
org.springframework.web=DEBUG 
org.springframework.security=DEBUG
org.apache.coyote.http11=DEBUG
logging.level.org.springframework.security=DEBUG



--- test\java\com\Banking_Somnath\banking_systemn\BankingSystemnApplicationTests.java ---
package com.Banking_Somnath.banking_systemn;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class 	BankingSystemnApplicationTests {

	@Test
	void contextLoads() {
	}

}

>>>>>>> 1adb2d6168a408438343b338b26c1ecd27c3f347
